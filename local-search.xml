<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>consul</title>
    <link href="/2023/02/04/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/consul/consul/"/>
    <url>/2023/02/04/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/consul/consul/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkQzi14_daTk2E4nXJ1DJDv0wfIH.png"></p><ul><li>Consul 支持多数据中心，在上图中有两个数据中心(DateCenter)，数据中心之间通过 Internet 互联，为了提高通信效率，只有 Server 节点才能加入跨数据中心的通信。</li><li>在单个数据中心中，Consul 分为 Client 和 Server 两种节点(所有的节点被称为 Agent)。<ul><li>Server 节点保存数据，推荐数量是 3 个或者 5 个；</li><li>Client 节点负责健康检查及转发数据请求到 Server。</li></ul></li><li>Server 节点包含一个 Leader 和多个 Follower,Leader 节点会将数据同步到 Follower，在 Leader 挂掉的时候会启动选举机制产生一个新的 Leader。</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Atlas简单介绍</title>
    <link href="/2023/01/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/Atlas%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/01/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/Atlas%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Atlas 是一组可伸缩和可扩展的核心基础治理服务——使企业能够有效且高效地满足其在 Hadoop 中的合规性要求，并允许与整个企业数据生态系统集成。<br>Apache Atlas 为组织提供开放的元数据管理和治理功能，以构建其数据资产的目录，对这些资产进行分类和治理，并为数据科学家、分析师和数据治理团队提供围绕这些数据资产的协作能力。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>元数据管理<br>数据血缘查询<br>审计</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Foz_hdn5PfKuiRBvJ7G9CowzgS-L.png"></p><h1 id="Atlas-获取元数据方式"><a href="#Atlas-获取元数据方式" class="headerlink" title="Atlas 获取元数据方式"></a>Atlas 获取元数据方式</h1><p>/opt/module/atlas/hook-bin/import-hive.sh 该脚本同步全量数据<br>通过配置的 hook 同步增量数据（sources -&gt; kafka -&gt; core -&gt; store）</p><h1 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h1><h2 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h2><p>topic-ATLAS_HOOK:<br>来自各个组件的 Hook 的元数据通知事件通过写入到名为 ATLAS_HOOK 的 Kafka topic 发送到 Atlas.<br>topic-ATLAS_ENTITIES：<br>从 Atlas 到其他集成组件（如 Ranger）的事件写入到名为 ATLAS_ENTITIES 的 Kafka topic</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><a href="https://atlas.apache.org/api/v2/ui/index.html#/">https://atlas.apache.org/api/v2/ui/index.html#/</a></p><h1 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h1><h2 id="Type-System"><a href="#Type-System" class="headerlink" title="Type System"></a>Type System</h2><p>Atlas 允许用户为他们想要管理的元数据对象定义一个模型。该模型由称为“types” 的定义组成。“types” （类）的实例被称为 “entities” 表示被管理的实际元数据对象</p><h2 id="Graph-Engine"><a href="#Graph-Engine" class="headerlink" title="Graph Engine"></a>Graph Engine</h2><p>在内部，Atlas 通过使用图模型管理元数据对象。以实现元数据对象之间的巨大灵活性和丰富的关系。图形引擎是负责在类型系统的类型和实体之间进行转换的组件，以及基础图形模型。<br>除了管理图形对象之外，图形引擎还为元数据对象创建适当的索引，以便有效地搜索它们</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a><strong>Glossary</strong></h2><p>词汇表为业务用户提供适当的词汇表，它允许术语（单词）彼此相关并进行分类，以便在不同的上下文中可以理解它们。然后可以将这些术语映射到数据库、表、列等资产。这有助于抽象化与存储库相关的技术术语，并允许用户发现/使用他们更熟悉的词汇表中的数据。</p><h2 id="Classification-Propagation"><a href="#Classification-Propagation" class="headerlink" title="Classification Propagation"></a>Classification Propagation</h2><ul><li>分类传播使与实体相关联的分类能够自动与该实体的其他相关实体相关联。这在处理数据集从其他数据集派生数据的场景时非常有用——比如在文件中加载数据的表，从表/视图生成的报告等。</li><li>例如，当一个表被归类为<em>PII</em>时，从该表派生数据的表或视图将被自动归类为<em>PII</em>。</li><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fh_R29vfYGZx9nTwqQWMqL2QgQD4.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Atlas安装</title>
    <link href="/2023/01/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/Atlas%E5%AE%89%E8%A3%85/"/>
    <url>/2023/01/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/Atlas%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Solr-安装"><a href="#1-Solr-安装" class="headerlink" title="1. Solr 安装"></a>1. Solr 安装</h1><p>需要在三个节点都执行</p><h2 id="1-1-创建系统用户-solr"><a href="#1-1-创建系统用户-solr" class="headerlink" title="1.1 创建系统用户 solr"></a>1.1 创建系统用户 solr</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo useradd solr<br><span class="hljs-keyword">echo</span> solr | sudo passwd <span class="hljs-params">--stdin</span> solr<br></code></pre></td></tr></table></figure><h2 id="1-2-上传-solr-安装包-solr-7-7-3-tgz，并解压到-opt-module-目录，重命名为-solr"><a href="#1-2-上传-solr-安装包-solr-7-7-3-tgz，并解压到-opt-module-目录，重命名为-solr" class="headerlink" title="1.2 上传 solr 安装包 solr-7.7.3.tgz，并解压到/opt/module 目录，重命名为 solr"></a>1.2 上传 solr 安装包 solr-7.7.3.tgz，并解压到/opt/module 目录，重命名为 solr</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf solr-<span class="hljs-number">7</span>.<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.tgz -C /opt/module/<br><span class="hljs-attribute">cd</span> /opt/module<br><span class="hljs-attribute">mv</span> solr-<span class="hljs-number">7</span>.<span class="hljs-number">7</span>.<span class="hljs-number">3</span>/ solr<br></code></pre></td></tr></table></figure><h2 id="1-3-修改-solr-目录的所有者为-solr-用户"><a href="#1-3-修改-solr-目录的所有者为-solr-用户" class="headerlink" title="1.3 修改 solr 目录的所有者为 solr 用户"></a>1.3 修改 solr 目录的所有者为 solr 用户</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo chown -R solr:solr <span class="hljs-regexp">/opt/m</span>odule/solr<br></code></pre></td></tr></table></figure><h2 id="1-4-修改-solr-配置"><a href="#1-4-修改-solr-配置" class="headerlink" title="1.4 修改 solr 配置"></a>1.4 修改 solr 配置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/solr/</span>bin/solr.<span class="hljs-keyword">in</span>.sh<br><br><span class="hljs-comment"># 修改ZK_HOST</span><br>ZK_HOST=<span class="hljs-string">&quot;szst-dev-bigdata-05:2181,szst-dev-bigdata-06:2181,szst-dev-bigdata-07:2181&quot;</span><br></code></pre></td></tr></table></figure><h2 id="1-5-启动-solr"><a href="#1-5-启动-solr" class="headerlink" title="1.5 启动 solr"></a>1.5 启动 solr</h2><p>启动前需要保证 ZK 已正常运行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 三个节点各自执行</span><br>sudo -i -u solr <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/solr/</span>bin/solr start<br></code></pre></td></tr></table></figure><h2 id="1-6-访问-web-页面"><a href="#1-6-访问-web-页面" class="headerlink" title="1.6 访问 web 页面"></a>1.6 访问 web 页面</h2><p>默认端口为 8983，可指定三台节点中的任意一台 IP，<a href="http://szst-dev-bigdata-05:8983/">http://szst-dev-bigdata-05:8983</a></p><h1 id="2-Atlas-安装"><a href="#2-Atlas-安装" class="headerlink" title="2 Atlas 安装"></a>2 Atlas 安装</h1><h2 id="2-1-解压-apache-atlas-2-1-0-server-tar-gz-到-opt-module-目录下面"><a href="#2-1-解压-apache-atlas-2-1-0-server-tar-gz-到-opt-module-目录下面" class="headerlink" title="2.1 解压 apache-atlas-2.1.0-server.tar.gz 到/opt/module/目录下面"></a>2.1 解压 apache-atlas-2.1.0-server.tar.gz 到/opt/module/目录下面</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf apache-atlas-<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-server.tar.gz -C /opt/module/<br><span class="hljs-attribute">cd</span> /opt/module/<br><span class="hljs-attribute">mv</span> apache-atlas-<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> atlas<br></code></pre></td></tr></table></figure><h2 id="2-2-Atlas-配置"><a href="#2-2-Atlas-配置" class="headerlink" title="2.2 Atlas 配置"></a>2.2 <strong>Atlas 配置</strong></h2><p>配置完以下内容后，根据实际需要集成对应的组件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># atlas集成hbase</span><br><span class="hljs-attribute">atlas</span>.graph.storage.hostname=szst-dev-bigdata-<span class="hljs-number">05</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">06</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">07</span>:<span class="hljs-number">2181</span><br><span class="hljs-attribute">export</span> HBASE_CONF_DIR=/opt/datasophon/hbase-<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>/conf<br><br><span class="hljs-comment"># atlas集成solr</span><br><span class="hljs-attribute">atlas</span>.graph.index.search.backend=solr<br><span class="hljs-attribute">atlas</span>.graph.index.search.solr.mode=cloud<br><span class="hljs-attribute">atlas</span>.graph.index.search.solr.zookeeper-url=szst-dev-bigdata-<span class="hljs-number">05</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">06</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">07</span>:<span class="hljs-number">2181</span><br><br><span class="hljs-comment"># atlas集成kafka</span><br><span class="hljs-attribute">atlas</span>.notification.embedded=false<br><span class="hljs-attribute">atlas</span>.kafka.data=/data/kafka-logs<br><span class="hljs-attribute">atlas</span>.kafka.zookeeper.connect=szst-dev-bigdata-<span class="hljs-number">05</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">06</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">07</span>:<span class="hljs-number">2181</span><br><span class="hljs-attribute">atlas</span>.kafka.bootstrap.servers=szst-dev-bigdata-<span class="hljs-number">05</span>:<span class="hljs-number">9092</span>,szst-dev-bigdata-<span class="hljs-number">06</span>:<span class="hljs-number">9092</span>,szst-dev-bigdata-<span class="hljs-number">07</span>:<span class="hljs-number">9092</span><br><br><span class="hljs-comment"># atlas server配置</span><br><span class="hljs-comment">######### Server Properties #########</span><br><span class="hljs-attribute">atlas</span>.rest.address=http://szst-dev-bigdata-<span class="hljs-number">05</span>:<span class="hljs-number">21000</span><br><span class="hljs-comment"># If enabled and set to true, this will run setup steps when the server starts</span><br><span class="hljs-attribute">atlas</span>.server.run.setup.<span class="hljs-literal">on</span>.start=false<br><span class="hljs-comment">######### Entity Audit Configs #########</span><br><span class="hljs-attribute">atlas</span>.audit.hbase.tablename=apache_atlas_entity_audit<br><span class="hljs-attribute">atlas</span>.audit.zookeeper.session.timeout.ms=<span class="hljs-number">1000</span><br><span class="hljs-attribute">atlas</span>.audit.hbase.zookeeper.quorum=szst-dev-bigdata-<span class="hljs-number">05</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">06</span>:<span class="hljs-number">2181</span>,szst-dev-bigdata-<span class="hljs-number">07</span>:<span class="hljs-number">2181</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo -i -u solr <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/solr/</span>bin<span class="hljs-regexp">/solr create -c vertex_index -d /</span>opt<span class="hljs-regexp">/module/</span>atlas<span class="hljs-regexp">/conf/</span>solr -shards <span class="hljs-number">3</span> -replicationFactor <span class="hljs-number">2</span><br>sudo -i -u solr <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/solr/</span>bin<span class="hljs-regexp">/solr create -c edge_index -d /</span>opt<span class="hljs-regexp">/module/</span>atlas<span class="hljs-regexp">/conf/</span>solr -shards <span class="hljs-number">3</span> -replicationFactor <span class="hljs-number">2</span><br>sudo -i -u solr <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/solr/</span>bin<span class="hljs-regexp">/solr create -c fulltext_index -d /</span>opt<span class="hljs-regexp">/module/</span>atlas<span class="hljs-regexp">/conf/</span>solr -shards <span class="hljs-number">3</span> -replicationFactor <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export HBASE_CONF_DIR=<span class="hljs-regexp">/opt/</span>datasophon<span class="hljs-regexp">/hbase-2.0.2/</span>conf<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">#去掉如下代码的注释</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;perf_appender&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.DailyRollingFileAppender&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;atlas.log.dir&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/atlas_perf.log&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;datePattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;.&#x27;yyyy-MM-dd&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;append&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConversionPattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d|%t|%m%n&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.atlas.perf&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;perf_appender&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="2-3-Atlas-集成组件（以-Hive-为例）"><a href="#2-3-Atlas-集成组件（以-Hive-为例）" class="headerlink" title="2.3 Atlas 集成组件（以 Hive 为例）"></a>2.3 Atlas 集成组件（以 Hive 为例）</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">######### Hive Hook Configs #######<br>atlas.hook.hive.synchronous=false<br>atlas.hook.hive.numRetries=<span class="hljs-number">3</span><br>atlas.hook.hive.queueSize=<span class="hljs-number">10000</span><br>atlas.cluster.name=primary<br></code></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># 配置 Hive Hook</span><br><span class="hljs-variable">&lt;property&gt;</span><br> <span class="hljs-variable">&lt;name&gt;</span>hive.exec.post.hooks<span class="hljs-variable">&lt;/name&gt;</span><br> <span class="hljs-variable">&lt;value&gt;</span>org.apache.atlas.hive.hook.HiveHook<span class="hljs-variable">&lt;/value&gt;</span><br><span class="hljs-variable">&lt;/property&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 解压</span><br>tar -zxvf apache-atlas-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span>-hive-hook.tar.gz<br><span class="hljs-comment"># 将 Hive Hook 依赖复制到 Atlas 安装路径</span><br>cp -r apache-atlas-hive-hook-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/* /</span>opt<span class="hljs-regexp">/module/</span>atlas/<br><br>cd <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hive/</span>conf/<br>mv hive-env.sh.template hive-env.sh<br>vi hive-env.sh<br>增加以下配置 export HIVE_AUX_JARS_PATH=<span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/atlas/</span>hook/hive<br><br><span class="hljs-comment"># 将 Atlas 配置文件/opt/module/atlas/conf/atlas-application.properties拷贝到/opt/module/hive/conf 目录</span><br>cp <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/atlas/</span>conf<span class="hljs-regexp">/atlas-application.properties /</span>opt<span class="hljs-regexp">/module/</span>hive<span class="hljs-regexp">/conf/</span><br></code></pre></td></tr></table></figure><h2 id="2-4-启动-atlas"><a href="#2-4-启动-atlas" class="headerlink" title="2.4 启动 atlas"></a>2.4 启动 atlas</h2><p>依赖环境： hadoop 集群，zookeeper 集群，kafka 集群，hbase 集群，solr 集群</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/atlas/</span>bin/atlas_start.py<br></code></pre></td></tr></table></figure><h2 id="2-5-访问-web-页面"><a href="#2-5-访问-web-页面" class="headerlink" title="2.5 访问 web 页面"></a>2.5 访问 web 页面</h2><p>url:<br><a href="http://szst-dev-bigdata-05:21000/">http://szst-dev-bigdata-05:21000</a><br>账号/密码：<br>admin/admin</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2022/11/30/java%E5%9F%BA%E7%A1%80/JDBC/"/>
    <url>/2022/11/30/java%E5%9F%BA%E7%A1%80/JDBC/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FthfZ5Fl_s7b6BX_nQVV-SJgQJ_5.png"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单播组播与广播</title>
    <link href="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%95%E6%92%AD%E7%BB%84%E6%92%AD%E4%B8%8E%E5%B9%BF%E6%92%AD/"/>
    <url>/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%95%E6%92%AD%E7%BB%84%E6%92%AD%E4%B8%8E%E5%B9%BF%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h1><p>组播是主机间一对多的通讯模式， 组播是一种允许一个或多个组播源发送同一报文到多个接收者的技术。组播源将一份报文发送到特定的组播地址，组播地址不同于单播地址，它并不属于特定某个主机，而是属于一组主机。一个组播地址表示一个群组，需要接收组播报文的接收者都加入这个群组。</p><h1 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h1><p>单播是主机间一对一的通讯模式，网络中的设备根据网络报文中包含的目的地址选择传输路径，将单播报文传送到指定的目的地，只对接收到的数据进行转发，不会进行复制。它能够针对每台主机及时的响应，现在的网页浏览全部都是采用单播模式。<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtpQTBtFGlhKzQyFBR14oCsNtv__.png"></p><h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>广播是主机间一对所有的通讯模式，设备会将报文发送到网络中的所有可能接收者。设备简单地将它收到的任何广播报文都复制并转发到除该报文到达的接口外的每个接口。广播处理流程简单，不用选择路径。<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fgg4vH1F0y4pJKHtHXGwkro6fehN.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flink</title>
    <link href="/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/Flink/"/>
    <url>/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/Flink/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Flink？"><a href="#什么是-Flink？" class="headerlink" title="什么是 Flink？"></a>什么是 Flink？</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsMXaK8CDlh7GUK63ySHXyL3kfQP.png"></p><blockquote><p>Flink 是一个分布式的计算处理引擎</p></blockquote><ul><li>分布式：「它的存储或者计算交由多台服务器上完成，最后汇总起来达到最终的效果」。</li><li>实时：处理速度是毫秒级或者秒级的</li><li>计算：可以简单理解为对数据进行处理，比如清洗数据（对数据进行规整，取出有用的数据）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FlN2MKtjO6zhQqAB13MsjFggsWjd.png"></p><p>基于官网的一句话介绍，我们就可以联想出很多东西。</p><p>这篇文章可以带你简单认识一下 Flink 的一些基础概念，等你真正用到的时候就可以依据这篇文章来对 Flink 进行入门，现在 Storm 都被很多人给抛弃掉了，那么 Flink 优于 Storm 的地方有哪些呢？接下来我们一起来看看 Flink 吧。</p><p>什么是有边界和无边界？<br>Apache Flink 是一个框架和分布式处理引擎，用于在无边界和有边界数据流上进行有状态的计算。</p><p>官方其实也有介绍，但对初学者来说不太好理解，我来幼儿园化一下。</p><p>大家学到 Flink 了，消息队列肯定有用过吧？那你们是怎么用消息队列的呢？Producer 生产数据，发给 Broker，Consumer 消费，完事。</p><p>在消费的时候，我们需要管什么 Producer 什么时候发消息吗？不需要吧。反正来一条，我就处理一条，没毛病吧。</p><p>这种没有做任何处理的消息，默认就是无边界的。</p><p>那有边界就很好理解了：无边界的基础上加上条件，那就是有边界的。加什么条件呢？比如我要加个时间：我要消费从 8 月 8 号到 8 月 9 号的数据，那就是有边界的。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fjh-5bduezp6zuvNVIAnjSnRYHTQ.png"></p><p>什么时候用无边界，什么时候用有边界？那也很好理解。我做数据清洗：来一条，我处理一条，这种无边界的就好了。我要做数据统计：每个小时的 pv(page view)是多少，那我就设置 1 小时的边界，攒着一小时的数据来处理一次。</p><p>在 Flink 上，设置“边界”这种操作叫做开窗口(Windows)，窗口可简单分为两种类型：</p><p>时间窗口(TimeWindows)：按照时间窗口进行聚合，比如上面所讲得攥着一个小时的数据处理一次。<br>计数窗口(CountWindows)：按照指定的条数来进行聚合，比如每来了 10 条数据处理一次。<br>看着就非常人性化（妈妈再也不用担心我需要聚合了）…</p><p>不仅如此，在 Flink 使用窗口聚合的时候，还考虑到了数据的准确性问题。比如说：现在我在 11:06 分产生了 5 条数据，在 11:07 分 产生了 4 条数据，我现在是按每分钟的维度来进行聚合计算。</p><p>理论上来讲：Flink 应该是在 06 分聚合了 5 条数据，在 07 分聚合了 4 条数据。但是，可能由于网络的延迟性等原因，导致 06 分的 3 条数据在 07 分时 Flink 才接收到。如果不做任何处理，那 07 分有可能处理了 7 条条数据。</p><p>某些需要准确结果的场景来说，这就不太合理了。所以 Flink 可以给我们指定”时间语义“，不指定默认是「数据到 Flink 的时间」Processing Time 来进行聚合处理，可以给我们指定聚合的时间以「事件发生的时间」Event Time 来进行处理。</p><p>事件发生的时间指的就是：日志真正记录的时间</p><p>2020-11-22 00:00:02.552 INFO [http-nio-7001-exec-28] c.m.t.rye.admin.web.aop.LogAspect</p><p>虽然指定了聚合的时间为「事件发生的时间」Event Time，但还是没解决数据乱序的问题（06 分产生了 5 条数据，实际上 06 分只收到了 3 条，而剩下的两条在 07 分才收到，那此时怎么办呢？在 06 分时该不该聚合，07 分收到的两条 06 分数据怎么办？）</p><p>Flink 又可以给我们设置水位线(waterMarks)，Flink 意思就是：存在网络延迟等情况导致数据接收不是有序，这种情况我都能理解。你这样吧，根据自身的情况，你可以设置一个「延迟时间」，等延迟的时间到了，我再聚合统一聚合。</p><p>比如说：现在我知道数据有可能会延迟一分钟，那我将水位线 waterMarks 设置延迟一分钟。</p><p>解读：因为设置了「事件发生的时间」Event Time，所以 Flink 可以检测到每一条记录发生的时间，而设置了水位线 waterMarks 设置延迟一分钟，等到 Flink 发现 07 分:59 秒的数据来到了 Flink，那就确信 06 分的数据都来了（因为设置了 1 分钟延迟），此时才聚合 06 分的窗口数据。<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhjQsjN32C23P8CMvyPy43wfZ-_z.png"></p><p>什么叫做有状态？<br>Apache Flink 是一个框架和分布式处理引擎，用于在无边界和有边界数据流上进行有状态的计算。</p><p>什么是有状态，什么是无状态？</p><p>无状态我们可以简单认为：每次的执行都不依赖上一次或上 N 次的执行结果，每次的执行都是独立的。</p><p>有状态我们可以简单认为：执行需要依赖上一次或上 N 次的执行结果，某次的执行需要依赖前面事件的处理结果。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FpXP4P-sPKZmqmPSqkjFaYCwGvIY.png"></p><p>比如，我们现在要统计文章的阅读 PV(page view)，现在只要有一个点击了文章，在 Kafka 就会有一条消息。现在我要在流式处理平台上进行统计，那此时是有状态的还是无状态的？</p><p>假设我们要在 Storm 做，那我们可能将每次的处理结果放到一个“外部存储”中，然后基于这个“外部存储”进行计算（这里我们不用 Storm Trident），那此时 Storm 是无状态的。</p><p>比如说：我存储将每次得到的数据存储到 Redis 中，来一条数据，我就先查一下 Redis 目前的值是多少，跟 Redis 的值和现在的值做一次累加就完事了。</p><p>假设要在 Flink 做，Flink 本身就提供了这种功能给我们使用，我们可以依赖 Flink 的“存储”，将每次的处理结果交由 Flink 管理，执行计算的逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FglSUY0o61_9VvDAmWaWztxTRVuP.png"></p><p>可以简单的认为：Flink 本身就给我们提供了”存储“的功能，而我们每次执行是可以依赖 Flink 的”存储”的，所以它是有状态的。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FonrqiZmSLLQ5T2E8NqHfZsdwPLT.png"></p><p>那 Flink 是把这些有状态的数据存储在哪的呢？</p><p>主要有三个地方：</p><p>内存<br>文件系统（HDFS）<br>本地数据库<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiOhgdp8w34okCfvMhvOfNZ862Rr.png"><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhMRqt7c0S_frH2_T8HeXMXDC5Nf.png"></p><p>如果假设 Flink 挂了，可能内存的数据没了，磁盘可能存储了部分的数据，那再重启的时候（比如消息队列会重新拉取），就不怕会丢了或多了数据吗？</p><p>看到这里，你可能在会在别的地方看过 Flink 的另外一个比较出名的特性：精确一次性</p><p>（简单来说就是：Flink 遇到意外事件挂了以后，有什么机制来尽可能保证处理数据不重复和不丢失的呢）</p><p>什么是精确一次性（exactly once）？<br>众所周知，流的语义性有三种：</p><p>精确一次性（exactly once）：有且只有一条，不多不少<br>至少一次（at least once）：最少会有一条，只多不少<br>最多一次（at most once）：最多只有一条，可能会没有<br>Flink 实现了精确一次性，这个精确一次性是什么意思呢？</p><p>Flink 的精确一次性指的是：状态只持久化一次到最终的存储介质中（本地数据库/HDFS…)<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fo_Iq0AlOjuz-x5gIVZc3Z2uPiV0.png"></p><p>以上面的图为例：Source 数据流有以下数字 21,13,8,5,3,2,1,1，然后在 Flink 需要做累加操作（求和）</p><p>现在处理完 2,1,1 了，所以累加的值是 4，现在 Flink 把累积后的状态 4 已经存储起来了（认为前面 2,1,1 这几个数字已经完全处理过了）。</p><p>程序一直往下走，处理了 5,3，现在累加的值是 12，但现在 Flink 还没来得及把 12 存储到最终的介质，此时系统挂掉了。</p><p>Flink 重启后会重新把系统恢复到累加的值是 4 的状态，所以 5,3 得继续计算一遍，程序继续往下走。</p><p>看文章有的同学可能会认为：精确一次性指的不是某一段代码只会执行一次，不会执行多次或不执行。这 5 和 3 这两个数，你不是重复计算了吗？怎么就精确一次了？</p><p>显然，代码只执行一次肯定是不可能的嘛。我们无法控制系统在哪一行代码挂掉的，你要是在挂的时候，当前方法还没执行完，你还是得重新执行该方法的。</p><p>所以，状态只持久化一次到最终的存储介质中（本地数据库/HDFS)，在 Flink 下就叫做 exactly once（计算的数据可能会重复（无法避免），但状态在存储介质上只会存储一次）。</p><p>那么 Flink 是在多长时间存储一次的呢？这个是我们自己手动配置的。</p><p>所谓的 CheckPoint 其实就是 Flink 会在指定的时间段上保存状态的信息，假设 Flink 挂了可以将上一次状态信息再捞出来，重放还没保存的数据来执行计算，最终实现 exactly once。</p><p>那 CheckPonit 是怎么办到的呢？想想我们在 Kafka 在业务上实现「至少一次」是怎么做的？我们从 Kafka 把数据拉下来，处理完业务了以后，手动提交 offset (告诉 Kafka 我已经处理完了)</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgSqiUqPQHcMS7gUXN4oNHZkwIlt.png"></p><p>我们是做完了业务规则才将 offset 进行 commit 的，checkponit 其实也是一样的（等拉下来该条数据所有的流程走完，才进行真正的 checkponit）。</p><p>问题又来了，那 checkpoint 是怎么知道拉下来的数据已经走完了呢？Flink 在流处理过程中插入了 barrier，每个环节处理到 barrier 都会上报，等到 sink 都上报了 barrier 就说明这次 checkpoint 已经走完了。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmoyOqoDyVwpKAqg9-pVdap9tA1j.png"></p><p>要注意的是，Flink 实现的精确一次性只是保证内部的状态是精确一次的，如果想要端到端精确一次，需要端的支持</p><p>数据源需要可回放，发证故障可以重新读取未确认的数据<br>Flink 需要把数据存到磁盘介质（不能用内存），发生故障可以恢复<br>发送源需要支持事务（从读到写需要事务的支持保证中途不失败）</p><p>最后<br>这篇文章对 Flink 做了一次简单的介绍，希望对大家在入门的时候有所帮助。后续打算会再写一篇 Flink 文章对 CheckPoint 机制做更加深入的了解，有兴趣的同学可以点个关注第一时间能接收到。<br>————————————————<br>版权声明：本文为 CSDN 博主「Java3y」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Java_3y/article/details/110184903">https://blog.csdn.net/Java_3y/article/details/110184903</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop</title>
    <link href="/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    <url>/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="三大发行版本"><a href="#三大发行版本" class="headerlink" title="三大发行版本"></a>三大发行版本</h1><ol><li>Apache 版本<ol><li>最原始（最基础）的版本，对于入门学习最好。</li><li>组件兼容性需要自己调研</li></ol></li><li>CDH<ol><li>开源</li><li>在大型互联网企业中用的较多。</li></ol></li><li>HDP<ol><li>开源，可以二次开发</li><li>没有 cdh 稳定，使用较少</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>技术栈</title>
    <link href="/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <url>/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th><strong>类别</strong></th><th></th><th><strong>主流代表技术</strong></th></tr></thead><tbody><tr><td>分布式文件系统</td><td></td><td>Hadoop HDFS</td></tr><tr><td>资源调度与管理</td><td></td><td>Hadoop YARN 、Kubernetes</td></tr></tbody></table><p>|</p><p>分布式计算 | 批处理：特点是有界、持久、大量，非常适合需要访问全套记录才能完成的计算工作，一般用于离线统计。</p><p>| MapReduce（中间过程会落盘，慢）<br>Hive<br>Spark |<br>| | 流处理：特点是无界、实时, 无需针对整个数据集执行操作，而是对通过系统传输的每个数据项执行操作，一般用于实时统计。 | Spark Streaming（微批处理）、<br>Flink</p><p>|</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简介</title>
    <link href="/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/06/06/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="主要解决问题："><a href="#主要解决问题：" class="headerlink" title="主要解决问题："></a>主要解决问题：</h1><p>海量的数据存储 海量数据的分析计算</p><h1 id="大数据技术的特点："><a href="#大数据技术的特点：" class="headerlink" title="大数据技术的特点："></a>大数据技术的特点：</h1><p>高可靠性：数据多副本，某个存储故障不会导致数据丢失。<br>高扩展性：随着数据量的增大，可以横向扩展数以千计的节点。<br>高效性：数据处理和计算是并行工作的，以加快数据处理速度。<br>高容错性: 因为外部原因（硬件、网络）处理出现错误，可以自动重新分配，继续提供服务。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker常用操作</title>
    <link href="/2022/03/12/%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/03/12/%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<ul><li>抓取 image<ul><li>docker image pull [组]/[image 文件名]</li></ul></li><li>查看 image<ul><li>docker image ls</li><li>docker images</li></ul></li><li>运行<ul><li>根据 image 文件，每次都生成一个正在运行的容器实例，若本地没有该 image，则从仓库自动抓取<ul><li>docker run -itd –name redis -p 6379:6379 redis</li><li>docker run –name nginx -p 8080:80 -d nginx</li></ul></li><li>启动已经生成并停止运行的 container<ul><li>docker container start [containID]</li></ul></li></ul></li><li>终止<ul><li>强行立即终止（SIGKILL）<ul><li>docker container kill [containID]</li></ul></li><li>应用程序可以进行一些收尾工作（SIGTERM）<ul><li>docker container stop [containID]</li></ul></li></ul></li><li>查看 container<ul><li>正在运行<ul><li>docker container ls</li></ul></li><li>所有：正在运行的+停止运行的<ul><li>docker container ls -all</li></ul></li></ul></li><li>删除 container<ul><li>docker container rm [containID]</li></ul></li><li>创建 image 文件<ul><li>docker image build -t [imageName] . (. 表示 Dockerfile 文件路径)</li></ul></li><li>查看 log 输出<ul><li>docker container logs [containerID]</li></ul></li><li>进入容器<ul><li>docker container exec -it [containerID] /bin/bash</li></ul></li><li>拷贝文件至本机<ul><li>docker container cp [containID]:[/path/to/file] .</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/21/hello-world/"/>
    <url>/2022/02/21/hello-world/</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">本地重新启动</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">清除缓存文件 db.json 和已生成的静态文件 public</span><br>hexo clean<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br>hexo g<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">启动服务器。默认情况下，访问网址为： http://localhost:4000/</span><br>hexo server <br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br>hexo d<br></code></pre></td></tr></table></figure><ul><li>更换主题<ul><li>cd /Users/will/blog</li><li>git clone <a href="https://github.com/iissnan/hexo-theme-next.git">https://github.com/iissnan/hexo-theme-next.git</a> themes/iissan</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法题</title>
    <link href="/2021/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-如何用栈模拟队列"><a href="#1-如何用栈模拟队列" class="headerlink" title="1 如何用栈模拟队列"></a>1 如何用栈模拟队列</h1><p>用两个栈来翻转压入栈的数据实现先进先出</p><hr><h1 id="2-LRU-算法有哪些数据结构实现"><a href="#2-LRU-算法有哪些数据结构实现" class="headerlink" title="2 LRU 算法有哪些数据结构实现"></a>2 LRU 算法有哪些数据结构实现</h1><p>Least Recently Used<br><a href="https://www.cnblogs.com/kyoner/p/11179766.html">https://www.cnblogs.com/kyoner/p/11179766.html</a><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqwNaHrKlw-H-cK4ukbvXXpFFY_9.png"><br>保证查询和删除插入的都足够快</p><ul><li>双向链表<ul><li>链表：可以包含节点顺序信息，找到最末几位的节点删除</li><li>双向：删除时需要找到前一个节点修改引用</li></ul></li><li>hash<ul><li>查询操作 O(1)级别时间复杂度</li></ul></li></ul><hr><h1 id="雪花算法会生成重复-ID-吗？如何避免？"><a href="#雪花算法会生成重复-ID-吗？如何避免？" class="headerlink" title="雪花算法会生成重复 ID 吗？如何避免？"></a>雪花算法会生成重复 ID 吗？如何避免？</h1><p><a href="https://www.jianshu.com/p/71286e89e0c5">https://www.jianshu.com/p/71286e89e0c5</a><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fu_PcdvDUJnnvHtem4tXy2uAqc4p.png"></p><ul><li>其中位数可以自定义</li><li>如果能够保证每个节点都有自己的工作机器 id，就不会有重复<ul><li>当多个节点对应的 workerId 重复时，可能会有重复的 id 生成</li><li>所以需要保证每个节点都有自己的 workerId</li></ul></li><li>workerId 和时间戳相同时，当生成的 id 过多，序列号用完的情况下<ul><li>直接阻塞线程，让时间顺延到下一毫秒，再生成 id</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="/2021/12/21/java%E5%9F%BA%E7%A1%80/Stream/"/>
    <url>/2021/12/21/java%E5%9F%BA%E7%A1%80/Stream/</url>
    
    <content type="html"><![CDATA[<h1 id="1-parallelStream-原理"><a href="#1-parallelStream-原理" class="headerlink" title="1. parallelStream 原理"></a>1. parallelStream 原理</h1><p><a href="https://zhuanlan.zhihu.com/p/440286561">https://zhuanlan.zhihu.com/p/440286561</a></p><p>parallelStream 使用的是 Fork/Join 框架。Fork/Join 框架自 JDK 7 引入。Fork/Join 框架可以将一个大任务拆分为很多小 任务来异步执行。 Fork/Join 框架主要包含三个模块：</p><ol><li>线程池：ForkJoinPool</li><li>任务对象：ForkJoinTask</li><li>执行任务的线程：ForkJoinWorkerThread</li></ol><p>特点：</p><ol><li>parallelStream 适用的场景是 CPU 密集型的，只是做到别浪费 CPU，假如本身电脑 CPU 的负载很大，那还到处用 并行流，那并不能起到作用</li><li>所有的并行流计算默认都共享一个 ForkJoinPool，这个共享的 ForkJoinPool 的默认线程数是 CPU 核数；</li><li>若所有并行流计算都是 CPU 密集型，完全没有问题，<strong>但若存在 I/O 密集型并行流计算，那很可能因为一个很慢的 I/O 计算而拖慢整个系统的性能</strong>。所以建议用不同 ForkJoinPool 执行不同类型的计算任务。</li><li>在使用并行流的时候是无法保证元素的顺序的，也就是即使你用了同步集合也只能保证元素都正确但无法保证 其中的顺序</li></ol><h2 id="1-1-Fork-Join"><a href="#1-1-Fork-Join" class="headerlink" title="1.1 Fork/Join"></a>1.1 Fork/Join</h2><p>Doug Lea 在 JDK1.7 中引入</p><h3 id="1-分治法"><a href="#1-分治法" class="headerlink" title="1) 分治法"></a>1) 分治法</h3><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiLj7LPedN0AQhvUoQegThfi3Vdg.png"><br>ForkJoinPool 主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法， ForkJoinPool 需要使用相对少的线程来处理大量的任务。比如要对 1000 万个数据进行排序，那么会将这个任务分割成 两个 500 万的排序任务和一个针对这两组 500 万数据的合并任务。以此类推，对于 500 万的数据也会做出同样的分割处 理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于 10 时，会停 止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概 2000000+个。问题的关键在 于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。</p><h3 id="2-工作窃取算法"><a href="#2-工作窃取算法" class="headerlink" title="2) 工作窃取算法"></a>2) 工作窃取算法</h3><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgrNMYeHi-IpmGYueOeqkDssCnua.png"><br>Fork/Join 最核心的地方就是利用了现代硬件设备多核，在一个操作时候会有空闲的 cpu，那么如何利用好这个空闲的 cpu 就成了提高性能的关键，而这里我们要提到的工作窃取（work-stealing）算法就是整个 Fork/Join 框架的核心理念 Fork/Join 工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。<br>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖 的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来 执行队列里的任务，线程和队列一一对应，比如 A 线程负责处理 A 队列里的任务。但是有的线程会先把自己队列里的 任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就 去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任 务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永 远从双端队列的尾部拿任务执行。<br>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争， 比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础</title>
    <link href="/2021/11/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/11/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ApplicationContext-和-BeanFactory-的区别："><a href="#1-ApplicationContext-和-BeanFactory-的区别：" class="headerlink" title="1 ApplicationContext 和 BeanFactory 的区别："></a>1 ApplicationContext 和 BeanFactory 的区别：</h1><ul><li>可以从 ApplicationContext 继承的这几个接口入手，除去 BeanFactory 相关的两个接口就是 ApplicationContext 独有的功能<ul><li>MessageSource 国际化</li><li>Event 事件机制</li><li>扩展了 ResourceLoader(资源加载器)接口，从而可以用来加载多个 Resource</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FuCwiD4y3NSp2q5LAEgw3poTu1RH.png"></p><ul><li>BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用 getBean())，才对该 Bean 进行加载实例化，这样，我们就不能发现一些存在的 Spring 的配置问题。而 ApplicationContext 则相反，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误。</li><li></li></ul><hr><h1 id="2-bean-的生命周期"><a href="#2-bean-的生命周期" class="headerlink" title="2 bean 的生命周期"></a>2 bean 的生命周期</h1><p><a href="https://www.jianshu.com/p/1dec08d290c1">https://www.jianshu.com/p/1dec08d290c1</a><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiS3sz2bGrxQ9Xx0bEgMVcpXqPQg.png"></p>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>定位线程占用资源问题的方法与步骤</title>
    <link href="/2021/11/02/%E5%91%BD%E4%BB%A4/%E5%AE%9A%E4%BD%8D%E7%BA%BF%E7%A8%8B%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E6%AD%A5%E9%AA%A4/"/>
    <url>/2021/11/02/%E5%91%BD%E4%BB%A4/%E5%AE%9A%E4%BD%8D%E7%BA%BF%E7%A8%8B%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定位有问题的-java-进程"><a href="#1-定位有问题的-java-进程" class="headerlink" title="1 定位有问题的 java 进程"></a>1 定位有问题的 java 进程</h1><ul><li>top</li></ul><p>可以通过 top 命令，或者 jps 命令找到对应的 java 进程 ID，以 top 命令为例，这里 mainfabcore 的进程 id 是 8856<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FjrYk7-JAE2qY74xH_zDNNTKLtT2.png"></p><h1 id="2-定位消耗资源较高的线程"><a href="#2-定位消耗资源较高的线程" class="headerlink" title="2 定位消耗资源较高的线程"></a>2 定位消耗资源较高的线程</h1><ul><li>top -Hp {pid}</li></ul><p>获取到进程 ID 以后，可以使用 top -Hp {pid}获取线程情况，以上图中的进程 id 8856 为例<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsNy5xqgmUa5eALFdJ8PNNQRMEg4.png"></p><ul><li>printf %x {线程 id}</li></ul><p>先转换成 16 进制，以 8908 线程 id 为例<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtXuAOOyqebWm0rkuxHv8p1lnw5j.png"></p><h1 id="3-查看线程当前执行情况"><a href="#3-查看线程当前执行情况" class="headerlink" title="3 查看线程当前执行情况"></a>3 查看线程当前执行情况</h1><ul><li>jstack {java 进程 id} | grep ‘{16 进制的线程 id}’ -A 20</li></ul><p>例子中：jstack 8856 | grep ‘0x22cc’ -A 20<br>jstack 890 | grep ‘12f9’ -A 20<br>根据这个 16 进制的线程 id，去查看当前执行情况，用 jstask 命令<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fv62-Oc63wGdDuL43NM4utIs2YKR.png"><br>从上图可以看到，当前线程处于 TIMED WAITING 状态，等待操作系统调度，正常。当前执行的代码是线程池中执行部分，非业务代码，因此属于正常状态。</p>]]></content>
    
    
    <categories>
      
      <category>命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Logback配置</title>
    <link href="/2021/10/29/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/log/Logback%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/29/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/log/Logback%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- scan-配置文件被修改时是否重新加载，scanPeriod-监测配置文件是否有修改的时间间隔， debug-是否打印logback日志--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;60000&quot;</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置变量 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;APP_Name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;myAppName&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>$&#123;APP_Name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logback.LogbackDemo&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- scan-配置文件被修改时是否重新加载，scanPeriod-监测配置文件是否有修改的时间间隔， debug-是否打印logback日志--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;60000&quot;</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- The FILE and ASYNC appenders are here as examples for a production configuration --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/all/%d&#123;yyyy-MM-dd&#125;/mainfabcore.%d&#123;yyyy-MM-dd-HH&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>48<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d %-5level [%thread] %logger&#123;0&#125;: %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--只匹配ERROR级别日志--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/%d&#123;yyyy-MM-dd&#125;/mainfabcore.%d&#123;yyyy-MM-dd-HH&#125;.error.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>48<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d %-5level [%thread] %logger&#123;0&#125;: %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--只匹配ERROR级别日志--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/%d&#123;yyyy-MM-dd&#125;/mainfabcore.%d&#123;yyyy-MM-dd-HH&#125;.info.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>48<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d %-5level [%thread] %logger&#123;0&#125;: %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ASYNC&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">queueSize</span>&gt;</span>512<span class="hljs-tag">&lt;/<span class="hljs-name">queueSize</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;info&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;$&#123;logging.level.root&#125;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;info&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ASYNC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。</span><br><span class="hljs-comment">&lt;loger&gt;仅有一个name属性，一个可选的level和一个可选的addtivity属性。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.activation&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.mail&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.management.remote&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.xml.bind&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ch.qos.logback&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.ryantenney&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.sun&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.zaxxer&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.undertow&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.undertow.websockets.jsr&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.ehcache&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.startup.DigesterFactory&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.bson&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate.validator&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate.ejb.HibernatePersistence&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.web&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.security&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.cache&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.thymeleaf&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.xnio&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;springfox&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sun.rmi&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;liquibase&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LiquibaseSchemaResolver&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;springfox.documentation.schema.property&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sun.rmi.transport&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;i.lettuce&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.lettuce&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.alibaba.nacos.spring.util.parse.DefaultYamlConfigParse&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.alibaba.nacos.client.naming&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- jhipster-needle-logback-add-log - JHipster will add a new log with level, Do not remove --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- https://logback.qos.ch/manual/configuration.html#shutdownHook and https://jira.qos.ch/browse/LOGBACK-1090 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">shutdownHook</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.hook.DelayingShutdownHook&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">contextListener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.jul.LevelChangePropagator&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resetJUL</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">resetJUL</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">contextListener</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>log</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装oracle12.2</title>
    <link href="/2021/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/%E5%AE%89%E8%A3%85oracle12.2/"/>
    <url>/2021/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/%E5%AE%89%E8%A3%85oracle12.2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_41650000/article/details/117003428">https://blog.csdn.net/qq_41650000/article/details/117003428</a><br>拉取镜像</p><hr><ol><li>拉取 oracle 镜像<ol><li>docker pull marcocimatti/oracle12.2.0.1-se2</li></ol></li><li>检查拉取的镜像<ol><li>docker images -a</li><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FjxAe1B6XfAlTEizg4O3cUO8XQ71.png"></li></ol></li></ol><p>启动</p><hr><ol start="3"><li>启动容器<ol><li>docker run -p 1521:1521 –name oracle12.2se2 -e ORACLE_PWD=guns123456 -d marcocimatti/oracle12.2.0.1-se2</li><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqZfUFMMQAsDiB8qkaDYwkugLl7z.png"><br>（-d 后台挂载运行 -p 映射容器端口到宿主机 -e 设置容器环境变量）</li></ol></li><li>查看启动 log<ol><li>docker logs -f oracle12.2se2</li></ol></li><li>查看 container 状态为 up<ol><li>docker ps -a</li></ol></li><li>确认启动成功<ol><li>docker exec -it oracle12.2 /bin/bash 进入容器</li><li>sqlplus system/guns123456@ORCLPDB1 连接 sqlplus</li></ol></li></ol><p>创建用户，赋予默认表空间</p><hr><ol start="7"><li>创建用户<ol><li>create user mainfabcore identified by mainfabcore;</li></ol></li><li>授权用户权限<ol><li>grant connect,resource,dba to mainfabcore;</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fo_yQfYCsDQ6-TVve58J0u2RAUT2.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>oracle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装oracle11</title>
    <link href="/2021/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/%E5%AE%89%E8%A3%85oracle11/"/>
    <url>/2021/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/%E5%AE%89%E8%A3%85oracle11/</url>
    
    <content type="html"><![CDATA[<p>因为在 Linux 上安装 Oracle 非常麻烦，而且也会遇到各种问题。手工方式可以参考我的以前写的一篇博客：在 Linux 虚拟机上安装 Oracle 数据库（超完整版！）</p><p>我们用 Docker 安装 oracle 真的是非常方便。</p><p>一、准备工作 1.安装 docker-ce （有 docker 老版本也可以直接使用）</p><p>安装依赖的软件包<br>yum install -y yum-utils device-mapper-persistent-data lvm2</p><p>配置 Docker 的阿里云 yum 源<br>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><p>安装 docker-ce<br>yum install -y docker-ce</p><p>2.启动 Docker 服务</p><p>systemctl start docker</p><p>3.获取阿里云的 oracle 镜像</p><p>docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g 4.查看获取的镜像</p><p>docker images</p><p>二、使用 docker 安装 oracle 1.默认启动容器方式</p><p>docker run -d -it -p 1521:1521 –name oracle11g –restart=always registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</p><p>持久化启动方式如下：</p><p>docker run -d -it -p 1521:1521 –name oracle –restart=always –mount source=oracle_vol,target=/home/oracle/app/oracle/oradata registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</p><p>一般用默认启动方式就可以了，若是需要将数据保存到本地的采用持久化方式。</p><p>–mount 表示要将 Host 上的路径挂载到容器中。</p><p>source=oracle_vol 为 Host 的持久化卷，若未提前创建会自动创建，可通过 docker volume instpect 【容器名】查看 volume 的具体位置，target 为容器中的路径</p><p>2.查看容器，容器状态 up 表示在运行状态</p><p>docker ps</p><p>3.进入容器</p><p>docker exec -it 【容器 id 或名称】 bash</p><p>4.切换到 root 账户（默认进入之后是 oracle 账户）</p><p>su root</p><p>输入密码：helowin（密码都是一样的）</p><p>5.编辑环境变量</p><p>vi /etc/profile 添加以下内容：</p><p>export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2<br>export ORACLE_SID=helowin<br>export PATH=$ORACLE_HOME/bin:$PATH</p><p>source /etc/profile 使配置生效</p><p>6.创建软链接</p><p>ln -s $ORACLE_HOME/bin/sqlplus /usr/bin</p><p>7.切换到 oracle 用户，登录 sqlplus</p><p>su - oracle</p><p>sqlplus /nolog</p><p>conn /as sysdba<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fh8M5mWCExlLGMoqdt9sv9spArlR.png"></p><p>修改 sys、system 用户密码：</p><p>alter user system identified by 123456;<br>alter user sys identified by 123456;<br>alter profile default limit PASSWORD_LIFE_TIME UNLIMITED;</p><p>8.创建用户（可选，根据需要）</p><p>用一个具有 dba 权限的用户登录（sysdba)，然后输入以下语句</p><p>create user mainfabcore identified by mainfabcore;</p><p>grant connect,resource,dba to mainfabcore;</p><p>9.使用 Navicat 链接 Oracle</p><p>注意下面的服务名<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fkepv-UzH5blzt2Y3wh3IKy8QhCz.png"></p><p>测试连接，连接成功。</p><p>————————————————<br>版权声明：本文为 CSDN 博主「长林攻城狮」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/shao_yc/article/details/104423387">https://blog.csdn.net/shao_yc/article/details/104423387</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>oracle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大数据</title>
    <link href="/2021/09/17/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    <url>/2021/09/17/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hbase操作</title>
    <link href="/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/Hbase%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/Hbase%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="0-总体操作流程"><a href="#0-总体操作流程" class="headerlink" title="0 总体操作流程"></a>0 总体操作流程</h1><ol><li>client 请求到 Zookeeper，然后 Zookeeper 返回 HRegionServer 地址给 client</li><li>client 得到 Zookeeper 返回的地址去请求 HRegionServer，</li><li>HRegionServer 从 HDFS 读写数据后返回给 client。<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FoxoGTzSQ73G88ye66ouxoIe69CM.png"></li></ol><h1 id="1-查询"><a href="#1-查询" class="headerlink" title="1 查询"></a>1 查询</h1><h2 id="1-1-流程"><a href="#1-1-流程" class="headerlink" title="1.1 流程"></a>1.1 流程</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fp5a4UvHtzl9sGQkzjsEdt_TzrxK.png"></p><ol><li>hbase client 要读数据了，先从 zookeeper 中拿到 meta 表信息，根据要查的 rowkey 找到对应的数据在哪些 RegionServer 上</li><li>分别在这些 RegionServer 上根据列簇定位到 Region，</li><li>先在<strong>MemStore</strong>中查找，命中则返回，否则在<strong>Storefile</strong>中扫描，为了能快速的判断要查询的数据在不在这个 StoreFile 中，应用了<strong>BloomFilter</strong></li><li>根据数据的版本找到最新数据进行返回</li></ol><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkAuJDQruDuEqGuIv9v5aHonYG-K.png"></p><h2 id="1-2-查询方式"><a href="#1-2-查询方式" class="headerlink" title="1.2 查询方式"></a>1.2 查询方式</h2><ul><li>无法直接用 sql 查询，只能通过 rowKey 查询<ul><li>rowKey 底层也是 b+ Tree</li><li>把查询的条件字段放在 rowKey 中</li></ul></li></ul><p>注：有些中间件把 sql 翻译成 hbase 的查询规则，从而支持了 sql 间接查 hbase</p><ul><li>第一种是 scan：设置  <strong>startRow</strong>  和  <strong>stopRow</strong>  参数进行范围匹配<ul><li>[<strong>startRow, stopRow</strong>) 左闭右开</li></ul></li><li>第二种是根据一个 rowkey 进行查询</li><li>第三种是全表扫描，直接获取整张表中的所有行记录</li><li>如果 rowkey 复杂且查询条件复杂，hbase 还针对 rowkey 提供了自定义 Filter</li></ul><h2 id="1-3-设置-rowKey-需要注意的点"><a href="#1-3-设置-rowKey-需要注意的点" class="headerlink" title="1.3 设置 rowKey 需要注意的点"></a>1.3 设置 rowKey 需要注意的点</h2><blockquote><p>一条数据的唯一标识：rowKey<br>rowKey = 散列字段 + indicator 信息 + 时间戳</p></blockquote><ul><li>必须唯一</li><li>尽可能短<ul><li>每个 key-value 都包含 rowKey，这样可以节省存储空间</li></ul></li><li>数字需要补齐<ul><li>rowkey 是按照字符串字典序来组织成 B+树的，所以数字的话需要补齐，不然的话会出现 123w 小于 20w 的情况，但是补齐的话，你就会发现 020w 小于 123w</li></ul></li><li>rowKey 散列性<ul><li>数据是根据 rowkey 和一定的哈希规则，分散到不同的 Region 上面，而 Region 又是属于某一个 HRegionServer</li><li>rowKey 的前几个字符若一样，会分布在同一个 HRegionServer 上，导致 server 负载不均（堆积的热点现象）</li></ul></li></ul><hr><h1 id="2-写入"><a href="#2-写入" class="headerlink" title="2 写入"></a>2 写入</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FrP7KKf4q6DMXIgBzZOTK443rzzH.png"></p><h2 id="2-1-流程"><a href="#2-1-流程" class="headerlink" title="2.1 流程"></a>2.1 流程</h2><ol><li>hbase client 要写入了，先从 zookeeper 中拿到**.META.**表信息，根据数据的 rowkey 找到应该往哪个 RegionServer 写</li><li>然后记录操作日志<strong>WAL</strong>，再将数据写入对应<strong>MemStore</strong>中</li><li>判断 MemStore 是否超过阈值，（当 MemStore 大小超过阈值时，就会创建一个新的 MemStore，并且将老的 MemStore 添加到 flush 队列，由单独的线程 flush 到磁盘上，成为一个 StoreFile）</li><li>在触发了一定条件的时候，小的 StoreFile 会进行合并，变成大的 StoreFile，有利于 hdfs 存储</li></ol><hr><h2 id="2-2-LSM-三层模型（数据-gt-内存-gt-小文件-gt-大文件）"><a href="#2-2-LSM-三层模型（数据-gt-内存-gt-小文件-gt-大文件）" class="headerlink" title="2.2 LSM 三层模型（数据-&gt;内存-&gt;小文件-&gt;大文件）"></a>2.2 LSM 三层模型（数据-&gt;内存-&gt;小文件-&gt;大文件）</h2><p>LSM 被设计来提供比传统的 B+树或者 ISAM 更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。这个问题的本质还是<strong>磁盘随机操作慢，顺序读写快</strong>的老问题。这二种操作存在巨大的差距，无论是磁盘还是 SSD</p><ul><li>小文件-&gt;大文件：分两种： - minor compact，这种方式只会将少数文件进行简单合并，不会进行数据的清理。一般在生产环境禁止大合并，不然可能资源被耗光，无法正常提供服务。 - major compact，这种方式会将大部分文件进行合并，并且清理数据，十分消耗性能，一般在业务低峰期手动进行或定时任务执行</li></ul><h2 id="2-3-WAL-机制保证宕机时内存中数据恢复"><a href="#2-3-WAL-机制保证宕机时内存中数据恢复" class="headerlink" title="2.3 WAL 机制保证宕机时内存中数据恢复"></a>2.3 WAL 机制保证宕机时内存中数据恢复</h2><p>WAL，即 Write ahead log。<br>类似 mysql 中的 binlog，用来做灾难恢复之用，Hlog 记录数据的所有变更</p><ul><li>数据在更新时首先写入 HLog(WAL Log)，再写入内存(MemStore)中，MemStore 中的数据是排序的，当 MemStore 累计到一定阈值时，就会创建一个新的 MemStore，并且将老的 MemStore 添加到 flush 队列，由单独的线程 flush 到磁盘上，成为一个 StoreFile。于此同时，系统会在 ZooKeeper 中记录一个 redo point，表示这个时刻之前的变更已经持久化了。当系统出现意外时，可能导致内存(MemStore)中的数据丢失，此时使用 HLog(WAL Log)来恢复 checkpoint 之后的数据。</li><li>HLog 文件定期会滚动出新，并删除旧的文件(已持久化到 StoreFile 中的数据)。当 HRegionServer 意外终止 后，HMaster 会通过 ZooKeeper 感知，HMaster 首先处理遗留的 HLog 文件，将不同 Region 的 log 数据拆分，分别放到相应 Region 目录下，然后再将失效的 Region（带有刚刚拆分的 log） 重新分配，领取到这些 Region 的 HRegionServer 在 load Region 的过程中，会发现有历史 HLog 需要处理，因此会 Replay HLog 中的数据到 MemStore 中，然后 flush 到 StoreFiles，完成数据恢复。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FjmO7LjJAEEBfpsnnJE7HkJ6hnjx.png"></p><hr><h1 id="3-修改-删除"><a href="#3-修改-删除" class="headerlink" title="3 修改/删除"></a>3 修改/删除</h1><ul><li>修改时原数据不变，只是追加一条版本号最新的数据</li><li>删除时原数据不变，只是追加一条版本号最新的标识被删除的数据</li><li>查询时只查版本最新的数据</li></ul><p>注：LSM 第三层 hbase 在<em>major compact</em>时会把用不到的数据删除</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hbase逻辑结构</title>
    <link href="/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/Hbase%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/"/>
    <url>/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/Hbase%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/54184168">https://zhuanlan.zhihu.com/p/54184168</a><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fvo8jmib0CglazvnO4jD6MN8I1P4.png"></p><ul><li>row key ：表的主键，按照字典序排序。</li><li>列簇：在 HBase 中，列簇将表进行横向切割。</li><li>列：属于某一个列簇，在 HBase 中可以进行动态的添加。</li><li>Cell : 是指具体的 Value 。</li><li>Version ：在这张图里面没有显示出来，这个是指版本号，用时间戳（TimeStamp ）来表示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FnvguPJV6EiqOun1jf8XD26UEpYX.png"><br><strong>key ~ value</strong></p><ul><li>key:         rowKey + CF(ColumnFamily)  + Column + TimeStamp</li><li>value:     value</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hbase物理结构</title>
    <link href="/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/Hbase%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/"/>
    <url>/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/Hbase%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FlU6_ekCHKLdlYKBwyRZr5CTEPOO.png"><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fi9RbQT5VHrt4_TxrtOAT7_fjSaA.jpeg"></p><h2 id="1-Master"><a href="#1-Master" class="headerlink" title="1 Master"></a>1 Master</h2><ul><li>为 RegionServer 分配 Region</li><li>负责 RegionServer 的负载均衡</li><li>发现失效的 RegionServer 并重新分配其上的 Region</li></ul><p>注：client 访问 HBase 上数据的过程并不需要 Master 参与，在没有 Region 分裂的情况，Master 宕机一段时间是可以忍受的</p><hr><h2 id="2-RegionServer"><a href="#2-RegionServer" class="headerlink" title="2 RegionServer"></a>2 RegionServer</h2><ul><li>RegionServer 维护 Master 分配给它的 Region，处理对这些 Region 的 IO 请求</li><li>RegionServer 负责 Split 在运行过程中变得过大的 Region，负责 Compact 操作</li></ul><h3 id="2-1-Region"><a href="#2-1-Region" class="headerlink" title="2.1 Region"></a>2.1 Region</h3><blockquote><p>两个重要属性：startRowkey，endRowkey，表示 Region 维护的 rowKey 范围</p></blockquote><ul><li>Region 按大小分隔，每个表一开始只有一个 region。随着数据不断插入表，region 不断增大，当 region 的某个列簇达到阈值时就会分成两个新的 region。</li><li>每个 region 由以下信息标识：&lt; 表名,startRowkey,创建时间&gt;</li><li>由目录表(-ROOT-和.META.)记录该 region 的 endRowkey</li></ul><h4 id="2-1-1-Store"><a href="#2-1-1-Store" class="headerlink" title="2.1.1 Store"></a>2.1.1 Store</h4><ul><li>hbase 会把一起访问的数据放在一个 store 里面，即为每个 ColumnFamily 建一个 store。 HBase 以 store 的大小来判断是否需要切分 region</li></ul><h5 id="2-1-1-1-MemStore"><a href="#2-1-1-1-MemStore" class="headerlink" title="2.1.1.1 MemStore"></a>2.1.1.1 MemStore</h5><ul><li>memStore 是在内存里的。保存修改的数据即 keyValues。当 memStore 的大小达到阈值（默认 128MB）时，memStore 会被 flush 到 StoreFile。目前 hbase 会有一个线程来负责 memStore 的 flush 操作。</li></ul><h5 id="2-1-1-2-StoreFile"><a href="#2-1-1-2-StoreFile" class="headerlink" title="2.1.1.2 StoreFile"></a>2.1.1.2 StoreFile</h5><ul><li>StoreFile 底层是以 HFile 的格式保存。当 storefile 文件的数量增长到一定阈值后，系统会进行合并（minor、major compaction），在合并过程中会进行版本合并和删除工作（majar compaction 才会删除），形成更大的 storefile。</li><li>HFile 是 Hadoop 中的二进制格式文件，实际上 StoreFile 就是对 Hfile 做了轻量级包装，即 StoreFile 底层就是 HFile。</li></ul><h3 id="2-2-HLog"><a href="#2-2-HLog" class="headerlink" title="2.2 HLog"></a>2.2 HLog</h3><ul><li>HLog(WAL log)：WAL 意为 write ahead log，用来做灾难恢复使用，HLog 记录数据的所有变更，一旦 region server 宕机，就可以从 log 中进行恢复。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>liquibase</title>
    <link href="/2021/08/03/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/liquibase/liquibase/"/>
    <url>/2021/08/03/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/liquibase/liquibase/</url>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml">--删除唯一约束<br><span class="hljs-tag">&lt;<span class="hljs-name">dropNotNullConstraint</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;FDC_MES_DATA&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">columnName</span>=<span class="hljs-string">&quot;LAYER_ID&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">columnDataType</span>=<span class="hljs-string">&quot;bigint&quot;</span>/&gt;</span><br><br>--修改字段类型<br><span class="hljs-tag">&lt;<span class="hljs-name">modifyDataType</span>  <span class="hljs-attr">columnName</span>=<span class="hljs-string">&quot;NO_DATA_TIME&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">newDataType</span>=<span class="hljs-string">&quot;DATE&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;HIST_CHAMBER_GROUP&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">nullable</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br>--删除字段<br><span class="hljs-tag">&lt;<span class="hljs-name">dropColumn</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;HIST_CHAMBER_GROUP&quot;</span> <span class="hljs-attr">columnName</span>=<span class="hljs-string">&quot;CHAMBER_GROUP&quot;</span> /&gt;</span><br><br>--添加字段<br><span class="hljs-tag">&lt;<span class="hljs-name">addColumn</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;HIST_CHAMBER_GROUP&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CHAMBER_GROUP&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;CLOB&quot;</span> <span class="hljs-attr">remarks</span>=<span class="hljs-string">&quot;Chamber Group的json对象&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">addColumn</span>&gt;</span><br><br>--创建唯一索引<br><span class="hljs-tag">&lt;<span class="hljs-name">createIndex</span> <span class="hljs-attr">indexName</span>=<span class="hljs-string">&quot;SYS_C007461&quot;</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;FDC_CONF_CHAMBER&quot;</span> <span class="hljs-attr">unique</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;TOOL_ID&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CHAMBER_NAME&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">createIndex</span>&gt;</span><br><br>--创建外键约束<br><span class="hljs-tag">&lt;<span class="hljs-name">addForeignKeyConstraint</span> <span class="hljs-attr">constraintName</span>=<span class="hljs-string">&quot;FK_FDC_CONF_MES_CHAMBER_MES_TOOL_ID&quot;</span></span><br><span class="hljs-tag">                                 <span class="hljs-attr">baseTableName</span>=<span class="hljs-string">&quot;FDC_CONF_MES_CHAMBER&quot;</span> <span class="hljs-attr">baseColumnNames</span>=<span class="hljs-string">&quot;MES_TOOL_ID&quot;</span></span><br><span class="hljs-tag">                                 <span class="hljs-attr">referencedTableName</span>=<span class="hljs-string">&quot;FDC_CONF_MES_TOOL&quot;</span> <span class="hljs-attr">referencedColumnNames</span>=<span class="hljs-string">&quot;ID&quot;</span></span><br><span class="hljs-tag">                                 <span class="hljs-attr">deferrable</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">initiallyDeferred</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">onDelete</span>=<span class="hljs-string">&quot;RESTRICT&quot;</span> <span class="hljs-attr">onUpdate</span>=<span class="hljs-string">&quot;RESTRICT&quot;</span> <span class="hljs-attr">validate</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>--删除外键约束<br><span class="hljs-tag">&lt;<span class="hljs-name">dropForeignKeyConstraint</span> <span class="hljs-attr">baseTableName</span>=<span class="hljs-string">&quot;FDC_CONF_SENSOR&quot;</span></span><br><span class="hljs-tag">                          <span class="hljs-attr">baseColumnNames</span>=<span class="hljs-string">&quot;CHAMBER_ID&quot;</span></span><br><span class="hljs-tag">                          <span class="hljs-attr">constraintName</span>=<span class="hljs-string">&quot;FK_CONF_SENSOR_CHAMBER_ID&quot;</span>/&gt;</span><br><br>--校验<br><span class="hljs-tag">&lt;<span class="hljs-name">preConditions</span> <span class="hljs-attr">onFail</span>=<span class="hljs-string">&quot;MARK_RAN&quot;</span> <span class="hljs-attr">onError</span>=<span class="hljs-string">&quot;MARK_RAN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tableExists</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;FDC_CONF_CHAMBER_GROUP_VIRTUAL_SENSOR_MAPPING&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">preConditions</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>liquibase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DDD</title>
    <link href="/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DDD/"/>
    <url>/2021/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DDD/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一种设计思想，不解决技术问题，只解决复杂的业务问题</p></blockquote><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>适合：<ul><li>复杂系统：维护老项目时提供帮助</li><li>容易剥离开业务和技术</li></ul></li><li>不适合<ul><li>不容易剥离开业务和技术：如 底层技术平台：</li><li>简单系统：如 新项目</li></ul></li></ul><p>ddd 可以指导拆分微服务<br>按限界上下文拆分微服务；上下文地图则为微服务之间的接口<br>单一职责原则</p><p>聚合：<br>整体消失时，部分也消失<br>整体产生前，部分不能产生<br>部分的生命周期在整体的内部</p><h1 id="领域模型到程序设计"><a href="#领域模型到程序设计" class="headerlink" title="领域模型到程序设计"></a>领域模型到程序设计</h1>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解</title>
    <link href="/2021/06/29/java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/06/29/java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><ul><li><p>@Retention（标识注解存在阶段）</p><ul><li>@Retention(RetentionPolicy.SOURCE)，注解仅存在于源码中，在 class 字节码文件中不包含</li><li>@Retention(RetentionPolicy.CLASS)， 默认的保留策略，注解会在 class 字节码文件中存在，但运行时无法获得</li><li>@Retention(RetentionPolicy.RUNTIME)， 注解会在 class 字节码文件中存在，在运行时可以通过反射获取到</li></ul></li><li><p>@Target（注解作用的范围）</p><ul><li>@Target(ElementType.TYPE) 作用接口、类、枚举、注解</li><li>@Target(ElementType.FIELD) 作用属性字段、枚举的常量</li><li>@Target(ElementType.METHOD) 作用方法</li><li>@Target(ElementType.PARAMETER) 作用方法参数</li><li>@Target(ElementType.CONSTRUCTOR) 作用构造函数</li><li>@Target(ElementType.LOCAL_VARIABLE)作用局部变量</li><li>@Target(ElementType.ANNOTATION_TYPE)作用于注解（@Retention 注解中就使用该属性）</li><li>@Target(ElementType.PACKAGE) 作用于包</li><li>@Target(ElementType.TYPE_PARAMETER) 作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8 加入）</li><li>@Target(ElementType.TYPE_USE) 类型使用.可以用于标注任意类型除了 class （jdk1.8 加入）</li></ul></li><li><p>@Inherited（继承，一个被@Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。）</p></li><li><p>@Documented（它的作用是能够将注解中的元素包含到 Javadoc 中去。）</p></li><li><p>@Repeatable（可重复的。被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义）</p></li></ul><h1 id="java-自带标准注解"><a href="#java-自带标准注解" class="headerlink" title="java 自带标准注解"></a>java 自带标准注解</h1><p>包括@Override、@Deprecated、@SuppressWarnings 等，使用这些注解后编译器就会进行检查。</p><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p><strong>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个 Annotation。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>javax</title>
    <link href="/2021/06/28/java%E5%9F%BA%E7%A1%80/javax/"/>
    <url>/2021/06/28/java%E5%9F%BA%E7%A1%80/javax/</url>
    
    <content type="html"><![CDATA[<h1 id="javax-validation"><a href="#javax-validation" class="headerlink" title="javax.validation"></a>javax.validation</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Null</span>  被注释的元素必须为<span class="hljs-literal">null</span><br><span class="hljs-meta">@NotNull</span>  被注释的元素不能为<span class="hljs-literal">null</span><br><span class="hljs-meta">@AssertTrue</span>  被注释的元素必须为<span class="hljs-literal">true</span><br><span class="hljs-meta">@AssertFalse</span>  被注释的元素必须为<span class="hljs-literal">false</span><br><span class="hljs-meta">@Min(value)</span>  被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br><span class="hljs-meta">@Max(value)</span>  被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br><span class="hljs-meta">@DecimalMin(value)</span>  被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br><span class="hljs-meta">@DecimalMax(value)</span>  被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br><span class="hljs-meta">@Size(max,min)</span>  被注释的元素的大小必须在指定的范围内。<br><span class="hljs-meta">@Digits(integer,fraction)</span>  被注释的元素必须是一个数字，其值必须在可接受的范围内<br><span class="hljs-meta">@Past</span>  被注释的元素必须是一个过去的日期<br><span class="hljs-meta">@Future</span>  被注释的元素必须是一个将来的日期<br><span class="hljs-meta">@Pattern(value)</span> 被注释的元素必须符合指定的正则表达式。<br><span class="hljs-meta">@Email</span> 被注释的元素必须是电子邮件地址<br><span class="hljs-meta">@Length</span> 被注释的字符串的大小必须在指定的范围内<br><span class="hljs-meta">@NotEmpty</span>  被注释的字符串必须非空<br><span class="hljs-meta">@Range</span>  被注释的元素必须在合适的范围内<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BASE理论</title>
    <link href="/2021/06/21/%E5%88%86%E5%B8%83%E5%BC%8F/BASE%E7%90%86%E8%AE%BA/"/>
    <url>/2021/06/21/%E5%88%86%E5%B8%83%E5%BC%8F/BASE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></blockquote><ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FlXkqNXDgYzbzpSMLxQ_rBQgpqBD.png"></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大努力通知方案</title>
    <link href="/2021/06/19/%E9%A1%B9%E7%9B%AE/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88/"/>
    <url>/2021/06/19/%E9%A1%B9%E7%9B%AE/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fh2ACUoyQi6NAvQJEeculGKYefst.png"></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Guava Cache</title>
    <link href="/2021/06/03/java%E5%9F%BA%E7%A1%80/Guava%20Cache/"/>
    <url>/2021/06/03/java%E5%9F%BA%E7%A1%80/Guava%20Cache/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzw.fdc.web.rest;<br><br><span class="hljs-keyword">import</span> com.google.common.base.Preconditions;<br><span class="hljs-keyword">import</span> com.google.common.cache.*;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestGuavaCache</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>        CacheLoader&lt;String, String&gt; loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheLoader</span>&lt;String, String&gt; () &#123;<br>            <span class="hljs-comment">// get 时先从缓存中找，找不到则通过load加载</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">load</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;key&quot;</span>.equals(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                System.out.println(key + <span class="hljs-string">&quot; is loaded from a cacheLoader!&quot;</span>);<br>                <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;&#x27;s value&quot;</span>;<br>            &#125;<br>        &#125;;<br><br>        RemovalListener&lt;String, String&gt; removalListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemovalListener</span>&lt;String, String&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRemoval</span><span class="hljs-params">(RemovalNotification&lt;String, String&gt; removal)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;[&quot;</span> + removal.getKey() + <span class="hljs-string">&quot;:&quot;</span> + removal.getValue() + <span class="hljs-string">&quot;] is evicted!&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// CacheBuilder缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。</span><br>        LoadingCache&lt;String, String&gt; testCache = CacheBuilder.newBuilder()<br>            .maximumSize(<span class="hljs-number">7</span>)<br>            .expireAfterWrite(<span class="hljs-number">10</span>, TimeUnit.MINUTES)<br>            .removalListener(removalListener)<br>            .softValues() <span class="hljs-comment">// 使用软引用存储值</span><br>            .recordStats() <span class="hljs-comment">// 开启后会对缓存的操作进行统计</span><br>            .build(loader);<br><br>        <span class="hljs-comment">// get</span><br>        <span class="hljs-comment">// 从本地缓存中找值，如果找不到返回null，找到就返回相应的值。</span><br>        testCache.getIfPresent(<span class="hljs-string">&quot;myKey&quot;</span>);<br>        <span class="hljs-comment">// get 时先从缓存中找，找不到则通过load加载</span><br>        testCache.get(<span class="hljs-string">&quot;myKey&quot;</span>);<br>        System.out.println(testCache.get(<span class="hljs-string">&quot;myKey&quot;</span>));<br>        <span class="hljs-comment">// get时先从缓存中找，找不到则通过call加载</span><br>        testCache.get(<span class="hljs-string">&quot;hehe&quot;</span>, ()-&gt;<span class="hljs-string">&quot;valueHehe&quot;</span>);<br>        System.out.println(testCache.get(<span class="hljs-string">&quot;hehe&quot;</span>));<br><br>        System.out.println(testCache.get(<span class="hljs-string">&quot;xixi&quot;</span>, ()-&gt;<span class="hljs-string">&quot;valueXixi&quot;</span>));<br><br>        testCache.put(<span class="hljs-string">&quot;haha0&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>        testCache.put(<span class="hljs-string">&quot;haha1&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>        System.out.println(testCache.getIfPresent(<span class="hljs-string">&quot;haha0&quot;</span>));<br>        System.out.println(testCache.getIfPresent(<span class="hljs-string">&quot;haha1&quot;</span>));<br>        <span class="hljs-comment">// delete</span><br><span class="hljs-comment">//        testCache.invalidate(&quot;myKey&quot;);</span><br><br>        <span class="hljs-comment">// status</span><br><span class="hljs-comment">//        System.out.println(testCache.stats());</span><br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>唯一索引与唯一约束</title>
    <link href="/2021/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F/"/>
    <url>/2021/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<ul><li>两者本质不同<ul><li><strong>index</strong><ul><li>Optional structure associated with tables and clusters. You can create indexes on one or more columns of a table to speed SQL statement execution on that table.</li></ul></li><li><strong>integrity constraint</strong><ul><li>Declarative method of defining a rule for a column of a table. Integrity constraints enforce the business rules associated with a database and prevent the entry of invalid information into tables.</li></ul></li></ul></li><li>两者的关联<ul><li>建立唯一约束时会自动建立唯一索引（若无唯一索引，要保证唯一约束只能全表扫描，这样不好）</li><li>建立唯一索引不会有唯一约束</li></ul></li><li>两者的不同<ul><li>外键的建立必须有唯一约束，这是唯一索引做不到的</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenTSDB</title>
    <link href="/2021/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93/TSDB/OpenTSDB/"/>
    <url>/2021/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93/TSDB/OpenTSDB/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/wangchaowei/p/7827366.html">https://www.cnblogs.com/wangchaowei/p/7827366.html</a></p><ul><li>基于 HBase</li></ul><h1 id="存储概念"><a href="#存储概念" class="headerlink" title="存储概念"></a>存储概念</h1><p>譬如假设我们采集 1 个服务器（hostname=qatest）的 CPU 使用率，发现该服务器在 21:00 的时候，CPU 使用率达到 99%</p><ul><li>Metric：即平时我们所说的监控项。譬如上面的 CPU 使用率</li><li>Tags：一些标签，<ul><li>在 OpenTSDB 里面，Tags 由 tagk 和 tagv 组成，即 tagk=takv。</li><li>标签是用来描述 Metric 的，譬如上面为了标记是服务器 A 的 CpuUsage，tags 可为 hostname=qatest</li></ul></li><li>Value：一个 Value 表示一个 metric 的实际数值，譬如上面的 99%</li><li>Timestamp：即时间戳，用来描述 Value 是什么时候的；譬如上面的 21:00</li><li>Data Point：即某个 Metric 在某个时间点的数值。<ul><li>Data Point 包括以下部分：Metric、Tags、Value、Timestamp</li><li>上面描述的服务器在 21:00 时候的 cpu 使用率，就是 1 个 DataPoint 保存到 OpenTSDB 的，就是无数个 DataPoint。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>TSDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关系型数据库</title>
    <link href="/2021/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><strong>关系型数据库：指采用了关系模型来组织数据的数据库。<br>关系模型：二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</strong><br>关系模型中常用的概念：<br>关系：一张二维表，每个关系都具有一个关系名，也就是表名<br>元组：二维表中的一行，在数据库中被称为记录<br>属性：二维表中的一列，在数据库中被称为字段<br>域：属性的取值范围，也就是数据库中某一列的取值限制<br>关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成<br>关系模式：指对关系的描述。其格式为：关系名(属性 1，属性 2， … … ，属性 N)，在数据库中成为表结构</p><p>链接：<a href="https://www.jianshu.com/p/fd7b422d5f93">https://www.jianshu.com/p/fd7b422d5f93</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TSDB</title>
    <link href="/2021/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93/TSDB/TSDB/"/>
    <url>/2021/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93/TSDB/TSDB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>时序列数据库用来存储时序列（time-series）数据并以时间（点或区间）建立索引的软件</p></blockquote><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h1><ul><li>数据结构简单</li><li>数据量大</li></ul><hr><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="OpenTSDB"><a href="#OpenTSDB" class="headerlink" title="OpenTSDB"></a>OpenTSDB</h2><p>-</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><ul><li>Golong</li></ul><h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><ul><li>开源版本只有单机版是免费的，单机版性能差</li><li>Golong</li><li>默认存储原始数据，时间自由度高，Rollup 低效</li></ul><h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><ul><li>不存储原始数据，时间自由度低，性能高</li><li>双层存储</li><li>查询自由度高</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>TSDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Client与Server交互方式</title>
    <link href="/2021/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/Client%E4%B8%8EServer%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/Client%E4%B8%8EServer%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Polling（短轮询）"><a href="#1-Polling（短轮询）" class="headerlink" title="1 Polling（短轮询）"></a>1 Polling（短轮询）</h1><blockquote><p>客户端拉方式</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fr9kc8LJ2kEl8Ls1ZNRBhuwSFqOP.png"></p><ul><li><strong>交互方式</strong><ul><li>client 每隔一段时间都会向 server 发送 http 请求，服务器收到请求后，将最新的数据发回给 client。</li></ul></li><li>缺点<ul><li><strong>浪费网络带宽</strong>：比如在某个时间段 server 没有更新数据，但 client 仍然每隔一段时间发送请求来询问，所以这段时间内的询问都是无效的，这样浪费了网络带宽。</li><li><strong>实时性不好</strong></li></ul></li></ul><h1 id="2-Comet"><a href="#2-Comet" class="headerlink" title="2 Comet"></a>2 Comet</h1><blockquote><p>基于 HTTP 长连接的 “服务器推”  方式</p></blockquote><p>具体可以细分为两种实现方式，一种是长轮询机制，一种是流技术。</p><h2 id="2-1-长轮询（Long-polling）"><a href="#2-1-长轮询（Long-polling）" class="headerlink" title="2.1 长轮询（Long-polling）"></a>2.1 长轮询（Long-polling）</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fhk_UDAmzIhTa5hSMVZdjW9UnnRm.png"></p><ul><li><strong>交互方式</strong><ul><li>client 向 server 发出请求，server 接收到请求后，server 并不一定立即发送回应给 client，而是看数据是否更新，如果数据已经更新了的话，那就立即将数据返回给 client；但如果数据没有更新，那就把这个请求保持住（阻塞），等待有新的数据到来时，才将数据返回给 client</li></ul></li><li><strong>缺点</strong><ul><li>本质上还是一种轮询方式，实时性较差</li></ul></li></ul><h2 id="2-2-流技术（Http-Streaming）"><a href="#2-2-流技术（Http-Streaming）" class="headerlink" title="2.2 流技术（Http Streaming）"></a>2.2 流技术（Http Streaming）</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Flu3bGTukP039HYhDFm6nNB4ZJ94.png"></p><ul><li>交互方式<ul><li>一直保持连接，不需要 client 请求，当数据发生改变时，server 自动的将数据发送给 client。</li><li>（疑问：HTTP 一个 request 只会对应一个 response，为什么可以有多个 response？）</li></ul></li><li>缺点<ul><li>网页会一直显示未加载完成的状态</li></ul></li></ul><h1 id="3-WebSocket"><a href="#3-WebSocket" class="headerlink" title="3 WebSocket"></a>3 WebSocket</h1><blockquote><p>是一种基于 TCP 的<strong>应用层协议</strong></p></blockquote><p><strong><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fsulbs8daUM-utN5sr-eOZj7bc8G.png"></strong></p><ul><li><strong>交互流程</strong><ul><li><strong>借助 HTTP 建立连接</strong></li><li><strong>双向通信（与 HTTP 无关）</strong></li><li>client 或者 server 中有一端主动断开连接</li></ul></li><li><strong>缺点</strong><ul><li><strong>兼容性</strong>：非现代浏览器 IE7 IE8 IE9 不支持 websocket</li><li><strong>浪费流量和电：</strong>Websocket 的 ping/pong 包比较频繁，所以可能在长时间没信息的情况下<strong>浪费流量和电</strong></li></ul></li></ul><h2 id="3-1-WebSocket-与-socket"><a href="#3-1-WebSocket-与-socket" class="headerlink" title="3.1 WebSocket 与 socket"></a>3.1 WebSocket 与 socket</h2><ul><li>WebSocekt 是 HTML5 规范中的一部分，其借鉴了 socket 的思想，为 client 和 server 之间提供了类似的双向通信机制</li><li>socket 并不是一个协议，而是一组接口，其主要方便大家直接使用更底层的协议（比如 TCP 或 UDP）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsyZy3EcaRR-yKsrWcpEHMmzTJpI.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2021/03/25/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/docker/Docker/"/>
    <url>/2021/03/25/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/docker/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-是如何运行的"><a href="#Docker-是如何运行的" class="headerlink" title="Docker 是如何运行的"></a>Docker 是如何运行的</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fp459VacyCm_dMeV0miK_rhMx1b3.png"></p><hr><h1 id="Docker-优势"><a href="#Docker-优势" class="headerlink" title="Docker 优势"></a>Docker 优势</h1><h2 id="快"><a href="#快" class="headerlink" title="快"></a>快</h2><ul><li>Docker 的抽象层比 VM 少</li><li>Docker 利用 HostOS（宿主机内核），VM 需要 GuestOS</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhEWCbyoIK5TRYtDglCPUQQ6Qsc4.png"></p><hr><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ul><li><p>启动 systemctl start docker</p></li><li><p>关闭 systemctl stop docker</p></li><li><p>重启 systemctl restart docker</p></li><li><p>抓取 image</p><ul><li>docker image pull [组]/[image 文件名]</li></ul></li><li><p>查看 image</p><ul><li>docker image ls</li><li>docker images</li></ul></li><li><p>运行</p><ul><li>根据 image 文件，每次都生成一个正在运行的容器实例，若本地没有该 image，则从仓库自动抓取<ul><li>docker container run [image 文件名]</li></ul></li><li>启动已经生成并停止运行的 container<ul><li>docker container start [containID]</li></ul></li></ul></li><li><p>终止</p><ul><li>强行立即终止（SIGKILL）<ul><li>docker container kill [containID]</li></ul></li><li>应用程序可以进行一些收尾工作（SIGTERM）<ul><li>docker container stop [containID]</li></ul></li></ul></li><li><p>查看 container</p><ul><li>正在运行<ul><li>docker container ls</li></ul></li><li>所有：正在运行的+停止运行的<ul><li>docker container ls -all</li></ul></li></ul></li><li><p>删除 container</p><ul><li>docker container rm [containID]</li></ul></li><li><p>创建 image 文件</p><ul><li>docker image build -t [imageName] . (. 表示 Dockerfile 文件路径)</li></ul></li><li><p>查看 log 输出</p><ul><li>docker container logs [containerID]</li></ul></li><li><p>进入容器</p><ul><li>docker container exec -it [containerID] /bin/bash</li></ul></li><li><p>拷贝文件至本机</p><ul><li>docker container cp [containID]:[/path/to/file] .</li></ul></li></ul><hr><h1 id="docker-引擎："><a href="#docker-引擎：" class="headerlink" title="docker 引擎："></a>docker 引擎：</h1><p><a href="https://zhuanlan.zhihu.com/p/490585683">https://zhuanlan.zhihu.com/p/490585683</a><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FoUFNdai2hme7DQ3gNrLGV6BgTAj.webp"></p>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IaaS,PaaS,SaaS</title>
    <link href="/2021/03/24/%E5%88%86%E5%B8%83%E5%BC%8F/IaaS,PaaS,SaaS/"/>
    <url>/2021/03/24/%E5%88%86%E5%B8%83%E5%BC%8F/IaaS,PaaS,SaaS/</url>
    
    <content type="html"><![CDATA[<ul><li>Iaas 就是卖硬件，Paas 就是卖开发、运行环境，Saas 就是卖软件。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvqzWBN95dqM5akBAhuSLV9Cuwfc.png"></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编码转换方式与应用</title>
    <link href="/2021/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2021/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Base64 是一种用 64 个字符来表示任意二进制数据的方法。</p><ul><li>小写字母 a-z、</li><li>大写字母 A-Z、</li><li>数字 0-9、</li><li>符号”+”、”/“（再加上作为垫字的”=”，实际上是 65 个字符）所以不能直接用于 url</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmowlNSZhtcdfznahNX6u7V522D5.png"></p><h2 id="编码步骤："><a href="#编码步骤：" class="headerlink" title="编码步骤："></a>编码步骤：</h2><ol><li>将每三个字节作为一组，一共是 24 个二进制位。</li><li>将这 24 个二进制位分为四组，每个组有 6 个二进制位。</li><li>在每组前面加两个 00，扩展成 32 个二进制位，即四个字节。</li><li>根据下表，得到扩展后的每个字节的对应符号，这就是 Base64 的编码值。</li></ol><p><strong>即，以 4x 个字节（每个字节只有其中 6 位有含义）表示 3x 个字节数据</strong><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FseKOXJPNGTdNc_gmlDRE27dsmZq.png"></p><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>jwt 令牌</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSH</title>
    <link href="/2021/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/SSH/"/>
    <url>/2021/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>建互信，登陆服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">hostname是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。</span><br><span class="hljs-meta"># </span><span class="language-bash">username是用户名，不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名</span><br><span class="hljs-meta"># </span><span class="language-bash">-p参数可以指定其他端口，默认22</span><br><span class="hljs-meta">$ </span><span class="language-bash">ssh -p 22 username@hostname</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM基础</title>
    <link href="/2021/02/23/java%E5%9F%BA%E7%A1%80/JVM/JVM%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/23/java%E5%9F%BA%E7%A1%80/JVM/JVM%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-编译执行-解释执行"><a href="#JVM-编译执行-解释执行" class="headerlink" title="JVM 编译执行/解释执行"></a>JVM 编译执行/解释执行</h1><ul><li>解释执行：<ul><li>字节码 -&gt; [ 解释器 解释执行 ] -&gt; 执行结果</li></ul></li><li>编译执行：<ul><li>字节码 -&gt; [ 编译器 编译 ] -&gt; 机器码 -&gt; [ 执行 ] -&gt; 执行结果</li></ul></li></ul><p>javac 生成的字节码与 32 位，64 位 JVM 无关。它可以在两个 JVM 上运行。记住古老的诺言“编译一次，随处运行”</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>遍历删除List中的元素</title>
    <link href="/2021/02/19/java%E5%9F%BA%E7%A1%80/%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4List%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2021/02/19/java%E5%9F%BA%E7%A1%80/%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4List%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>ArrayList 中的 Iterator 实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Index of element to be returned by subsequent call to next.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Index of element returned by most recent call to next or</span><br><span class="hljs-comment">    * previous.  Reset to -1 if this element is deleted by a call</span><br><span class="hljs-comment">    * to remove.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * The modCount value that the iterator believes that the backing</span><br><span class="hljs-comment">    * List should have.  If this expectation is violated, the iterator</span><br><span class="hljs-comment">    * has detected concurrent modification.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">return</span> cursor != size();<br>   &#125;<br>   <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>           checkForComodification();<br>       <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-type">E</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> get(cursor);<br>       lastRet = cursor++;<br>       <span class="hljs-keyword">return</span> next;<br>       &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e) &#123;<br>       checkForComodification();<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (lastRet == -<span class="hljs-number">1</span>)<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>           checkForComodification();<br>       <span class="hljs-keyword">try</span> &#123;<br>       AbstractList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>       <span class="hljs-keyword">if</span> (lastRet &lt; cursor)<br>           cursor--;<br>       lastRet = -<span class="hljs-number">1</span>;<br>       expectedModCount = modCount;<br>       &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e) &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>基本上 ArrayList 采用 size 属性来维护自已的状态，而 Iterator 采用 cursor 来来维护自已的状态。<br>当 size 出现变化时，cursor 并不一定能够得到同步，_除非这种变化是 Iterator 主动导致的_。</strong><br><strong>从上面的代码可以看到当 Iterator.remove 方法导致 ArrayList 列表发生变化时，他会更新 cursor 来同步这一变化。但其他方式导致的 ArrayList 变化，Iterator 是无法感知的。ArrayList 自然也不会主动通知 Iterator 们，那将是一个繁重的工作。Iterator 到底还是做了努力：为了防止状态不一致可能引发的无法设想的后果，Iterator 会经常做 checkForComodification 检查，以防有变。如果有变，则以异常抛出，所以就出现了上面的异常。</strong><br>如果对正在被迭代的集合进行结构上的改变（即对该集合使用 add、remove 或 clear 方法），那么迭代器就不再合法（并且在其后使用该迭代器将会有 ConcurrentModificationException 异常被抛出）.<br>如果使用迭代器自己的 remove 方法，那么这个迭代器就仍然是合法的。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    <url>/2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1 B+树"></a>1 B+树</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsbDcldJKWL19S6S3Z5gQI2UnEg3.png"><br>B+Tree 由三部分组成：根 root、枝 branch 以及 Leaf 叶子，其中 root 和 branch 不存储数据，只存储指针地址，数据全部存储在 Leaf Node，同时 Leaf Node 之间用双向链表链接</p><p>从 root 到每个 Leaf 的距离是相等的，也就是访问任何一个 Leaf Node 需要的 IO 是一样的，即索引树的高度 Level + 1 次 IO 操作</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态代理</title>
    <link href="/2021/02/17/java%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2021/02/17/java%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-jdk-动态代理"><a href="#1-jdk-动态代理" class="headerlink" title="1 jdk 动态代理"></a>1 jdk 动态代理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">作者：bravo1988<br>链接：https:<span class="hljs-comment">//www.zhihu.com/question/20794107/answer/658139129</span><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-type">CalculatorImpl</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalculatorImpl</span>();<br><span class="hljs-type">Calculator</span> <span class="hljs-variable">calculatorProxy</span> <span class="hljs-operator">=</span> (Calculator) getProxy(target);<br>calculatorProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>calculatorProxy.subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object target)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(<br>target.getClass().getClassLoader(),<span class="hljs-comment">/*类加载器*/</span><br>target.getClass().getInterfaces(),<span class="hljs-comment">/*让代理对象和目标对象实现相同接口*/</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>()&#123;<span class="hljs-comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法开始执行...&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>System.out.println(result);<br>System.out.println(method.getName() + <span class="hljs-string">&quot;方法执行结束...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br>);<br><span class="hljs-keyword">return</span> proxy;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>开发常用笔记</title>
    <link href="/2021/02/16/java%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/16/java%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="DTO-常用注解"><a href="#DTO-常用注解" class="headerlink" title="DTO 常用注解"></a>DTO 常用注解</h1><h2 id="javax-validation"><a href="#javax-validation" class="headerlink" title="javax.validation"></a>javax.validation</h2><p>配合使用：controller 参数前加上@Valid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.format.annotation.DateTimeFormat;<br><span class="hljs-keyword">import</span> org.springframework.format.annotation.DateTimeFormat;<br><span class="hljs-keyword">import</span> javax.validation.constraints.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidatorPojo</span> &#123;<br><span class="hljs-meta">@NotNull(message = &quot;id不能为空&quot;)</span> <span class="hljs-comment">// 非空判断</span><br><span class="hljs-keyword">private</span> Long id;<br><br><span class="hljs-meta">@Future(message = &quot;需要一个将来日期&quot;)</span> <span class="hljs-comment">// 只能是将来的日期</span><br><span class="hljs-comment">// @Past //只能去过去的日期</span><br><span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> <span class="hljs-comment">// 日期格式化转换</span><br><span class="hljs-meta">@NotNull</span> <span class="hljs-comment">// 不能为空</span><br><span class="hljs-keyword">private</span> Date date;<br><br><span class="hljs-meta">@NotNull</span> <span class="hljs-comment">// 不能为空</span><br><span class="hljs-meta">@DecimalMin(value = &quot;0.1&quot;)</span> <span class="hljs-comment">// 最小值0.1元</span><br><span class="hljs-meta">@DecimalMax(value = &quot;10000.00&quot;)</span> <span class="hljs-comment">// 最大值10000元</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Double</span> <span class="hljs-variable">doubleValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-meta">@Min(value = 1, message = &quot;最小值为1&quot;)</span> <span class="hljs-comment">// 最小值为1</span><br><span class="hljs-meta">@Max(value = 88, message = &quot;最大值为88&quot;)</span> <span class="hljs-comment">// 最大值88</span><br><span class="hljs-meta">@NotNull</span> <span class="hljs-comment">// 不能为空</span><br><span class="hljs-keyword">private</span> Integer integer;<br><br><span class="hljs-meta">@Range(min = 1, max = 888, message = &quot;范围为1至888&quot;)</span> <span class="hljs-comment">// 限定范围</span><br><span class="hljs-keyword">private</span> Long range;<br><br><span class="hljs-comment">// 邮箱验证</span><br><span class="hljs-meta">@Email(message = &quot;邮箱格式错误&quot;)</span><br><span class="hljs-keyword">private</span> String email;<br><br><span class="hljs-meta">@Size(min = 20, max = 30, message = &quot;字符串长度要求20到30之间。&quot;)</span><br><span class="hljs-keyword">private</span> String size;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="NotNull："><a href="#NotNull：" class="headerlink" title="@NotNull："></a>@NotNull：</h4><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fm8cxsvHsw7J15bBhdZd6kW6d1P1.png"></p><h4 id="NotEmpty："><a href="#NotEmpty：" class="headerlink" title="@NotEmpty："></a>@NotEmpty：</h4><p>@NotNull + @Size(min = 1)</p><h4 id="NotBlank"><a href="#NotBlank" class="headerlink" title="@NotBlank:"></a>@NotBlank:</h4><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FoNr8QXaHkuPqquecfDFIkfJP7GZ.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CAP定理与BASE理论</title>
    <link href="/2021/02/11/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E5%AE%9A%E7%90%86%E4%B8%8EBASE%E7%90%86%E8%AE%BA/"/>
    <url>/2021/02/11/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E5%AE%9A%E7%90%86%E4%B8%8EBASE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-CAP"><a href="#1-CAP" class="headerlink" title="1 CAP"></a>1 CAP</h1><p>CA 只能二选一</p><ul><li>C（consistency）<ul><li>（强）一致性：写操作完成后，所有的读操作都能看到最新的数据</li></ul></li><li>A（Availability）<ul><li>可用性：每次向未崩溃的节点发送请求，总能保证收到响应数据</li></ul></li><li>P（PartitionTolerance）<ul><li>分区容错性：容许节点间传递消息的差错（延迟或丢失）</li></ul></li></ul><h1 id="2-BASE"><a href="#2-BASE" class="headerlink" title="2 BASE"></a>2 BASE</h1><blockquote><p>即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></blockquote><ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FlXkqNXDgYzbzpSMLxQ_rBQgpqBD.png"></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oauth2</title>
    <link href="/2021/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/Oauth2/"/>
    <url>/2021/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/Oauth2/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p><blockquote><p><strong>OAuth 的核心就是向第三方应用颁发令牌</strong></p></blockquote><h1 id="1-颁发令牌的方式"><a href="#1-颁发令牌的方式" class="headerlink" title="1 颁发令牌的方式"></a>1 颁发令牌的方式</h1><ul><li>不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（<strong>client ID</strong>）和客户端密钥（<strong>client secret</strong>）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</li></ul><h2 id="1-1-授权码模式（authorization-code）"><a href="#1-1-授权码模式（authorization-code）" class="headerlink" title="1.1 授权码模式（authorization-code）"></a>1.1 授权码模式（authorization-code）</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiqldvBtH6FSTyFk4sUo7F05kE-A.png"></p><ul><li>A. Client 提供一个 url，用户点击后跳转至认证服务器<ul><li><a href="https://b.com/oauth/authorize">https://b.com/oauth/authorize</a>?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read</li></ul></li><li>B. 用户在认证服务器登陆并同意授权</li><li>C. 认证服务器返回 AuthorizationCode 给 Client3<ul><li>通过跳转 CALLBACK_URL 并携带 code 方式：<a href="https://CALLBACK_URL[?code=AUTHORIZATION_CODE](https://a.com/callback?code=AUTHORIZATION_CODE)">https://CALLBACK_URL[?code=AUTHORIZATION_CODE](https://a.com/callback?code=AUTHORIZATION_CODE)</a></li><li>此 code 用户可见</li></ul></li><li>D. Client 用 code 交换 AccessToken<ul><li><a href="https://b.com/oauth/token">https://b.com/oauth/token</a>?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL</li></ul></li><li>E. 认证服务器向 redirect_uri 指定的网址，发送一段 JSON 数据。<ul><li>JSON 中包含 token 信息</li></ul></li></ul><h2 id="1-2-隐藏模式（implicit）"><a href="#1-2-隐藏模式（implicit）" class="headerlink" title="1.2 隐藏模式（implicit）"></a>1.2 隐藏模式（implicit）</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fn1XnmdUqv8EyxXbOFOdGgioGbHj.png"></p><ul><li>相比 1.1 授权码方式，减少了 code 这一中间步骤，直接返回 token<ul><li><a href="https://a.com/callback#token=ACCESS_TOKEN">https://a.com/callback#token=ACCESS_TOKEN</a></li></ul></li><li>较 1.1 授权码模式，implicit 模式不安全</li></ul><h2 id="1-3-密码模式（password）"><a href="#1-3-密码模式（password）" class="headerlink" title="1.3 密码模式（password）"></a>1.3 密码模式（password）</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FpS9U_wJNgwj-xqyJObHt3lhAO5K.png"></p><ul><li>该模式用于用户完全对 Client 信任的场景</li></ul><h2 id="1-4-客户端凭证模式（client-credentials）"><a href="#1-4-客户端凭证模式（client-credentials）" class="headerlink" title="1.4 客户端凭证模式（client credentials）"></a>1.4 客户端凭证模式（client credentials）</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fi41Rnts79DuYxiBWfcm1Qb9vTtR.png"></p><ul><li>A. Client 以应用的名义向认证服务器发起请求<ul><li><a href="https://oauth.b.com/token">https://oauth.b.com/token?</a>grant_type=client_credentials&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET</li></ul></li><li>B. 直接返回 token</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UAA-认证服务</title>
    <link href="/2021/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/UAA-%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/"/>
    <url>/2021/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/UAA-%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>UAA（User Account and Authentication）<br><a href="https://www.cnblogs.com/yorkwu/p/9572151.html">https://www.cnblogs.com/yorkwu/p/9572151.html</a></p></blockquote><ul><li>认证方式<ul><li>oauth2<ul><li>密码模式</li><li>客户端模式</li></ul></li><li>JWT<ul><li>非对称加密方式实现数字签名</li></ul></li></ul></li><li>密码加密方式<ul><li>Bcrypt 加盐摘要</li></ul></li></ul><h1 id="0-认证流程"><a href="#0-认证流程" class="headerlink" title="0 认证流程"></a>0 认证流程</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvTXy1tZezoR5BZnP5-SLk07Xmn1.png"></p><h1 id="1-认证方式"><a href="#1-认证方式" class="headerlink" title="1 认证方式"></a>1 认证方式</h1><h2 id="1-1-oauth2-–-password"><a href="#1-1-oauth2-–-password" class="headerlink" title="1.1 oauth2 – password"></a>1.1 oauth2 – password</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FrC4d3hBIvkCOeUau3zQc_2IfG8q.png"></p><h2 id="1-2-oauth2-–-client-credentials"><a href="#1-2-oauth2-–-client-credentials" class="headerlink" title="1.2 oauth2 – client credentials"></a>1.2 oauth2 – client credentials</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqDkg-zCkKvAId2ONA4XnDLbtEuI.png"><br><em>注：这种认证方式是用在内部服务之间调用的场景，也就是服务间调用时是没有用户名和密码信息的。</em></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-单线程与多线程</title>
    <link href="/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-6-%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-6-%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Redis4-0-前"><a href="#1-Redis4-0-前" class="headerlink" title="1 Redis4.0 前"></a>1 Redis4.0 前</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkeO1VLueRdIKpUdD0AB0qZFVkMr.png"></p><ul><li><strong>可维护性</strong>好<ul><li>串行执行代码</li><li>程序执行顺序确定</li><li>不用考虑竞争条件，锁的问题</li></ul></li><li><strong>IO 多路复用</strong>并发处理客户端多个连接<ul><li>不再需要额外创建和维护线程来监听来自客户端的大量连接</li></ul></li><li>绝大多数操作的<strong>性能瓶颈</strong>都不是 CPU<ul><li>瓶颈在网络 I/O，内存</li></ul></li><li>使用多线程<strong>线程切换开销</strong><ul><li>多线程虽然会帮助我们更充分地利用 CPU 资源，但是线程切换会带来额外的开销，其中包括：<ul><li>保存线程 1 的执行上下文；</li><li>加载线程 2 的执行上下文；</li></ul></li></ul></li></ul><hr><h1 id="2-Reids4-0-～-Redis6-0"><a href="#2-Reids4-0-～-Redis6-0" class="headerlink" title="2 Reids4.0 ～ Redis6.0"></a>2 Reids4.0 ～ Redis6.0</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FjwGcJmQgXLicUOpiXTd51Lq7Fyt.png"></p><ul><li>workThread 执行命令依旧是串行<ul><li>部分删除命令异步执行（<code>FLUSHALL ASYNC</code> ，<code>FLUSHDB ASYNC</code>，<code>UNLINK</code>）<ul><li>key 都同步删除</li><li>value 在评估大小后，若大则由后台线程异步删除</li></ul></li></ul></li><li>引用多线程原因<ul><li>如果待删除的键值对占用了较小的内存空间，那么哪怕同步地删除这些键值对也不会消耗太多的时间。</li><li>但是对于一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务</li></ul></li></ul><hr><h1 id="3-Reids6-0-及以后"><a href="#3-Reids6-0-及以后" class="headerlink" title="3 Reids6.0 及以后"></a>3 Reids6.0 及以后</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvWlprhAlUxTTALYn4p8pexDqTUX.png"></p><ul><li>多个 I/O 线程</li></ul><p><code>I/O 多路复用模块收到数据包之后将其丢给后面多个 I/O 线程进行解析，I/O 线程处理结束后，主线程会负责串行的执行这些命令，由于向客户端发回数据包的过程也是比较耗时的，所以执行之后的结果也会交给多个 I/O 线程发送回客户端。</code><br>io 线程可以自己配置，官网建议 4 个（io 线程可以复用）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql</title>
    <link href="/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/Mysql/"/>
    <url>/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/Mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h2><ul><li>基于日志的<code>Redo/Undo</code>机制<ul><li>Redo Log：Redo log 用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据</li><li>Undo Log：Undo log 是用来记录数据更新前的值，保证数据更新失败能够回滚。</li></ul></li></ul><p>假如某个时刻数据库崩溃，在崩溃之前有事务 A 和事务 B 在执行，事务 A 已经提交，而事务 B 还未提交。当数据库重启进行 crash-recovery 时，就会通过 Redo log 将已经提交事务的更改写到数据文件，而还没有提交的就通过 Undo log 进行 roll back。</p><h2 id="一致性（Consistent）"><a href="#一致性（Consistent）" class="headerlink" title="一致性（Consistent）"></a>一致性（Consistent）</h2><h2 id="隔离性（Isalotion）"><a href="#隔离性（Isalotion）" class="headerlink" title="隔离性（Isalotion）"></a>隔离性（Isalotion）</h2><h2 id="持久性-Durable"><a href="#持久性-Durable" class="headerlink" title="持久性(Durable)"></a>持久性(Durable)</h2><hr><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ul><li><strong>读未提交（READ UNCOMMITTED）</strong><ul><li><strong>脏读问题</strong></li></ul></li><li><strong>读提交 （READ COMMITTED）</strong><ul><li><strong>解决脏读问题</strong></li><li><strong>有不可重复读问题（update）</strong></li></ul></li><li><strong>可重复读 （REPEATABLE READ）</strong><ul><li><strong>解决了不可重复读问题</strong></li><li><strong>有幻读问题（insert）</strong></li></ul></li><li><strong>串行化 （SERIALIZABLE）</strong><ul><li><strong>解决所有问题</strong></li></ul></li></ul><h2 id="MVCC-多版本并发控制）"><a href="#MVCC-多版本并发控制）" class="headerlink" title="MVCC(多版本并发控制）"></a>MVCC(多版本并发控制）</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fult8Bxn6TqZ2BawoKlb_viu46HY.png"></p><ul><li>在 InnoDB 中每一个事务都有一个自己的事务 id，并且是唯一的，递增的 。</li><li>对于 Mysql 中的每一个数据行都有可能存在多个版本，在每次事务更新数据的时候，都会生成一个新的数据版本，并且把自己的事务 id 赋值给当前版本的 row trx_id。</li><li>版本 1、版本 2 并非实际物理存在的</li><li>U1 和 U2 实际就是 undo log，这 v1 和 v2 版本是根据当前 v3 和 undo log 计算出来的</li></ul><hr><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁/排他锁"></a>共享锁/排他锁</h2><p>共享锁是针对同一份数据，多个读操作可以同时进行，简单来说即读加锁，不能写并且可并行读；<br>排他锁针对写操作，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它读写都阻塞 。</p><h2 id="行锁-表锁"><a href="#行锁-表锁" class="headerlink" title="行锁/表锁"></a>行锁/表锁</h2><p>是从锁的粒度上进行划分的，行锁锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，行锁也是 MyISAM 和 InnoDB 的区别之一，InnoDB 支持行锁并且支持事务 。<br>表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低。</p><h2 id="两个事务执行写操作，怎么保证并发？"><a href="#两个事务执行写操作，怎么保证并发？" class="headerlink" title="两个事务执行写操作，怎么保证并发？"></a>两个事务执行写操作，怎么保证并发？</h2><ul><li>有索引：<ul><li>事务 1 先 update 数据行的时候，先回获取行锁，锁定数据，当事务 2 要进行 update 操作的时候，也会取获取该数据行的行锁，但是已经被事务 1 占有，事务 2 只能 wait。</li></ul></li><li>无索引：<ul><li>获取所有行，都加上行锁，然后 Mysql 会再次过滤符合条件的的行并释放锁，只有符合条件的行才会继续持有锁。</li><li>性能消耗大</li></ul></li></ul><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-事务</title>
    <link href="/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-5-%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-5-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>一次执行多条命令<ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令<strong>依然被执行（不会回滚）</strong>。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul></li><li>阶段<ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul></li><li>事务命令：<br>| 1 | <a href="https://www.runoob.com/redis/transactions-discard.html">DISCARD</a><br>取消事务，放弃执行事务块内的所有命令。 |<br>| — | — |<br>| 2 | <a href="https://www.runoob.com/redis/transactions-exec.html">EXEC</a><br>执行所有事务块内的命令。 |<br>| 3 | <a href="https://www.runoob.com/redis/transactions-multi.html">MULTI</a><br>标记一个事务块的开始。 |<br>| 4 | <a href="https://www.runoob.com/redis/transactions-unwatch.html">UNWATCH</a><br>取消 WATCH 命令对所有 key 的监视。 |<br>| 5 | <a href="https://www.runoob.com/redis/transactions-watch.html">WATCH key [key …]</a><br>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 |</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-持久化</title>
    <link href="/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-7-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-7-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="7-持久化"><a href="#7-持久化" class="headerlink" title="7 持久化"></a>7 持久化</h1><h2 id="7-1-RDB"><a href="#7-1-RDB" class="headerlink" title="7.1 RDB"></a>7.1 RDB</h2><ul><li>全量持久化</li></ul><p>fork 和 cow。<br>fork 是指 redis 通过创建子进程来进行 RDB 操作，<br>cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2 id="7-2-AOF"><a href="#7-2-AOF" class="headerlink" title="7.2 AOF"></a>7.2 AOF</h2><ul><li>使用 AOF 持久时，服务会将每个收到的写命令通过写函数追加到文件中（appendonly.aof）</li><li>AOF 持久化存储方式参数说明<ul><li>appendonly  yes                  #开启 AOF 持久化存储方式</li><li>appendfsync   always           #收到写命令后就立即写入磁盘，效率最差，效果最好</li><li>appendfsync   everysec        #每秒写入磁盘一次     效率与效果居中</li><li>appendfsync   no                 #完全依赖操作系统，效率最佳，效果没法保证</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-内存</title>
    <link href="/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-4-%E5%86%85%E5%AD%98/"/>
    <url>/2021/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-4-%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="4-内存"><a href="#4-内存" class="headerlink" title="4 内存"></a>4 内存</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fp9joROEraAgrK03OLKLv3iAMNlo.png"></p><h2 id="4-1-Redis-内存消耗划分"><a href="#4-1-Redis-内存消耗划分" class="headerlink" title="4.1 Redis 内存消耗划分"></a>4.1 Redis 内存消耗划分</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fsc8r_QXa7nptyKiER-MKHjX8w4r.png"></p><h3 id="4-1-1-自身内存"><a href="#4-1-1-自身内存" class="headerlink" title="4.1.1 自身内存"></a>4.1.1 自身内存</h3><h3 id="4-1-2-对象内存"><a href="#4-1-2-对象内存" class="headerlink" title="4.1.2 对象内存"></a>4.1.2 <strong>对象内存</strong></h3><ul><li>redis 内存占用最大一部分，存储用户的所有数据</li><li>简单理解为 sizeof（keys）+sizeof（values）<ul><li>key：应当尽量避免使用过长的 key</li><li>value：在使用时一定要合理预估并监控 value 对象占用情况， 避免内存溢出</li></ul></li></ul><h3 id="4-1-3-缓冲内存"><a href="#4-1-3-缓冲内存" class="headerlink" title="4.1.3 缓冲内存"></a>4.1.3 缓冲内存</h3><ul><li>客户端缓冲（所有接入到 Redis 服务器 TCP 连接的输入输出缓冲 ，输入输出缓冲区在大流量的场景中容易失控， 造成 Redis 内存的不稳定， 需要重点监控 ）<ul><li>输入缓冲：无法控制，最大 1G，如果超过将断开连接</li><li>输出缓冲：通过参数 client-output-buffer-limit 控制 ，具体如下：<ul><li>普通客户端</li><li>从客户端</li><li>订阅客户端</li></ul></li></ul></li><li>复制积压缓冲区<ul><li>Redis 在 2.8 版本之后提供了一个可重用的固定大小缓<br>冲区用于实现部分复制功能， 根据 repl-backlog-size 参数控制， 默认 1MB。 对<br>于复制积压缓冲区整个主节点只有一个， 所有的从节点共享此缓冲区， 因此<br>可以设置较大的缓冲区空间， 如 100MB， 这部分内存投入是有价值的， 可以<br>有效避免全量复制</li></ul></li><li>AOF 缓冲区<ul><li>用于在 Redis 重写期间保存最近的写入命令 ，AOF 缓冲区空间消耗用户无法控制， 消耗的内存取决于 AOF 重写时间和写入命令量， 这部分空间占用通常很小。</li></ul></li></ul><h3 id="4-1-4-内存碎片"><a href="#4-1-4-内存碎片" class="headerlink" title="4.1.4 内存碎片"></a>4.1.4 内存碎片</h3><ul><li><strong>内存分配器</strong><ul><li>jemalloc （默认）</li><li>glibc</li><li>tcmalloc</li></ul></li><li><strong>内存分配策略</strong><ul><li>一般采用<strong>固定范围的内存块</strong>进行分配</li></ul></li><li><strong>出现内存碎片的情况</strong>（当存储的数据长短差异较大时， 以下场景容易出现高内存碎片问题：）<ul><li><strong>频繁更新操作</strong>（例如频繁对已存在的键执行 append、 setrange 等更新操作）</li><li><strong>大量过期键删除</strong>（键对象过期删除后， 释放的空间无法得到充分利用， 导致碎片率上升）</li></ul></li><li>**出现高内存碎片问题时常见的解决方式 **<ul><li><strong>数据对齐</strong><ul><li>（在条件允许的情况下尽量做数据对齐， 比如数据尽量采用数字类型或者固定长度字符串等， 但是这要视具体的业务而定， 有些场景无法做到 ）</li></ul></li><li><strong>安全重启</strong><ul><li>重启节点可以做到内存碎片重新整理</li><li>可以利用高可用架构， 如 Sentinel（哨兵）或 Cluster， 将碎片率过高的主节点转换为从节点， 进行安全重启</li></ul></li></ul></li></ul><hr><h2 id="4-2-内存分析"><a href="#4-2-内存分析" class="headerlink" title="4.2 内存分析"></a>4.2 内存分析</h2><ul><li>info memory<ul><li>used_memory_rss<ul><li>redis 进程占用的内存总量</li></ul></li><li>used_memory<ul><li>redis 分配器分配的内存总量，即内部存储的所有数据内存占用量</li></ul></li><li>men_fragmentation_ratio = used_memory_rss / used_memory<ul><li><blockquote><p>1 时：多出的部分没有用于数据存储，被内存碎片消耗</p></blockquote></li><li>&lt;1 时：OS 把 redis 内存交换到硬盘，redis 性能会变很差，甚至僵死！</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtAK1R6aa0RqgQj3XUztzEqfqlC2.png"></p><hr><h2 id="4-3-内存管理"><a href="#4-3-内存管理" class="headerlink" title="4.3 内存管理"></a>4.3 内存管理</h2><p><a href="https://redis.io/commands/expire">https://redis.io/commands/expire</a></p><h3 id="4-3-1-内存回收策略"><a href="#4-3-1-内存回收策略" class="headerlink" title="4.3.1 内存回收策略"></a>4.3.1 内存回收策略</h3><ul><li><strong>删除到达过期时间的键对象</strong><ul><li><strong>惰性删除</strong><ul><li>A key is passively expired simply when some client tries to access it, and the key is found to be timed out.</li></ul></li><li><strong>定时任务删除</strong><ul><li>自适应算法，根据键的过期比例、 使用快慢两种速率模式回收键</li><li>快慢两种速率模式内部删除逻辑相同，仅执行的超时时间不同</li></ul></li></ul></li><li><strong>内存溢出控制策略（</strong>内存使用达到 maxmemory 上限时触发）<ul><li>noeviction （默认）</li><li>volatile-lru</li><li>allkeys-lru</li><li>allkeys-random</li><li>volatile-random</li><li>volatile-ttl</li></ul></li></ul><h3 id="4-3-2-内存上限"><a href="#4-3-2-内存上限" class="headerlink" title="4.3.2 内存上限"></a>4.3.2 内存上限</h3><hr><h2 id="4-4-内存优化"><a href="#4-4-内存优化" class="headerlink" title="4.4 内存优化"></a>4.4 内存优化</h2>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-常见问题</title>
    <link href="/2021/02/04/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-8-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/02/04/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-8-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>未设置好 ttl 导致 redis 占用内存过多（30+G）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-数据结构</title>
    <link href="/2021/02/04/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/02/04/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0 概述"></a>0 概述</h1><ul><li>键对象都是字符串</li><li>value 对象更复杂些， 主要包含 5 种基本数据类型：<ul><li>字符串</li><li>列表</li><li>哈希</li><li>集合</li><li>有序集合</li><li>其他数据类型都是建立在这 5 种数据结构之上实现的， 如：<ul><li>Bitmaps 和 HyperLogLog 使用字符串实现</li><li>GEO 使用有序集合实现等</li></ul></li></ul></li></ul><hr><h1 id="1-五种基本数据结构"><a href="#1-五种基本数据结构" class="headerlink" title="1 五种基本数据结构"></a>1 五种基本数据结构</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhtAfmZnk8SAHaZmtateCZJYu-Vz.png"></p><h2 id="1-1-String"><a href="#1-1-String" class="headerlink" title="1.1 String"></a>1.1 String</h2><h3 id="1-1-1-SDS-数据结构"><a href="#1-1-1-SDS-数据结构" class="headerlink" title="1.1.1 SDS 数据结构"></a>1.1.1 SDS 数据结构</h3><blockquote><p>类似 java 的<strong>ArrayList</strong></p></blockquote><ul><li>Redis 没有直接使用 C 中的 String，自己定义了 SDS （_Simple Dynamic String_）数据结构存储字符串</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *sds;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span>     <span class="hljs-comment">// 对应的字符串长度小于 1&lt;&lt;5</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span>     <span class="hljs-comment">// 对应的字符串长度小于 1&lt;&lt;8</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span>                       <span class="hljs-comment">//目前字符串的长度</span><br>    <span class="hljs-type">uint8_t</span> alloc;                                <span class="hljs-comment">//已分配大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags;                          <span class="hljs-comment">//flag用3bit来标明类型，其余5bit目前没有使用</span><br>    <span class="hljs-type">char</span> buf[];                                   <span class="hljs-comment">//柔性数组，以&#x27;\0&#x27;结尾</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span>    <span class="hljs-comment">// 对应的字符串长度小于 1&lt;&lt;16</span><br>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span>    <span class="hljs-comment">// 对应的字符串长度小于 1&lt;&lt;32</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span>    <span class="hljs-comment">// 对应的字符串长度小于 1&lt;&lt;64</span><br>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-1-2-对比"><a href="#1-1-2-对比" class="headerlink" title="1.1.2 对比"></a>1.1.2 对比</h3><table><thead><tr><th></th><th></th><th>C 语言的 String</th><th>SDS <strong>（</strong><em>Simple Dynamic String</em><strong>）</strong></th><th></th></tr></thead><tbody><tr><td>效率</td><td>获取字符串长度时间复杂度</td><td>** O(N)**</td><td>O(1）</td><td>因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；</td></tr><tr><td></td><td>空间预分配</td><td>-</td><td>✔</td><td>修改 SDS 扩充长度时，会预分配额外的空间</td></tr><tr><td></td><td>惰性空间释放</td><td>-</td><td>✔</td><td></td></tr><tr><td>安全性</td><td><strong>杜绝缓冲区溢出/内存泄漏</strong></td><td>-</td><td>✔</td><td>String 执行拼接/截断操作，如果操作不当（忘记重新分配内存）就很容易造成问题，SDS 则会自动扩容/释放空间；</td></tr><tr><td>功能</td><td>二进制安全</td><td>-</td><td>✔</td><td>C 语言中的字符串中间出现的 <code>&#39;\\0&#39;</code>就认为到了末尾，所以不能保存图片，视频等二进制文件</td></tr></tbody></table><hr><h2 id="1-2-Hash"><a href="#1-2-Hash" class="headerlink" title="1.2 Hash"></a>1.2 Hash</h2><blockquote><ul><li>与 java 的 HashMap 类似<ul><li>数组+链表</li><li>链地址法解决 hash 冲突</li></ul></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 哈希表节点 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-comment">// 键</span><br>    <span class="hljs-type">void</span> *key;<br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>    &#125; v;<br>    <span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br><br><span class="hljs-comment">/* This is our hash table structure. Every dictionary has two of this as we implement incremental rehashing, for the old to the new table.</span><br><span class="hljs-comment"> * 哈希表</span><br><span class="hljs-comment"> * 每个字典都使用两个哈希表，以实现渐进式 rehash 。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">// 哈希表数组(一个哈希表数组，数组的每个项是entry链表的头结点)</span><br>    dictEntry **table;<br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-comment">// 总是等于 size - 1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br><br><span class="hljs-comment">/* 字典 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    <span class="hljs-comment">// 类型特定函数</span><br>    dictType *type;<br>    <span class="hljs-comment">// 私有数据</span><br>    <span class="hljs-type">void</span> *privdata;<br>    <span class="hljs-comment">// 哈希表</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// rehash 索引(当 rehash 不在进行时，值为 -1)</span><br>    <span class="hljs-type">int</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br>    <span class="hljs-comment">// 目前正在运行的安全迭代器的数量</span><br>    <span class="hljs-type">int</span> iterators; <span class="hljs-comment">/* number of iterators currently running */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fqb7VIsI1QxCLiH0I5Odq5BiLjta.png"></h3><h3 id="1-2-1-渐进式-Rehash"><a href="#1-2-1-渐进式-Rehash" class="headerlink" title="1.2.1 渐进式 Rehash"></a>1.2.1 渐进式 Rehash</h3><ul><li><strong>目的：</strong><ul><li>保证数据量大时<strong>不会阻塞其他操作</strong></li><li>rehash 是以<strong>bucket</strong>(桶,哈希表数组中的一条 entry 链表)为基本单位进行渐进式的数据迁移的，从 ht[0]中迁移至 ht[1]，每步完成一个 bucket 的迁移，直至所有数据迁移完毕</li></ul></li><li><strong>步骤</strong><ol><li> 在执行添加，删除，查找操作时，执行一次 dictRehash(dict,1)，迁移一个 bucket 数据</li><li> 为 ht[1] 分配空间，让字典同时拥有 ht[0] 和 ht[1] 两个哈希表。</li><li> 字典中维护一个 rehashidx，并将它置为 0，表示 Rehash 开始。</li><li> 在 Rehash 期间，每次对字典操作时，程序还顺便将 ht[0] 在 rehashidx 索引上 bucket rehash 到 ht[1] 中（_ Move all the keys in this _<strong>_bucket _</strong>_from the old to the new hash HT_）</li><li> rehashidx++</li></ol></li><li><strong>在 rehash 期间其他操作</strong><ul><li>查询：会先查 ht[0] ，若无，再查 ht[1]</li><li>插入：直接插入 ht[1]，保证 ht[0] 中数据只减不增</li></ul></li></ul><hr><h2 id="1-3-List"><a href="#1-3-List" class="headerlink" title="1.3 List"></a>1.3 List</h2><blockquote><ul><li>类似 java 的<strong>LinkedList</strong><ul><li><strong>双向链表</strong></li><li><strong>插入删除快</strong></li><li><strong>查询慢</strong></li></ul></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">void</span> *value;<br>&#125; listNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listIter</span> &#123;</span><br>    listNode *next;<br>    <span class="hljs-type">int</span> direction;<br>&#125; listIter;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    listNode *head;<br>    listNode *tail;<br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>    unsignedlong len;<br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FoJBk_azdL1YX1ra1kcyxArjDfX9.png"></p><hr><h2 id="1-4-Set"><a href="#1-4-Set" class="headerlink" title="1.4 Set"></a>1.4 Set</h2><blockquote><p>类似 java 的 HashSet</p></blockquote><ul><li>特点<ul><li>无序</li><li>不重复</li></ul></li><li>应用场景<ul><li>随机事件<ul><li>抽奖</li><li>验证码</li><li>好友推荐（取集合交集）</li></ul></li></ul></li></ul><h3 id="1-4-1-intset"><a href="#1-4-1-intset" class="headerlink" title="1.4.1 intset"></a>1.4.1 intset</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 集合对象保存的所有元素都是整数值 &amp;&amp; 集合对象保存的元素数量不超过512个</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-type">int8_t</span> contents[];<br>&#125; intset;<br><span class="hljs-comment">//------------------------------------------------------------------------</span><br><span class="hljs-comment">// 不符合以上情况，则使用hashtable, 字典中所有的 value 都是NULL。</span><br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsK9C0daGl6AiK5xefHL39KZG9YD.png"></p><h3 id="1-4-2-hashtable"><a href="#1-4-2-hashtable" class="headerlink" title="1.4.2 hashtable"></a>1.4.2 hashtable</h3><p>集合对象保存的所有元素都是整数值 &amp;&amp; 集合对象保存的元素数量不超过 512 个，这时候使用 intset，<br>不然就使用 hashtable, 字典中所有的 value 都是 NULL。这时候 set 就是 value 为 NULL 的特使字典。</p><hr><h2 id="1-5-zset"><a href="#1-5-zset" class="headerlink" title="1.5 zset"></a>1.5 zset</h2><ul><li>底层数据结构（超过阈值（可自己设置），数据结构变成 ziplist）</li></ul><h3 id="1-5-1-跳表-skiplist"><a href="#1-5-1-跳表-skiplist" class="headerlink" title="1.5.1 跳表 skiplist"></a>1.5.1 跳表 skiplist</h3><ul><li>（近似折半查找）有序链表改造成支持折半查找的数据结构（方便查找及插入删除）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkP1gb9ASQpEvNACPBeOpenIAW9v.png"></p><h3 id="1-5-2-压缩列表-ziplist"><a href="#1-5-2-压缩列表-ziplist" class="headerlink" title="1.5.2 压缩列表 ziplist"></a>1.5.2 压缩列表 ziplist</h3><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgFIp9z1o0dbyry_XX_GzPUR9dC5.svg"><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqJu6UdfE4e1BOBtlhK2qpqptEYS.png"></p><ul><li>zlbytes 为 0x50(十进制 80),表示压缩列表的总长度为 80 字节。</li><li>zltail 为 0x3c(十进制 60),尾节点偏移量 60</li><li>zlen 为 0x3(十进制 3),表示压缩列表包含三个节点</li><li>entry：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmcsD9Knkev4SkTVgRlQbWnZt4Dh.png"></p><ul><li>previous_entry_length 属性以字节为单位,记录了压缩列表中前一个节点的长度。</li><li>encoding 属性记录了节点的 content 属性所保存数据的类型以及长度。</li><li>content 属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的 encoding 属性决定</li></ul><hr><h1 id="2-其他数据类型"><a href="#2-其他数据类型" class="headerlink" title="2 其他数据类型"></a>2 其他数据类型</h1><h2 id="2-1-HyperLogLog"><a href="#2-1-HyperLogLog" class="headerlink" title="2.1 HyperLogLog"></a>2.1 HyperLogLog</h2><blockquote><p><a href="http://content.research.neustar.biz/blog/hll.html">http://content.research.neustar.biz/blog/hll.html</a></p></blockquote><ul><li>特点<ul><li>无法保证高精度</li><li>节省空间（初始状态的稀疏存储 HyperLogLog 只需 2 字节，密集存储结构为 12KB）</li></ul></li><li>适合场景<ul><li>适合对精度要求不高的大量统计需求</li></ul></li><li>做法<ul><li>HyperLogLog 的基本思想是利用集合中数字的比特串第一个 1 出现位置的最大值来预估整体基数，但是这种预估方法存在较大误差，为了改善误差情况，HyperLogLog 中引入分桶平均的概念，计算 16384 个桶的调和平均数。</li></ul></li></ul><h3 id="2-1-1-存储过程"><a href="#2-1-1-存储过程" class="headerlink" title="2.1.1 存储过程"></a>2.1.1 存储过程</h3><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fq1lfZdZCnUQBDGNnBbToLRwghib.png"></p><h3 id="2-1-2-存储结构"><a href="#2-1-2-存储结构" class="headerlink" title="2.1.2 存储结构"></a>2.1.2 存储结构</h3><blockquote><p><a href="https://www.zhihu.com/search?type=content&q=redis%20HyperLogLog">https://www.zhihu.com/search?type=content&amp;q=redis%20HyperLogLog</a></p></blockquote><ul><li>数据结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hllhdr</span> &#123;</span><br>    <span class="hljs-type">char</span> magic[<span class="hljs-number">4</span>]; <span class="hljs-comment">/* 魔法值 &quot;HYLL&quot; */</span><br>    <span class="hljs-type">uint8_t</span> encoding; <span class="hljs-comment">/* 密集结构或者稀疏结构 HLL_DENSE or HLL_SPARSE. */</span><br>    <span class="hljs-type">uint8_t</span> notused[<span class="hljs-number">3</span>]; <span class="hljs-comment">/* 保留位, 全为0. */</span><br>    <span class="hljs-type">uint8_t</span> card[<span class="hljs-number">8</span>]; <span class="hljs-comment">/* 基数大小的缓存 */</span><br>    <span class="hljs-type">uint8_t</span> registers[]; <span class="hljs-comment">/* 数据字节数组 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>HLL_DENSE 密集存储结构<ul><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fj7N3RTAhHdBTngN2KCVeHGFQ893.png"></li></ul></li><li>HLL_SPARSE 稀疏存储结构<ul><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtQyGD5Wt1y7_GP7gF6k5llRjVHO.png"></li><li>ZERO : 一字节，表示连续多少个桶计数为 0，前两位为标志 00，后 6 位表示有多少个桶，最大为 64。</li><li>XZERO : 两个字节，表示连续多少个桶计数为 0，前两位为标志 01，后 14 位表示有多少个桶，最大为 16384。</li><li>VAL : 一字节，表示连续多少个桶的计数为多少，前一位为标志 1，四位表示连桶内计数，所以最大表示桶的计数为 32。后两位表示连续多少个桶。</li></ul></li></ul><hr><h2 id="2-2-BitMap"><a href="#2-2-BitMap" class="headerlink" title="2.2 BitMap"></a>2.2 BitMap</h2><ul><li>bitmap 并不是一种真实的数据结构，它本质上是<strong>String 数据结构</strong>，只不过操作的<strong>粒度</strong>变成了<strong>位（bit）</strong></li><li>bitmap 就是通过最小的单位 bit 来进行 0 或者 1 的设置，表示某个元素对应的值或者状态。</li><li>bitmap 最多可以存储 2^32 个 bit（String 类型最大长度为 512MB）</li></ul><h3 id="2-2-1-应用场景-BloomFilter"><a href="#2-2-1-应用场景-BloomFilter" class="headerlink" title="2.2.1 应用场景-BloomFilter"></a>2.2.1 应用场景-BloomFilter</h3><p>这个就是 Redis 实现的 BloomFilter，BloomFilter 非常简单，如下图所示，假设已经有 3 个元素 a、b 和 c，分别通过 3 个 hash 算法 h1()、h2()和 h2()计算然后对一个 bit 进行赋值，接下来假设需要判断 d 是否已经存在，那么也需要使用 3 个 hash 算法 h1()、h2()和 h2()对 d 进行计算，然后得到 3 个 bit 的值，恰好这 3 个 bit 的值为 1，这就能够说明：<strong>d 可能存在集合中</strong>。再判断 e，由于 h1(e)算出来的 bit 之前的值是 0，那么说明：<strong>e 一定不存在集合中</strong>：<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvDNDM0nhjvvMPr4DK_KZXxMo3Zi.jpeg"></p><hr><h2 id="2-3-GEO"><a href="#2-3-GEO" class="headerlink" title="2.3 GEO"></a>2.3 GEO</h2><hr><h2 id="2-4-Streams"><a href="#2-4-Streams" class="headerlink" title="2.4 Streams"></a>2.4 Streams</h2><p>Redis5.0 引入的全新数据结构<br>用一句话概括 Streams 就是 Redis 实现的<strong>内存版 kafka</strong>。<br>Stream 的消费模型借鉴了 kafka 的**Consumer Groups(<strong>消费分组</strong>)**的概念，它弥补了 Redis Pub/Sub 不能持久化消息的缺陷。<br>但是它又不同于 kafka，kafka 的消息可以分 partition，而 Stream 不行。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务管理</title>
    <link href="/2021/01/29/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <url>/2021/01/29/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-编程式事务"><a href="#1-编程式事务" class="headerlink" title="1 编程式事务"></a>1 编程式事务</h1><ul><li>在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">DefaultTransactionDefinition <span class="hljs-keyword">def</span> = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();<br>        <span class="hljs-keyword">def</span>.setReadOnly(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">def</span>.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);<br>        <span class="hljs-keyword">def</span>.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);<br>        TransactionStatus status = transactionManager.getTransaction(<span class="hljs-keyword">def</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// xxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br>            transactionManager.commit(status);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            transactionManager.rollback(status);<br>            log.error(<span class="hljs-string">&quot;删除失败，事务回滚&quot;</span>, e);<br>        &#125;<br></code></pre></td></tr></table></figure><h1 id="2-声明式事务"><a href="#2-声明式事务" class="headerlink" title="2 声明式事务"></a>2 声明式事务</h1><ul><li>基于 AOP 面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低</li><li>实现方式：<ul><li>基于 TX 和 AOP 的 xml 配置文件</li><li>基于@Transactional 注解</li></ul></li></ul><h2 id="2-1-Transactional"><a href="#2-1-Transactional" class="headerlink" title="2.1 @Transactional"></a>2.1 @Transactional</h2><h3 id="2-1-1-作用范围"><a href="#2-1-1-作用范围" class="headerlink" title="2.1.1 作用范围"></a>2.1.1 作用范围</h3><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FuVlXalzP4YQ-wN4CTzvh0I6Cxc6.png"></p><ul><li>TYPE（Class, interface (including annotation type), or enum declaration）<ul><li>类</li><li>接口</li><li>枚举</li></ul></li><li>METHOD（Method declaration）<ul><li>方法</li></ul></li></ul><hr><h3 id="2-1-2-Transactional-属性"><a href="#2-1-2-Transactional-属性" class="headerlink" title="2.1.2 @Transactional 属性"></a>2.1.2 @Transactional 属性</h3><h4 id="propagation-属性"><a href="#propagation-属性" class="headerlink" title="propagation 属性"></a>propagation 属性</h4><p>propagation 代表事务的传播行为，默认值为 Propagation.REQUIRED</p><ul><li><strong>Propagation.REQUIRED</strong>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。( 也就是说如果 A 方法和 B 方法都添加了注解，在默认传播模式下，A 方法内部调用 B 方法，会把两个方法的事务<strong>合并为一个事务</strong> ）</li><li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li><li>Propagation.MANDATORY：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li><li>Propagation.REQUIRES_NEW：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。( 当类 A 中的 a 方法用默认 Propagation.REQUIRED 模式，类 B 中的 b 方法加上采用 Propagation.REQUIRES_NEW 模式，然后在 a 方法中调用 b 方法操作数据库，然而 a 方法抛出异常后，b 方法并没有进行回滚，因为 Propagation.REQUIRES_NEW 会暂停 a 方法的事务 )</li><li>Propagation.NOT_SUPPORTED：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li><li>Propagation.NEVER：以非事务的方式运行，如果当前存在事务，则抛出异常。</li><li>Propagation.NESTED ：和 Propagation.REQUIRED 效果一样。</li></ul><h4 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a>isolation 属性</h4><ul><li>isolation ：事务的隔离级别，默认值为 Isolation.DEFAULT。</li><li><strong>Isolation.DEFAULT</strong>：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul><h4 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a>timeout 属性</h4><ul><li>timeout ：事务的超时时间，默认值为 <strong>-1</strong>。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li></ul><h4 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a>readOnly 属性</h4><ul><li>readOnly ：指定事务是否为只读事务，默认值为 <strong>false</strong>；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</li></ul><h4 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h4><blockquote><p>By default, a transaction will be rolling back on <strong>RuntimeException</strong> and <strong>Error</strong> but not on checked exceptions (business exceptions</p></blockquote><ul><li>rollbackFor ：用于指定能够触发事务回滚的异常类型（默认只有在<strong>RuntimeException</strong> and <strong>Error 时回滚</strong>），可以指定多个异常类型。</li></ul><h4 id="noRollbackFor-属性"><a href="#noRollbackFor-属性" class="headerlink" title="noRollbackFor 属性"></a>noRollbackFor 属性</h4><ul><li>noRollbackFor：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</li></ul><hr><h3 id="2-1-3-Transactional-失效场景"><a href="#2-1-3-Transactional-失效场景" class="headerlink" title="2.1.3 @Transactional 失效场景"></a>2.1.3 @Transactional 失效场景</h3><h4 id="2-1-3-1-应用在非-public-修饰的方法"><a href="#2-1-3-1-应用在非-public-修饰的方法" class="headerlink" title="2.1.3.1 应用在非 public 修饰的方法"></a>2.1.3.1 应用在非 public 修饰的方法</h4><h4 id="2-1-3-2-被同一个类中方法调用"><a href="#2-1-3-2-被同一个类中方法调用" class="headerlink" title="2.1.3.2 被同一个类中方法调用"></a>2.1.3.2 被同一个类中方法调用</h4><h4 id="2-1-3-3-异常被-catch"><a href="#2-1-3-3-异常被-catch" class="headerlink" title="2.1.3.3 异常被 catch"></a>2.1.3.3 异常被 catch</h4><h4 id="2-1-3-4-数据库引擎不支持事务"><a href="#2-1-3-4-数据库引擎不支持事务" class="headerlink" title="2.1.3.4 数据库引擎不支持事务"></a>2.1.3.4 数据库引擎不支持事务</h4><hr><h1 id="3-坑"><a href="#3-坑" class="headerlink" title="3 坑"></a>3 坑</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁</title>
    <link href="/2021/01/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2021/01/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<ul><li>基于 MySQL 中的锁：<ul><li>MySQL 本身有自带的悲观锁 for update 关键字，也可以自己实现悲观/乐观锁来达到目的；</li></ul></li><li>基于 Zookeeper 有序节点：<ul><li>Zookeeper 允许临时创建有序的子节点，这样客户端获取节点列表时，就能够当前子节点列表中的序号判断是否能够获得锁；</li></ul></li><li>基于 Redis 的单线程：<ul><li>由于 Redis 是单线程，所以命令会以串行的方式执行，并且本身提供了像 SETNX(set if not exists) 这样的指令，本身具有互斥性；</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-应用场景</title>
    <link href="/2021/01/25/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2021/01/25/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是-redis"><a href="#1-什么是-redis" class="headerlink" title="1 什么是 redis"></a>1 什么是 redis</h1><p>Redis 是一个开源的，使用 C 语言编写，基于内存的数据结构存储，可用作于缓存、消息中间件。</p><h1 id="2-redis-的特点"><a href="#2-redis-的特点" class="headerlink" title="2 redis 的特点"></a>2 redis 的特点</h1><ul><li>性能极高。Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。</li><li>丰富的数据类型。</li><li>原子。 Redis 的操作是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li><li>丰富的特性。Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h1 id="3-如何使用-redis"><a href="#3-如何使用-redis" class="headerlink" title="3 如何使用 redis"></a>3 如何使用 redis</h1><h1 id="3-1-添加依赖"><a href="#3-1-添加依赖" class="headerlink" title="3.1 添加依赖"></a>3.1 添加依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-2-添加配置"><a href="#3-2-添加配置" class="headerlink" title="3.2 添加配置"></a>3.2 添加配置</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@<span class="hljs-keyword">Configuration</span><br>@ConditionalOnClass(RedisOperations.<span class="hljs-keyword">class</span>)<br>@EnableConfigurationProperties(RedisProperties.<span class="hljs-keyword">class</span>)<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> RedisConfig &#123;<br><br>    @Bean<br>    @ConditionalOnMissingBean(<span class="hljs-type">name</span> = &quot;redisTemplate&quot;)<br>    <span class="hljs-built_in">public</span> RedisTemplate&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;<br>        RedisTemplate&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; template = <span class="hljs-built_in">new</span> RedisTemplate&lt;&gt;();<br>        // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化)<br>        Jackson2JsonRedisSerializer&lt;<span class="hljs-keyword">Object</span>&gt; jackson2JsonRedisSerializer = <span class="hljs-built_in">new</span> Jackson2JsonRedisSerializer&lt;&gt;(<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">class</span>);<br>        ObjectMapper objectMapper = <span class="hljs-built_in">new</span> ObjectMapper();<br>        // 解决jackson2无法反序列化LocalDateTime的问题<br>        objectMapper.<span class="hljs-keyword">disable</span>(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>        objectMapper.registerModule(<span class="hljs-built_in">new</span> JavaTimeModule());<br>        // 指定要序列化的域，field,<span class="hljs-keyword">get</span>和<span class="hljs-keyword">set</span>,以及修饰符范围，<span class="hljs-keyword">ANY</span>是都有包括private和<span class="hljs-built_in">public</span><br>        objectMapper.setVisibility(PropertyAccessor.<span class="hljs-keyword">ALL</span>, JsonAutoDetect.Visibility.<span class="hljs-keyword">ANY</span>);<br>        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,<span class="hljs-type">Integer</span>等会跑出异常<br>        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>        // <span class="hljs-keyword">value</span>值的序列化采用Jackson2JsonRedisSerialize<br>        <span class="hljs-keyword">template</span>.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">template</span>.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        // key的序列化采用StringRedisSerializer<br>        <span class="hljs-keyword">template</span>.setKeySerializer(<span class="hljs-built_in">new</span> StringRedisSerializer());<br>        <span class="hljs-keyword">template</span>.setHashKeySerializer(<span class="hljs-built_in">new</span> StringRedisSerializer());<br>        <span class="hljs-keyword">template</span>.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">template</span>;<br>    &#125;<br><br>    @Bean<br>    @ConditionalOnMissingBean(StringRedisTemplate.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-built_in">public</span> StringRedisTemplate stringRedisTemplate(<br>        RedisConnectionFactory redisConnectionFactory) &#123;<br>        StringRedisTemplate template = <span class="hljs-built_in">new</span> StringRedisTemplate();<br>        <span class="hljs-keyword">template</span>.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">template</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.8</span><span class="hljs-number">.123</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">100</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">100000</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">1000000</span><br></code></pre></td></tr></table></figure><h1 id="4-redis-的应用场景"><a href="#4-redis-的应用场景" class="headerlink" title="4 redis 的应用场景"></a>4 redis 的应用场景</h1><h2 id="4-1-缓存热点数据"><a href="#4-1-缓存热点数据" class="headerlink" title="4.1 缓存热点数据"></a>4.1 缓存热点数据</h2><p>由于 redis 访问速度快、支持的数据类型比较丰富，所以 redis 很适合用来存储热点数据。<br>在新闻及来信来访等模块中，会把一网首页中的信息保存至 redis，从而保证首页的访问速度以及减轻对数据库的压力。</p><h2 id="4-2-分布式锁"><a href="#4-2-分布式锁" class="headerlink" title="4.2 分布式锁"></a>4.2 分布式锁</h2><p>主要利用 redis 的 SET key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]命令实现分布式锁，在获取锁时同时设置过期时间保证获取锁的节点宕机后不会造成死锁。<br>新闻模块及来信来访等模块中有定时任务，为防止集群环境中各节点多次执行定时任务，就采取了通过 redis 实现分布式锁的方案。</p><h2 id="4-3-统计点击量"><a href="#4-3-统计点击量" class="headerlink" title="4.3 统计点击量"></a>4.3 统计点击量</h2><p>在一网首页统计点击量时，若直接刷新点击量至数据库可能会对数据库造成较大压力。由于 redis incrby 命令可以实现原子性的递增，所以可以在 redis 中保存点击量，然后定时刷新至数据库，以此减轻数据库的压力，并且提升性能。</p><h2 id="4-4-获取全局唯一-id"><a href="#4-4-获取全局唯一-id" class="headerlink" title="4.4 获取全局唯一 id"></a>4.4 获取全局唯一 id</h2><p>主要利用 incrby 命令实现原子性的递增，以此获取全局唯一 id<br>在来信来访模块中，为保证信访件号唯一，就采取了通过 redis 获取全局唯一 id 的方案</p><h2 id="4-5-定时任务"><a href="#4-5-定时任务" class="headerlink" title="4.5 定时任务"></a>4.5 定时任务</h2><ul><li>redis.conf 中添加 notify-keyspace-events Ex 配置</li><li>客户端监听 redis 的过期事件（只知道过期的 key，不知道 value）</li></ul><h2 id="4-6-获取时间范围内的值"><a href="#4-6-获取时间范围内的值" class="headerlink" title="4.6 获取时间范围内的值"></a>4.6 获取时间范围内的值</h2><ul><li>zset 数据结构，score 保存时间</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-OLTP-与-OLAP"><a href="#1-OLTP-与-OLAP" class="headerlink" title="1 OLTP 与 OLAP"></a>1 OLTP 与 OLAP</h1><ul><li>OLTP：<ul><li>应用叫联机事务处理应用，就是类似银行转账等业务的，这类应用对事务要求比较高。</li><li>适合用 mysql 这类数据库</li></ul></li><li>OLAP：<ul><li>应用叫联机分析处理应用，比如推荐系统，是在收集了大量用户行为后进行分析，再得出结论的应用，主要侧重分析，对事务要求非常低。</li><li>适合用 hbase 这类数据库</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HBase</title>
    <link href="/2021/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/HBase/"/>
    <url>/2021/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/HBase/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li><strong>低成本存储海量</strong>的数据（依赖 HDFS）<ul><li>低成本：列式存储，适合存储稀疏数据</li></ul></li><li><strong>存储数据的”结构“可以地非常灵活（</strong>列式存储<strong>）</strong><ul><li><strong>若只取某几列数据，可以直接取（列簇），无需扫描所有记录</strong></li><li><strong>若想查询所有信息，可以通过列簇一次取出</strong></li><li>拆开每一行的每一列，然后通过 rowKey 关联起来</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhvT32m8F0i_LIr09cLfEE2oqPDE.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符集与编码规则</title>
    <link href="/2021/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/"/>
    <url>/2021/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<ul><li>字符集：为每一个字符分配一个唯一 id（码位）<ul><li>unicode</li></ul></li><li>编码规则：将码位转化为字节序列的规则<ul><li>utf-8 / utf-16</li></ul></li></ul><h1 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h1><p>在计算机中，1 字节对应 8 位二进制数，而每位二进制数有 0、1 两种状态，因此 1 字节可以组合出 256 种状态。如果这 256 中状态每一个都对应一个符号，就能通过 1 字节的数据表示 256 个字符。美国人于是就制定了一套编码（其实就是个字典），描述英语中的字符和这 8 位二进制数的对应关系，这被称为 ASCII 码。<br>ASCII 码一共定义了 128 个字符，例如大写的字母 A 是 65（对应二进制是 0100 0001）。这 128 个字符只使用了 8 位二进制数中的后面 7 位，最前面的一位统一规定为 0。</p><p>历史问题<br>英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。于是，一些欧洲的国家就决定，将 ASCII 码中闲置的最高位利用起来，这样一来就能表示 256 个字符。但是，这里又有了一个问题，那就是不同的国家的字符集可能不同，就算它们都能用 256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。         因此，ASCII 码的问题在于尽管所有人都在 0 - 127 号字符上达成了一致，但对于 128 - 255 号字符上却有很多种不同的解释。与此同时，亚洲语言有更多的字符需要被存储，一个字节已经不够用了。于是，人们开始使用两个字节来存储字符。<br>各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>最终，美国人意识到他们应该提出一种标准方案来展示世界上所有语言中的所有字符，出于这个目的，Unicode 诞生了。<br>Unicode 可以当作是一本很厚的字典，记录着世界上所有字符与其对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是 Unicode 考虑的问题了，我们只用知道 Unicode 给所有的字符指定了一个数字用来表示该字符。<br>对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。<br>Unicode 编码方案：<br>之前提到，Unicode 没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节，甚至更多字节来表示了。<br>这就导致了一些问题，计算机怎么知道你这个 2 个字节表示的是一个字符，而不是分别表示两个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 4 字节就可以表示了，那么我们就将所有的字符都用 4 个字节来表示，不够的就往前面补 0。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍，这显然是无法接受的。<br>于是，为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。</p><h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><p>UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。<br>UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是<strong>可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度</strong>。编码规则如下：<br>对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。<br>对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为 0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。<br><strong>编码规则如下：</strong><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FnPKjDyFsCKtDK9iIhxpe0rLRinQ.png"><br>根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。<br>“汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。    <br>解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位 1，那么连续有多少个 1，就表示该字符占用多少个字节。</p><h1 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h1><p>在了解 UTF-16 编码方式之前，先了解一下另外一个概念——“平面”。<br>在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个（2^5）平面，也就是说，整个 Unicode 字符集的大小现在是 2^21。<br>最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。<br>基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。<strong>它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节</strong>。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢<br>这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。<br>辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。<br>因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。<br>接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。<br>汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为 0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。<br>Unicode3.0 中给出了辅助平面字符的转换公式：<br>H = Math.floor((c-0x10000) / 0x400)+0xD800<br>L = (c - 0x10000) % 0x400 + 0xDC00<br>根据编码公式，可以很方便的计算出字符的 UTF-16 编码</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令</title>
    <link href="/2021/01/13/%E5%91%BD%E4%BB%A4/%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/01/13/%E5%91%BD%E4%BB%A4/%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li><p>启动 systemctl start docker</p></li><li><p>关闭 systemctl stop docker</p></li><li><p>重启 systemctl restart docker</p></li><li><p>抓取 image</p><ul><li>docker image pull [组]/[image 文件名]</li></ul></li><li><p>查看 image</p><ul><li>docker image ls</li><li>docker images</li></ul></li><li><p>运行</p><ul><li>根据 image 文件，每次都生成一个正在运行的容器实例，若本地没有该 image，则从仓库自动抓取<ul><li>docker container run [image 文件名]</li></ul></li><li>启动已经生成并停止运行的 container<ul><li>docker container start [containID]</li></ul></li></ul></li><li><p>终止</p><ul><li>强行立即终止（SIGKILL）<ul><li>docker container kill [containID]</li></ul></li><li>应用程序可以进行一些收尾工作（SIGTERM）<ul><li>docker container stop [containID]</li></ul></li></ul></li><li><p>查看 container</p><ul><li>正在运行<ul><li>docker container ls</li></ul></li><li>所有：正在运行的+停止运行的<ul><li>docker container ls -all</li></ul></li></ul></li><li><p>删除 container</p><ul><li>docker container rm [containID]</li></ul></li><li><p>创建 image 文件</p><ul><li>docker image build -t [imageName] . (. 表示 Dockerfile 文件路径)</li></ul></li><li><p>查看 log 输出</p><ul><li>docker container logs [containerID]</li><li>docker logs -f -t –tail=20 [redis]</li></ul></li><li><p>进入容器</p><ul><li>docker container exec -it [containerID] /bin/bash</li></ul></li><li><p>拷贝文件至本机</p><ul><li>docker container cp [containID]:[/path/to/file] .</li></ul></li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul><li>docker<ul><li>docker run -d –name redis -p 6379:6379 redis:latest redis-server –appendonly yes –requirepass “123456”</li></ul></li><li>启动：<ul><li>redisstart</li><li>nohup /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf &amp;</li></ul></li><li>关闭：<ul><li>redisshutdown</li><li>/usr/local/redis/bin/redis-cli shutdown</li></ul></li></ul><h1 id="clickhouse"><a href="#clickhouse" class="headerlink" title="clickhouse"></a>clickhouse</h1><p>docker run -d –name test-clickhouse-server-latest –ulimit nofile=262144:262144 –platform linux/amd64 yandex/clickhouse-server</p><p>docker run -d –name single-clickhouse-server:21.11 <br>–ulimit nofile=262144:262144 <br>-p 8123:8123 -p 9000:9000 -p 9009:9009 <br>–volume=/Users/will/studySpace/docker/clickhouse/single-volume/data:/var/lib/clickhouse <br>–platform linux/amd64 <br>yandex/clickhouse-server:21.11</p><p>docker pull yandex/clickhouse-server:21.11</p><p>docker run -d –name clickhouse-server <br>–ulimit nofile=262144:262144 <br>-p 8123:8123 -p 9000:9000 -p 9009:9009 <br>–volume=/Users/will/studySpace/docker/clickhouse/single-volume/data:/var/lib/clickhouse <br>–platform linux/amd64 <br>lunalabsltd/clickhouse-server:21.7.2.7-arm</p><hr><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">docker启动方式：</span><br><span class="hljs-meta"># </span><span class="language-bash">拉取kafka:</span><br>  docker pull wurstmeister/zookeeper<br><span class="hljs-meta"># </span><span class="language-bash">拉取zookeeper:</span><br>  docker pull wurstmeister/kafka<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="language-bash">运行zookeeper:</span><br>  docker run -d --name zookeeper  -p 2181:2181 -t wurstmeister/zookeeper<br><span class="hljs-meta">#</span><span class="language-bash">运行kafka:</span><br>  docker run -d --name kafka --publish 9092:9092 \<br>  --link zookeeper \<br>  --env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \<br>  --env KAFKA_ADVERTISED_HOST_NAME=127.0.0.1 \<br>  --env KAFKA_ADVERTISED_PORT=9092 \<br>  wurstmeister/kafka<br><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-built_in">kill</span>进程</span><br>kill -9 $(ps -ef|grep zookeeper |awk &#x27;$0 !~/grep/ &#123;print $2&#125;&#x27; |tr -s &#x27;\n&#x27; &#x27; &#x27;)<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">启动zookeeper</span><br>nohup /usr/local/Cellar/kafka/2.7.0/bin/zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp;<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">启动kafka</span><br>nohup /usr/local/Cellar/kafka/2.7.0/bin/kafka-server-start /usr/local/etc/kafka/server.properties &amp;<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">创建topic列表</span><br>kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic mainfab_mes_topic<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">查看topic列表</span><br>kafka-topics --list --zookeeper localhost:2181<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">查看消费者组的消费情况（可以查看谁在消费消息）</span><br>./kafka-consumer-groups.sh --bootstrap-server 192.168.11.80:9092 --group aegis-consumer-alarmlevel-action-alarm --describe<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">发送消息</span><br>kafka-console-producer --broker-list localhost:9092 --topic mainfab_mes_topic<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">接收消息</span><br>kafka-console-consumer --bootstrap-server localhost:9092 --topic mainfab_mes_topic --from-beginning<br></code></pre></td></tr></table></figure><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><ul><li><p>系统偏好设置</p></li><li><p>sudo /usr/local/mysql/support-files/mysql.server stop</p></li><li><p>sudo /usr/local/mysql/support-files/mysql.server start</p></li><li><p>sudo /usr/local/mysql/support-files/mysql.server restart</p></li></ul><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ul><li>docker<ul><li>docker pull nginx</li><li>docker run –name nginx-test -p 8080:80 -d nginx</li></ul></li><li>配置<ul><li>vi /usr/local/etc/nginx/nginx.conf</li></ul></li><li>命令<ul><li>启动<ul><li>nginx</li></ul></li><li>停止<ul><li>nginx -s quit</li></ul></li><li>重启<ul><li>nginx -s reload</li></ul></li><li>查看配置文件是否正确<ul><li>nginx -t</li></ul></li><li>查看版本<ul><li>nginx -v</li></ul></li></ul></li></ul><h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><ul><li>配置<ul><li>vi /Users/will/software/elasticsearch-7.12.0/config/elasticsearch.yml</li></ul></li><li>命令<ul><li>启动<ul><li>elasticsearch</li></ul></li><li>后台启动<ul><li>elasticsearch -d</li></ul></li></ul></li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li>netstat<ul><li>netstat -anop | grep 6379 | wc -l</li><li>netstat -anop | grep 6379</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>问题总结</title>
    <link href="/2021/01/13/%E9%A1%B9%E7%9B%AE/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/13/%E9%A1%B9%E7%9B%AE/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-正向代理："><a href="#1-正向代理：" class="headerlink" title="1 正向代理："></a>1 正向代理：</h1><p>push 服务部署的环境无法直接访问外网，无法调用第三方 api，需要通过代理服务器访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">--push容器需要配置环境变量：<br>JAVA_OPTS   -Dhttps.proxyPort=3128 -Dhttps.proxyHost=192.168.4.11 -Dhttps.proxySet=true -Dhttp.proxyPort=3128 -Dhttp.proxyHost=192.168.4.11<br>http_proxy 192.168.4.11:3128<br>https_proxy 192.168.4.11:3128<br></code></pre></td></tr></table></figure><hr><h1 id="2-SecureRandom-getInstanceStrong"><a href="#2-SecureRandom-getInstanceStrong" class="headerlink" title="2 SecureRandom.getInstanceStrong()"></a>2 SecureRandom.getInstanceStrong()</h1><p>图形验证码生成时需获取随机数，用 SecureRandom.getInstanceStrong()方式获取 SecureRandom，linux 环境下容易产生阻塞</p><hr><h1 id="3-i18n-的-properties-文件需区分大小写"><a href="#3-i18n-的-properties-文件需区分大小写" class="headerlink" title="3 i18n 的 properties 文件需区分大小写"></a>3 i18n 的 properties 文件需区分大小写</h1><p>windows 环境下不区分大小写也不会暴露问题，但是在 linux 上就会导致文件内容无法获取的问题</p><hr><h1 id="4-Flink-集群中每个节点都读取-oracle，导致-cpu-资源暴涨"><a href="#4-Flink-集群中每个节点都读取-oracle，导致-cpu-资源暴涨" class="headerlink" title="4 Flink 集群中每个节点都读取 oracle，导致 cpu 资源暴涨"></a>4 Flink 集群中每个节点都读取 oracle，导致 cpu 资源暴涨</h1><p>把 oracle 中的数据存一份到 hbase 中，然后 job 读 hbase</p><hr><h1 id="5-kf-sh-从头消费-topic-中消息"><a href="#5-kf-sh-从头消费-topic-中消息" class="headerlink" title="5 kf.sh 从头消费 topic 中消息"></a>5 kf.sh 从头消费 topic 中消息</h1><p>导致内存耗尽</p><hr><h1 id="5-redis"><a href="#5-redis" class="headerlink" title="5 redis"></a>5 redis</h1><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">org</span>.springframework.dao.<span class="hljs-type">QueryTimeoutException</span>: <span class="hljs-type">Redis</span> command timed out; nested exception is io.lettuce.core.<span class="hljs-type">RedisCommandTimeoutException</span>: <span class="hljs-type">Command</span> timed out after <span class="hljs-number">5</span> second(s)<br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.connection.lettuce.<span class="hljs-type">LettuceExceptionConverter</span>.convert(<span class="hljs-type">LettuceExceptionConverter</span>.<span class="hljs-title">java</span>:70)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.connection.lettuce.<span class="hljs-type">LettuceExceptionConverter</span>.convert(<span class="hljs-type">LettuceExceptionConverter</span>.<span class="hljs-title">java</span>:41)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.<span class="hljs-type">PassThroughExceptionTranslationStrategy</span>.translate(<span class="hljs-type">PassThroughExceptionTranslationStrategy</span>.<span class="hljs-title">java</span>:44)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.<span class="hljs-type">FallbackExceptionTranslationStrategy</span>.translate(<span class="hljs-type">FallbackExceptionTranslationStrategy</span>.<span class="hljs-title">java</span>:42)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.connection.lettuce.<span class="hljs-type">LettuceConnection</span>.convertLettuceAccessException(<span class="hljs-type">LettuceConnection</span>.<span class="hljs-title">java</span>:270)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.connection.lettuce.<span class="hljs-type">LettuceHashCommands</span>.convertLettuceAccessException(<span class="hljs-type">LettuceHashCommands</span>.<span class="hljs-title">java</span>:471)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.connection.lettuce.<span class="hljs-type">LettuceHashCommands</span>.hMSet(<span class="hljs-type">LettuceHashCommands</span>.<span class="hljs-title">java</span>:347)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.connection.<span class="hljs-type">DefaultedRedisConnection</span>.hMSet(<span class="hljs-type">DefaultedRedisConnection</span>.<span class="hljs-title">java</span>:1095)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.core.<span class="hljs-type">DefaultHashOperations</span>.lambda$putAll$7(<span class="hljs-type">DefaultHashOperations</span>.<span class="hljs-title">java</span>:151)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.core.<span class="hljs-type">RedisTemplate</span>.execute(<span class="hljs-type">RedisTemplate</span>.<span class="hljs-title">java</span>:228)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.core.<span class="hljs-type">RedisTemplate</span>.execute(<span class="hljs-type">RedisTemplate</span>.<span class="hljs-title">java</span>:188)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.core.<span class="hljs-type">AbstractOperations</span>.execute(<span class="hljs-type">AbstractOperations</span>.<span class="hljs-title">java</span>:96)</span><br>        at org.springframework.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.core.<span class="hljs-type">DefaultHashOperations</span>.putAll(<span class="hljs-type">DefaultHashOperations</span>.<span class="hljs-title">java</span>:150)</span><br></code></pre></td></tr></table></figure><p>ulimit -n 太小，需要改大</p><hr><h1 id="6-redis-连接池满"><a href="#6-redis-连接池满" class="headerlink" title="6 redis 连接池满"></a>6 redis 连接池满</h1><p>客户端不释放资源，导致连接池被占满。<br>现象：redis 中查看客户端数量爆满，重启 redis 后之前 established 状态的连接变成了 close_wait 状态，因为客户端不释放连接。杀掉有问题的客户端进程后问题消失</p><hr><h1 id="7-hashMap-并发-put-导致死循环-gt-cpu-资源耗尽"><a href="#7-hashMap-并发-put-导致死循环-gt-cpu-资源耗尽" class="headerlink" title="7 hashMap 并发 put 导致死循环 -&gt; cpu 资源耗尽"></a>7 hashMap 并发 put 导致死循环 -&gt; cpu 资源耗尽</h1><p>hashMap + parallelStream 并行流 导致了问题。<br>把 hashMap 改成 ConcurrentHashMap 问题解决</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2021/01/13/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/nginx/Nginx/"/>
    <url>/2021/01/13/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/nginx/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="0-Nginx-配置"><a href="#0-Nginx-配置" class="headerlink" title="0 Nginx 配置"></a>0 Nginx 配置</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span>              <span class="hljs-comment">#全局块</span><br><br>events &#123;         <span class="hljs-comment">#events块</span><br>   <span class="hljs-string">...</span><br>&#125;<br><br>http      <span class="hljs-comment">#http块</span><br>&#123;<br>    <span class="hljs-string">...</span>   <span class="hljs-comment">#http全局块</span><br>    keepalive_timeout   65;<br>    proxy_read_timeout  60; --接口超时时间,默认60（单位：s）<br>    server        <span class="hljs-comment">#server块</span><br>    &#123;<br>        <span class="hljs-string">...</span>       <span class="hljs-comment">#server全局块</span><br>        location [PATTERN]   <span class="hljs-comment">#location块</span><br>        &#123;<br>            <span class="hljs-string">...</span><br>        &#125;<br>        location [PATTERN]<br>        &#123;<br>            <span class="hljs-string">...</span><br>        &#125;<br>        -- error_page<br>        error_page 404 <span class="hljs-string">/404.html</span>;<br>        location = <span class="hljs-string">/404.html</span> &#123;<br>                root <span class="hljs-string">/usr/share/nginx/html</span>; -- 会在该<span class="hljs-string">/usr/share/nginx/html</span>路径下找404.html文件<br>        &#125;<br>        error_page 500 502 503 504 <span class="hljs-string">/50x.html</span>;<br>        location = <span class="hljs-string">/50x.html</span> &#123;<br>                root <span class="hljs-string">/usr/share/nginx/html</span>;<br>        &#125;<br><br>    &#125;<br>    server<br>    &#123;<br>      <span class="hljs-string">...</span><br>    &#125;<br>    <span class="hljs-string">...</span>     <span class="hljs-comment">#http全局块</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="1-正向代理-反向代理"><a href="#1-正向代理-反向代理" class="headerlink" title="1 正向代理/反向代理"></a>1 正向代理/反向代理</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhjOnzGxJE-hIDb3UZ0yzHu2tjbN.png"></p><h1 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2 负载均衡"></a>2 负载均衡</h1>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息补偿</title>
    <link href="/2021/01/12/%E9%A1%B9%E7%9B%AE/%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF/"/>
    <url>/2021/01/12/%E9%A1%B9%E7%9B%AE/%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务</title>
    <link href="/2021/01/11/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/01/11/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h1><ul><li><p>严格意义上的事务：ACID</p><ul><li><p><strong>原子性（Atomicity）</strong></p><ul><li>可以理解为一个事务内的所有操作要么都执行，要么都不执行。</li></ul></li><li><p><strong>一致性（Consistency）</strong></p><ul><li>可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据，比如你账上有 400，我账上有 100，你给我打 200 块，此时你账上的钱应该是 200，我账上的钱应该是 300，不会存在我账上钱加了，你账上钱没扣的<strong>中间状态</strong>。</li></ul></li><li><p><strong>隔离性（Isolation）</strong></p><ul><li>指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。</li></ul></li><li><p><strong>持久性（Durability）</strong></p><ul><li>指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。</li></ul></li></ul></li><li><p>通俗的事务：</p><ul><li>一些更新操作要么都成功，要么都失败。</li></ul></li></ul><p><em>注：redis 事务无法回滚，不能保证 AC?</em></p><hr><h1 id="2-分布式事务"><a href="#2-分布式事务" class="headerlink" title="2 分布式事务"></a>2 分布式事务</h1><p>分布式系统中实现事务，其实由多个本地事务组成<br>鸵鸟算法</p><h2 id="2-1-两阶段提交"><a href="#2-1-两阶段提交" class="headerlink" title="2.1 两阶段提交"></a>2.1 两阶段提交</h2><p>缺点：<br>单点故障（事务协调者：seata）<br>阻塞资源（提交或者回滚前占用数据库连接）<br>数据不一致（事务提交失败/事务回滚失败）</p><ul><li>seata 作为一个 server 注册在 eureka 上<ul><li>AT</li><li>TCC</li></ul></li></ul><h2 id="2-2-三阶段提交（用的不多）"><a href="#2-2-三阶段提交（用的不多）" class="headerlink" title="2.2 三阶段提交（用的不多）"></a>2.2 三阶段提交（用的不多）</h2><p>can-&gt;pre-&gt;do</p><ul><li>流程<ul><li>can commit（检查 sql，看是否可以执行）</li><li>pre commit（执行 sql，占用连接，但不提交）</li><li>do commit（提交事务）</li></ul></li></ul><h2 id="2-3-TCC（就是两阶段的一种）"><a href="#2-3-TCC（就是两阶段的一种）" class="headerlink" title="2.3 TCC（就是两阶段的一种）"></a>2.3 TCC（就是两阶段的一种）</h2><ul><li>try</li><li>comfirm</li><li>cancel</li></ul><h2 id="2-4-MQ"><a href="#2-4-MQ" class="headerlink" title="2.4 MQ"></a>2.4 MQ</h2><p>base 理论：允许数据暂时的不一致<br>提升性能：server1 -&gt; server2 -&gt; server3，只在 server1 执行完后直接返回，通过 mq 通知后续服务执行。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinIO</title>
    <link href="/2021/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93/MinIO/MinIO/"/>
    <url>/2021/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93/MinIO/MinIO/</url>
    
    <content type="html"><![CDATA[<ul><li>基于 Apache License v2.0 开源协议</li><li>兼容 Amazon S3 云存储服务接口</li><li>适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像（存储对象大小从几 kb 到最大 5T 不等）</li></ul><h1 id="1-Amazon-S3"><a href="#1-Amazon-S3" class="headerlink" title="1 Amazon S3"></a>1 Amazon S3</h1><p><strong>Amazon Simple Storage Service</strong> (Amazon S3) 是一种面向 Internet 的存储服务。可以通过 Amazon S3 随时在 Web 上的任何位置存储和检索的任意大小的数据。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MinIO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO</title>
    <link href="/2020/12/31/java%E5%9F%BA%E7%A1%80/IO/"/>
    <url>/2020/12/31/java%E5%9F%BA%E7%A1%80/IO/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiampI4hMgKOD3bVN98SFHVN3QoS.png"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/12/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ul><li>适配器模式：<ul><li>特点<ul><li>包装另一个对象，并提供<strong>不同的接口</strong>。</li></ul></li></ul></li><li>外观模式：<ul><li>特点<ul><li>包装<strong>许多</strong>对象，以简化他们的接口。</li></ul></li></ul></li><li>装饰器模式（又称 包装（Wrapper）模式）：<ul><li>特点<ul><li>包装另一个对象，保持<strong>原有的接口</strong>，并提供<strong>额外的行为</strong>。</li><li>从来不创建被装饰的对象，它总是添加新功能到已经存在的对象上</li><li>可以通过嵌套装饰添加多重额外功能</li></ul></li><li>应用<ul><li>java.io</li></ul></li></ul></li><li>代理模式：<ul><li>特点<ul><li>包装另一个对象，并**控制对它的访问(安全，权限等)**。</li><li>在被代理对象不存在的时候会创建被代理对象</li><li>一般不推荐使用嵌套代理</li></ul></li></ul></li><li>观察者模式</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>国际化</title>
    <link href="/2020/12/30/java%E5%9F%BA%E7%A1%80/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <url>/2020/12/30/java%E5%9F%BA%E7%A1%80/%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<ul><li>java.util.ResourceBundle 类通常用来实现国际化</li><li>它使用的 properties 文件的文件名规范：<ul><li>自定义名<em>语言代码</em>国别代码.properties</li><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fn-vQPd_DY6S_ezfXJEcNBksZdmO.png">（cn 需要大写，不然 Linux 环境无法读取该文件内容）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码扫描记录</title>
    <link href="/2020/12/17/%E9%A1%B9%E7%9B%AE/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/12/17/%E9%A1%B9%E7%9B%AE/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Enum-中不应存在-public-属性-setter-方法"><a href="#1-Enum-中不应存在-public-属性-setter-方法" class="headerlink" title="1 Enum 中不应存在 public 属性/setter 方法"></a>1 Enum 中不应存在 public 属性/setter 方法</h1><h1 id="2-new-Random-伪随机，不是密码学安全的"><a href="#2-new-Random-伪随机，不是密码学安全的" class="headerlink" title="2 new Random 伪随机，不是密码学安全的"></a>2 new Random 伪随机，<strong>不是密码学安全的</strong></h1><ul><li>加密相关的推荐使用** SecureRandom**<ul><li><strong>慎用</strong>SecureRandom.getInstanceStrong()方式获取 SecureRandom，linux 环境下容易产生阻塞</li><li><strong>推荐</strong>使用 new SecureRandom()获取 SecureRandom，伪随机</li></ul></li><li>Random 使用当前系统时钟来生成种子 seed</li></ul><h1 id="3-sun-下的类不建议使用"><a href="#3-sun-下的类不建议使用" class="headerlink" title="3 sun.*下的类不建议使用"></a>3 sun.*下的类不建议使用</h1><ul><li>是 sun 的 hotspot 虚拟机中的 java.*和 javax.*的实现类</li><li>不是 sun 承诺公开的接口，不具有向后兼容性</li></ul><h1 id="4-Deprecated-不建议使用"><a href="#4-Deprecated-不建议使用" class="headerlink" title="4 @Deprecated 不建议使用"></a>4 @Deprecated 不建议使用</h1><h1 id="5-HttpOnly"><a href="#5-HttpOnly" class="headerlink" title="5 HttpOnly"></a>5 HttpOnly</h1><p>Cookie cookie = new Cookie(“myCookieName”, value);<br>cookie.setHttpOnly(true); // Compliant</p><ul><li>XSS</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES</title>
    <link href="/2020/12/14/%E6%95%B0%E6%8D%AE%E5%BA%93/es/ES/"/>
    <url>/2020/12/14/%E6%95%B0%E6%8D%AE%E5%BA%93/es/ES/</url>
    
    <content type="html"><![CDATA[<p>ElasticSearch</p><ul><li>作用<ul><li>全文搜索引擎</li></ul></li><li>本质<ul><li>分布式数据库</li><li>底层是 java 开源库 Lucene，Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。<ul><li>我们没法直接用 Lucene，必须自己写代码去调用它的接口</li></ul></li></ul></li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fj_uqEjv1jx865kzAL2aPx8lhzA3.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>es</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2020/12/13/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-1/"/>
    <url>/2020/12/13/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fv-moUPC3HGNIgx5fh8ypG8HrOaW.jpeg"></p><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h1><p>Redis (Remote Dictionary Server) 是一个使用  C 语言   编写的，开源的  (BSD 许可)  高性能   非关系型  (NoSQL)  的   键值对数据库。</p><hr><h1 id="2-Redis-优缺点"><a href="#2-Redis-优缺点" class="headerlink" title="2 Redis 优缺点"></a>2 Redis 优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>读写性能优异， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。</li><li>支持数据持久化，支持 AOF 和 RDB 两种持久化方式。</li><li>支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>数据库 容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 系统的可用性。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><hr><h1 id="3-什么情况下考虑使用-redis"><a href="#3-什么情况下考虑使用-redis" class="headerlink" title="3 什么情况下考虑使用 redis"></a>3 什么情况下考虑使用 redis</h1><p>使用 redis 前先思考下以下三个问题：</p><ol><li>业务数据常用吗？命中率如何？ 如果命中率很低，就没有必要写入缓存；</li><li>该业务数据是读操作多，还是写操作多？ 如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li><li>业务数据大小如何？ 如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li></ol><hr><h1 id="4-快"><a href="#4-快" class="headerlink" title="4 快"></a>4 快</h1><ol><li><strong>纯内存</strong>操作：<ol><li>读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)</li></ol></li><li><strong>单线程</strong>，无锁竞争：<ol><li>这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li></ol></li><li><strong>多路 I/O 复用模型</strong>，非阻塞 I/O：<ol><li>采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li></ol></li><li><strong>高效的数据结构</strong>，加上底层做了大量优化：<ol><li>Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li></ol></li></ol><ul><li>redis 性能查看：</li></ul><p><code>redis-benchmark -n 100000 -q</code><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqXSarKPYq6YHcC61srRMsleGpK2.png"></p><hr><h1 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h1><p>原子操作。Redis 会将整个脚本作为一个整体执行，中间不会被其他请求插入。</p><hr>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>时区</title>
    <link href="/2020/12/07/java%E5%9F%BA%E7%A1%80/%E6%97%B6%E5%8C%BA/"/>
    <url>/2020/12/07/java%E5%9F%BA%E7%A1%80/%E6%97%B6%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FrcSttoPI-C-WFm89vGlxHeWiCxa.png"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译与反编译</title>
    <link href="/2020/12/01/java%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <url>/2020/12/01/java%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==%E2%88%A3=2247485689&idx=2&sn=d46da5ee31d9e810faea5b5620b10273&chksm=cef5fb4ff982725996b0350cd7e43d0a05c74b1b0c95af05107dab6f42b648c80b337b65155f&scene=21#wechat_redirect">链接</a></p><h1 id="1-计算机语言分类"><a href="#1-计算机语言分类" class="headerlink" title="1 计算机语言分类"></a>1 计算机语言分类</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtnEFjDM_4x8LAoEgJ7lC7I_WLc-.webp"></p><h2 id="1-1-低级语言"><a href="#1-1-低级语言" class="headerlink" title="1.1 低级语言"></a>1.1 低级语言</h2><p>机器语言和汇编语言，二者是几乎很少或者完全没有做任何语法抽象的，这种语言我们通常称之为低级语言，这种更加接近硬件，而且是不可以在不同硬件间移植的。</p><h3 id="1-1-1-机器语言"><a href="#1-1-1-机器语言" class="headerlink" title="1.1.1 机器语言"></a>1.1.1 机器语言</h3><ul><li>二进制代码表示</li><li>可以直接被计算机识别和执行，比较高效</li><li>不同型号的计算机其机器语言是不相通的，可移植性差</li></ul><h3 id="1-1-2-汇编语言"><a href="#1-1-2-汇编语言" class="headerlink" title="1.1.2 汇编语言"></a>1.1.2 汇编语言</h3><ul><li>使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作<ul><li>助记符（mnemonic）是便于人们记忆、并能描述指令功能和指令操作数的符号</li></ul></li><li>计算机并不认识汇编语言，需要先将汇编程序转换成可执行的机器语言（汇编过程）</li><li>较高级语言来说更接近机器语言，运行速度更快，占用更小内存</li></ul><h2 id="1-3-高级语言"><a href="#1-3-高级语言" class="headerlink" title="1.3 高级语言"></a>1.3 高级语言</h2><ul><li>高级语言接近算法语言，易学、易掌握</li><li>高级语言为程序员提供了结构化程序设计的环境和工具，使得设计出来的程序可读性好，可维护性强，可靠性高。</li><li>高级语言远离机器语言，与具体的计算机硬件关系不大，因而所写出来的程序可移植性好，重用率高。</li></ul><hr><h1 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h1><p>高级语言编译为低级语言</p><h2 id="2-1-JAVA-语言的编译"><a href="#2-1-JAVA-语言的编译" class="headerlink" title="2.1 JAVA 语言的编译"></a>2.1 JAVA 语言的编译</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvBfySvCW6-3EG9KS7V7kBSgGhwe.webp"></p><ul><li><strong>前端编译器</strong>（主要是<strong>javac</strong>， Eclipse JDT 中的增量式编译器 ECJ 等。）<ul><li>将 java 文件编译成中间代码，（.class 文件，字节码文件）<ul><li>javac 时会[解语法糖](<a href="https://www.yuque.com/docs/share/4f2075e7-c925-480e-8628-a34deafa2697#">https://www.yuque.com/docs/share/4f2075e7-c925-480e-8628-a34deafa2697?#</a> 《语法糖》)。</li></ul></li></ul></li><li><strong>后端编译器</strong>（<strong>JVM 实现</strong>，如 HotSpot 中的 JIT 编译器）<ul><li>将字节码文件，编译成机器语言。</li></ul></li></ul><hr><h1 id="3-反编译"><a href="#3-反编译" class="headerlink" title="3 反编译"></a>3 反编译</h1><p>低级语言反编译为高级语言</p><ul><li><p>我们说 Java 的反编译，一般是将 class 文件转换成 java 文件</p><ul><li>很难将机器语言反编译成源代码</li><li>可以把中间代码反编译为源代码</li></ul></li><li><p>如何防止反编译</p><ul><li><p>隔离 Java 程序，让用户接触不到你的 Class 文件</p></li><li><p>对 Class 文件进行加密，提到破解难度</p></li><li><p>代码混淆，将代码转换成功能上等价，但是难于阅读和理解的形式</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>语法糖</title>
    <link href="/2020/12/01/java%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2020/12/01/java%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==%E2%88%A3=2650123905&idx=1&sn=d524d74e28c1f29ab9123bea1b50a542&chksm=f36bb3a0c41c3ab610c201b9eeb271494203f7281bb4434b24e7da62bd3f871afc000a5f3ac4&scene=21#wechat_redirect">链接</a></p><h1 id="1-什么是语法糖"><a href="#1-什么是语法糖" class="headerlink" title="1 什么是语法糖"></a>1 什么是语法糖</h1><p>语法糖（Syntactic Sugar）指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p><ul><li>Java 虚拟机并不支持语法糖（javac 属于 jdk，不在 jre 中）</li><li>解语法糖：语法糖在编译阶段就会被还原成简单的基础语法结构<ul><li>com.sun.tools.javac.main.JavaCompiler 中的 compile()中有一个步骤就是调用 desugar()，这个方法负责解语法糖</li></ul></li></ul><hr><h1 id="2-JAVA-语法糖"><a href="#2-JAVA-语法糖" class="headerlink" title="2 JAVA 语法糖"></a>2 JAVA 语法糖</h1><h2 id="2-1-switch-支持-String"><a href="#2-1-switch-支持-String" class="headerlink" title="2.1 switch 支持 String"></a>2.1 switch 支持 String</h2><ul><li>Java7 引入</li></ul><hr><h2 id="2-2-泛型"><a href="#2-2-泛型" class="headerlink" title="2.2 泛型"></a>2.2 泛型</h2><hr><h2 id="2-3-自动装箱与拆箱"><a href="#2-3-自动装箱与拆箱" class="headerlink" title="2.3 自动装箱与拆箱"></a>2.3 自动装箱与拆箱</h2><hr><h2 id="2-4-方法边长参数"><a href="#2-4-方法边长参数" class="headerlink" title="2.4 方法边长参数"></a>2.4 方法边长参数</h2><ul><li>JDK1.5 引入</li></ul><hr><h2 id="2-5-枚举"><a href="#2-5-枚举" class="headerlink" title="2.5 枚举"></a>2.5 枚举</h2><ul><li>JDK1.5 引入</li></ul><hr><h2 id="2-6-内部类"><a href="#2-6-内部类" class="headerlink" title="2.6 内部类"></a>2.6 内部类</h2><hr><h2 id="2-7-条件编译"><a href="#2-7-条件编译" class="headerlink" title="2.7 条件编译"></a>2.7 条件编译</h2><hr><h2 id="2-8-断言"><a href="#2-8-断言" class="headerlink" title="2.8 断言"></a>2.8 断言</h2><ul><li>JDK1.4 引入</li><li>断言的底层实现就是 if 语句，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。</li></ul><hr><h2 id="2-9-数值字面量"><a href="#2-9-数值字面量" class="headerlink" title="2.9 数值字面量"></a>2.9 数值字面量</h2><ul><li>JDK1.7 引入</li></ul><hr><h2 id="2-10-for-each"><a href="#2-10-for-each" class="headerlink" title="2.10 for-each"></a>2.10 for-each</h2><ul><li>本质是普通的 for 循环（非集合类型）和迭代器（集合类型）</li></ul><hr><h2 id="2-11-try-with-resources"><a href="#2-11-try-with-resources" class="headerlink" title="2.11 try-with-resources"></a>2.11 try-with-resources</h2><ul><li>JDK1.7 引入</li><li>编译器帮我们关闭资源</li></ul><hr><h2 id="2-12-lambda-表达式"><a href="#2-12-lambda-表达式" class="headerlink" title="2.12 lambda 表达式"></a>2.12 lambda 表达式</h2><ul><li>JDK1.8 引入</li><li>lambda 表达式的实现其实是依赖了一些 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式</li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MD5为什么是不安全的</title>
    <link href="/2020/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/MD5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84/"/>
    <url>/2020/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/MD5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-原因"><a href="#1-原因" class="headerlink" title="1 原因"></a>1 原因</h1><p>摘要 = hash_MD5(明文)<br>因为 hash_MD5 算法是固定的，所以同一个明文计算出来的摘要是固定的，所以可以采用如下的方式进行破解：</p><h1 id="2-破解方式"><a href="#2-破解方式" class="headerlink" title="2 破解方式"></a>2 破解方式</h1><ul><li><strong>暴力枚举法：</strong>简单粗暴地枚举出所有原文，并计算出它们的哈希值，看看哪个哈希值和给定的信息摘要一致。<ul><li>时间成本高：14 位字母和数字的组合密码，共有(26<em>2+10)^14 = 1.24</em>10^25 种可能（每秒 10 亿次 * 4 亿年）</li></ul></li><li><strong>字典法：</strong>黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值。每次从字典用摘要查找明文<ul><li>空间成本高：14 位字母和数字的组合密码，生成的密码 32 位哈希串的对照表将占用 5.7×10^14 TB 的空间</li></ul></li><li><strong>彩虹表（</strong>rainbow<strong>）法：</strong>在字典法的基础上改进，以时间换空间。是现在破解哈希常用的办法。<ul><li>“加盐”防御：在密码的特定位置插入特定的字符串，这个特定字符串就是“盐（Salt）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2020/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fqn_s1wiin08UVwMJkVA_9oq1TcS.jpeg"></p><ul><li><p>主要有两组实体对象</p><ul><li><p>Observer 观察者</p><p>-</p></li><li><p>被观察者</p><ul><li>OberverList：存储着已注册的观察者，当事件发生时，会通知列表中的所有观察者</li></ul></li></ul></li></ul><hr><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h1><h2 id="2-1-抽象类-接口"><a href="#2-1-抽象类-接口" class="headerlink" title="2.1 抽象类/接口"></a>2.1 抽象类/接口</h2><ul><li>观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>被观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observerList.add(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detachObserver</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        observerList.remove(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer observer: observerList)&#123;<br>            observer.update();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-实现类"><a href="#2-2-实现类" class="headerlink" title="2.2 实现类"></a>2.2 实现类</h2><ul><li>观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//怪物</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>    <span class="hljs-comment">//事件触发的回调方法，包含了具体观察者对事件的不同反应</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(inRange())&#123;<br>            System.out.println(<span class="hljs-string">&quot;怪物 对主角攻击！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inRange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//判断主角是否在自己的影响范围内，这里忽略细节，直接返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>被观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;主角向前移动&quot;</span>);<br>        notifyObservers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-调用"><a href="#2-3-调用" class="headerlink" title="2.3 调用"></a>2.3 调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化对象</span><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">hero</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        <span class="hljs-type">Monster</span> <span class="hljs-variable">monster</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Monster</span>();<br>        <span class="hljs-type">Trap</span> <span class="hljs-variable">trap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trap</span>();<br>        <span class="hljs-type">Treasure</span> <span class="hljs-variable">treasure</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Treasure</span>();<br>        <span class="hljs-comment">//注册观察者</span><br>        hero.attachObserver(monster);<br>        hero.attachObserver(trap);<br>        hero.attachObserver(treasure);<br>        <span class="hljs-comment">//移动事件</span><br>        hero.move();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h1><h1 id="3-1-spring-event"><a href="#3-1-spring-event" class="headerlink" title="3.1 spring event"></a>3.1 spring event</h1><p><a href="https://www.cnblogs.com/dubhlinn/p/10725636.html">https://www.cnblogs.com/dubhlinn/p/10725636.html</a></p><ul><li>观察者<ul><li>Listener</li></ul></li><li>被观察者<ul><li>event</li></ul></li><li>通知观察者（main 方法？）<ul><li>publisher</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密算法/摘要算法与应用</title>
    <link href="/2020/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95!%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2020/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95!%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-加密算法"><a href="#1-加密算法" class="headerlink" title="1 加密算法"></a>1 加密算法</h1><h2 id="1-1-对称加密算法"><a href="#1-1-对称加密算法" class="headerlink" title="1.1 对称加密算法"></a>1.1 对称加密算法</h2><ul><li>使用一个秘钥进行加解密。对一段明文加密，加密之后也只能用这个密钥来解密得到明文</li></ul><h3 id="1-1-1-实现"><a href="#1-1-1-实现" class="headerlink" title="1.1.1 实现"></a>1.1.1 实现</h3><ul><li>DES<ul><li>分组数据加密技术（先将数据分成固定长度的小数据块，之后进行加密）</li><li>速度较快，适用于大量数据加密</li><li>密钥的长度 64 位，8 个字节。</li></ul></li><li>3DES<ul><li>基于 DES</li><li>使用 3 个不同密匙对同一个分组数据块进行 3 次加密</li><li>密文强度较 DES 更高。</li></ul></li><li>AES<ul><li>相较于 DES 和 3DES 算法而言，有着更高的速度和资源使用效率，安全级别也较之更高。</li><li>被称为下一代加密标准</li><li>密钥的长度可以为 128、192 和 256 位，也就是 16 个字节、24 个字节和 32 个字节</li></ul></li></ul><hr><h2 id="1-2-非对称加密算法"><a href="#1-2-非对称加密算法" class="headerlink" title="1.2 非对称加密算法"></a>1.2 非对称加密算法</h2><ul><li>使用一对秘钥（公钥 + 私钥）<ul><li><strong>加密信息</strong>：只有自己有私钥，确保加密信息无他人能解密<ul><li>公钥加密，私钥解密。</li></ul></li><li><strong>数字签名</strong>：只有自己有私钥，确保签名信息无他人能生成<ul><li>私钥加密，公钥解密</li></ul></li></ul></li></ul><h3 id="1-2-1-实现"><a href="#1-2-1-实现" class="headerlink" title="1.2.1 实现"></a>1.2.1 实现</h3><ul><li>RSA</li><li>DSA</li><li>ECC</li></ul><hr><h2 id="1-3-摘要算法"><a href="#1-3-摘要算法" class="headerlink" title="1.3 摘要算法"></a>1.3 摘要算法</h2><ul><li>只生成一串不可逆的密文。相同的生成算法对于同一明文只会生成唯一的密文</li></ul><h3 id="1-3-1-实现"><a href="#1-3-1-实现" class="headerlink" title="1.3.1 实现"></a>1.3.1 实现</h3><ul><li>MD5</li><li>SHA1</li><li>HMAC（Hash-based Message Authentication Code）密钥相关的哈希运算消息认证码<ul><li>做摘要时需要秘钥 key：digest = hash(msg, key)</li><li>所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC</li><li>使用 SHA-1、SHA-224、SHA-256 所构造的 HMAC，分别称为 HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-256</li></ul></li><li>Bcrypt</li></ul><hr><h1 id="2-应用"><a href="#2-应用" class="headerlink" title="2 应用"></a>2 应用</h1><h2 id="2-1-数字签名"><a href="#2-1-数字签名" class="headerlink" title="2.1 数字签名"></a>2.1 数字签名</h2><ul><li>作用：<ul><li>保证发送方的身份不可抵赖（用你的公钥打开，所以是你发出来的）</li><li>保证数据在传输过程中不会被篡改</li></ul></li><li>流程：<ul><li>发送方用 hash 算法对明文做摘要，然后利用自己的私钥对形成的摘要进行加密，得到数字签名。</li><li>接受方使用发送方的公钥解密数字签名得到结果 D’，然后对明文也进行 hash 操作产生摘要 D.最后,把 D 和 D’作比较</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtkhrbGhImp-QpBMTGaNZi5SEO7t.jpeg"></p><hr><h2 id="2-2-数字信封"><a href="#2-2-数字信封" class="headerlink" title="2.2 数字信封"></a>2.2 数字信封</h2><ul><li><strong>作用：</strong><ul><li>解决了对称密钥的发布安全问题（传递的秘钥用公钥加密）</li><li>解决了公钥加密速度慢的问题（不直接用公钥对明文加密）</li></ul></li><li><strong>缺陷：</strong><ul><li>接收方 无法保证获取的消息是 发送方 发的</li></ul></li><li><strong>流程：</strong>对称加密技术加密明文,然后用非对称加密技术加密对称密钥。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqwywMqvsWns59rBTdxpnhIyV5GT.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS</title>
    <link href="/2020/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/HTTPS/"/>
    <url>/2020/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是-HTTPS"><a href="#1-什么是-HTTPS" class="headerlink" title="1 什么是 HTTPS"></a>1 什么是 HTTPS</h1><p><code>**HTTPS = HTTP + SSL/TLS**</code><br>1994 年网景公司提出了 HTTPS（HyperText Transfer Protocol Secure）超文本传输安全协议，数据通信仍然是 HTTP，但利用<strong>SSL/TLS 加密数据包</strong>。</p><hr><h1 id="2-为什么需要-HTTPS"><a href="#2-为什么需要-HTTPS" class="headerlink" title="2 为什么需要 HTTPS"></a>2 为什么需要 HTTPS</h1><p>近几年来，各大公司都在大力推进 HTTPS 的建设。Chrome 将非 HTTPS 的网站标注为「不安全」；苹果要求 APP 中需要使用 HTTPS 进行通信；微信小程序也要求使用 HTTPS 协议。<br>HTTP 有一个致命的缺陷：<strong>明文传输。</strong>明文数据会经过 WiFi、路由器、运营商等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，该攻击手法为 MITM（Man In The Middle）<strong>中间人</strong>攻击。<br>如：<strong>运营商劫持</strong>：<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Flc4Xlq1HTpbPP6Cp5y2M55IV6ri.png"></p><hr><h1 id="3-HTTPS-实现原理"><a href="#3-HTTPS-实现原理" class="headerlink" title="3 HTTPS 实现原理"></a>3 HTTPS 实现原理</h1><h2 id="3-1-SSL-TLS"><a href="#3-1-SSL-TLS" class="headerlink" title="3.1 SSL/TLS"></a>3.1 SSL/TLS</h2><p>SSL 和 TLS 其实是一套东西。</p><ul><li><strong>SSL</strong>（Secure Sockets Layer）安全套接层：<ul><li>网景公司在 1994 年提出 HTTPS 协议时，使用的是 SSL 进行加密</li></ul></li><li><strong>TLS</strong>（Transport Layer Security）传输层安全协议<ul><li>后来 IETF（Internet Engineering Task Force）互联网工程任务组将 SSL 进一步<strong>标准化</strong>，于 1999 年公布第一版 TLS 协议文件 TLS 1.0</li></ul></li></ul><hr><h2 id="3-2-HTTPS-的加解密流程"><a href="#3-2-HTTPS-的加解密流程" class="headerlink" title="3.2 HTTPS 的加解密流程"></a>3.2 HTTPS 的加解密流程</h2><h3 id="3-2-1-流程"><a href="#3-2-1-流程" class="headerlink" title="3.2.1 流程"></a>3.2.1 流程</h3><ol><li><strong>证书校验（</strong>以此确保收到的公钥是服务端传来的<strong>）：</strong><ol><li>用户在浏览器<strong>发起 HTTPS 请求</strong><a href="https://www.mogu.com/"></a>，默认使用服务端的 443 端口进行连接</li><li>服务端收到请求，<strong>返回配置好的 CA 证书</strong>给客户端（HTTPS 需要使用一套 CA 证书,证书附带一个<strong>公钥</strong>，而与之对应的<strong>私钥</strong>保留在服务端不公开）</li><li>客户端<strong>收到 CA 证书</strong>，<strong>校验其合法性</strong>（主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效），如果不通过，则显示 HTTPS 警告信息；</li></ol></li><li><strong>传输对称加密秘钥</strong>（依赖于非对称加密保证秘钥安全）：<ol><li>客户端生成一个用于对称加密的<strong>随机 Key</strong>，并用证书内的<strong>公钥 Pub 进行加密</strong>，发送给服务端；</li><li>服务端<strong>收到随机 Key 的密文</strong>，使用与公钥匹配的<strong>私钥进行解密</strong>，得到随机 Key 的明文；</li></ol></li><li><strong>传输 http 数据密文</strong>（依赖对称加密保证数据安全）<ol><li>服务端使用客户端发送过来的随机 Key 对要传输的 HTTP 数据进行<strong>对称加密</strong>，将<strong>密文返回</strong>客户端；</li><li>客户端使用随机 Key<strong>对称解密密文</strong>，得到 HTTP 数据明文；</li><li>后续 HTTPS 请求使用之前交换好的随机 Key 进行对称加解密。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FjxHUeX7bMJFMx1JaXs3GKfu9qgR.png"></p><h3 id="3-2-2-必要性-对称与非对称加密配合使用（数字信封）"><a href="#3-2-2-必要性-对称与非对称加密配合使用（数字信封）" class="headerlink" title="3.2.2 必要性-对称与非对称加密配合使用（数字信封）"></a>3.2.2 必要性-对称与非对称加密配合使用（数字信封）</h3><p><code>数字信封技术：``对称加密技术加密明文,然后用非对称加密技术加密对称密钥</code></p><ul><li><strong>若只使用 非对称加密</strong><ul><li>传递公钥后只能保证一方能安全传输信息</li></ul></li><li><strong>若只使用 对称加密</strong><ul><li>密钥在互联网上传输无法保证安全，那么用该秘钥加密的数据其安全也无法保证</li></ul></li><li><strong>若使用 非对称加密 + 非对称加密</strong><ul><li>非对称加解密耗时要远大于对称加解密</li></ul></li></ul><h3 id="3-3-3-必要性-CA-认证"><a href="#3-3-3-必要性-CA-认证" class="headerlink" title="3.3.3 必要性-CA 认证"></a>3.3.3 必要性-CA 认证</h3><ul><li>若无 CA，中间人可以得到对称加密秘钥，而服务端和客户端毫无感知也就是说，客户端无法确认收到的公钥是不是真的是服务端发来的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvMgc0D3WNH_fNqNoSi69ddk9O0C.png"></p><ul><li>CA 证书（参考<a href="https://mp.weixin.qq.com/s/21JaXwdfSjItj5SgOwhapg">https://mp.weixin.qq.com/s/21JaXwdfSjItj5SgOwhapg</a>）<ul><li>服务端在使用 HTTPS 前，去经过认证的 CA 机构申请颁发一份<strong>数字证书</strong>，数字证书里包含有 证书持有者、证书有效期、公钥等信息，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。</li><li>为防止中间人只修改证书的公钥，需对证书进行<strong>数字签名**<strong>（</strong>CA 机构拥有自己的一对公钥和私钥</strong>）**</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2020/10/30/java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/10/30/java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsySpWqgEjovB6YMAFKuyNDSyf_Z.png"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cache</title>
    <link href="/2020/10/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Cache/"/>
    <url>/2020/10/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1 CPU"></a>1 CPU</h1><h2 id="1-1-多核-CPU"><a href="#1-1-多核-CPU" class="headerlink" title="1.1 多核 CPU"></a>1.1 多核 CPU</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmtKvt9_awSEAa0ae-NYRiBvFlV7.png"></p><h2 id="1-2-超线程"><a href="#1-2-超线程" class="headerlink" title="1.2 超线程"></a>1.2 超线程</h2><p>一个核中有多套<strong>PC</strong>和<strong>Register</strong>，他们公用一个<strong>ALU</strong>，这样一个核可以处理多个线程，<br>如四核八线程就由此而来</p><hr><h1 id="2-CacheLine"><a href="#2-CacheLine" class="headerlink" title="2 CacheLine"></a>2 CacheLine</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhVdd1xMEq94rzlX2psOg8Jc4ao2.png"></p><h2 id="2-1-volatile-可见性"><a href="#2-1-volatile-可见性" class="headerlink" title="2.1 volatile 可见性"></a>2.1 volatile 可见性</h2><ol><li>x 被标记了 volatile</li><li>两个线程运算时先将主内存中 x 所在的整条 CacheLine 复制到线程自己的<strong>工作内存</strong>，运算之后写回<strong>主内存</strong></li><li>假设线程 1 修改了 x 并写回，但是线程 2 中的 x 还是未修改的 x</li><li>由于 x 被标记了 volatile，在线程 1 写回 x 缓存时，线程 1 会通知线程 2 重新读取缓存中 x 对应的 CacheLine</li></ol><h2 id="2-2-伪共享"><a href="#2-2-伪共享" class="headerlink" title="2.2 伪共享"></a>2.2 伪共享</h2><ol><li>volatile x、volatile y 在同一个 CacheLine</li><li>如果线程 1 不断修改 x，线程 2 不断修改 y，那么修改的时候线程 1 就要不断通知线程 2 更新 x、线程 2 就要不断通知线程 1 更新 y</li><li>这样的不断通知不断从主内存重新读取 CacheLine 至线程的工作内存很浪费性能</li></ol><h2 id="2-3-CacheLine-对齐"><a href="#2-3-CacheLine-对齐" class="headerlink" title="2.3 CacheLine 对齐"></a>2.3 CacheLine 对齐</h2><p>一般一个 CacheLine 是 64 字节，也就是 8 个 long，我们可以把 x 定义为 long，并同时定义 7 个没有用的 long 变量，这样这 8 个 long 就在同一个 CacheLine 中<br>之后再定义 y，y 自然也就在下一个 CacheLine 中了<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FuR3THX1ofxWxbGeRWNnyhANQ7Pb.png"><br>这样就避免了伪共享的问题。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UID</title>
    <link href="/2020/10/29/java%E5%9F%BA%E7%A1%80/UID/"/>
    <url>/2020/10/29/java%E5%9F%BA%E7%A1%80/UID/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Twitter-snowflake"><a href="#1-Twitter-snowflake" class="headerlink" title="1 Twitter-snowflake"></a>1 Twitter-snowflake</h1><p>snowflake 将 long 的 64 位分为了 3 部分，如图：<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmxI7YIky3StXkNIUwkYxATQDzGs.png"><br>其中，时间戳部分的时间单位一般<strong>为毫秒</strong>。也就是说 1 台工作机器 1 毫秒可产生 4096 个 id（2 的 12 次方）。</p><h1 id="2-Baidu-UidGenerator"><a href="#2-Baidu-UidGenerator" class="headerlink" title="2 Baidu-UidGenerator"></a>2 Baidu-UidGenerator</h1><ul><li>源码：（使用说明详见：README.md）<ul><li><a href="https://github.com/baidu/uid-generator">https://github.com/baidu/uid-generator</a></li></ul></li><li>依赖版本：<ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Java8</a>及以上版本</li><li><a href="https://dev.mysql.com/downloads/mysql/">MySQL</a>(内置 WorkerID 分配器, 启动阶段通过 DB 进行分配; 如自定义实现, 则 DB 非必选依赖）</li></ul></li><li>特点<ul><li>UidGenerator 是 Java 实现的, 基于 Twitter 开源的<a href="https://github.com/twitter/snowflake"><strong>Snowflake</strong></a>算法的唯一 ID 生成器</li><li>采用 RingBuffer 来<strong>缓存</strong>已生成的 UID, 并行化 UID 的生产和消费（CachedUidGenerator）</li><li>同时对<strong>CacheLine 补齐</strong>，避免了由 RingBuffer 带来的硬件级「伪共享」问题（CachedUidGenerator）</li><li>单机 QPS(Query Per Second)  可达 600 万</li></ul></li></ul><h2 id="2-1-Long-位数分配"><a href="#2-1-Long-位数分配" class="headerlink" title="2.1 Long 位数分配"></a>2.1 Long 位数分配</h2><p><code>**这些部分的长度可以根据具体需要进行动态的调整，满足总长度为64位即可，下图为默认位数：**</code><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fuw-sk1MrbFu_x8rbpm7EVlaHbk6.webp"></p><ul><li>sign(1bit)：固定 1bit 符号标识，即生成的 UID 为正数。</li><li>delta seconds (28 bits)：当前时间，相对于时间基点”2016-05-20”的增量值，<strong>单位：秒</strong>，最多可支持约 8.7 年</li><li>worker id (22 bits)：机器 id，最多可支持约 420w 次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。</li><li>sequence (13 bits)：每秒下的并发序列，13 bits 可支持每秒 8192 个并发。</li></ul><h2 id="2-2-具体实现"><a href="#2-2-具体实现" class="headerlink" title="2.2 具体实现"></a>2.2 具体实现</h2><h3 id="2-2-1-DefaultUidGenerator"><a href="#2-2-1-DefaultUidGenerator" class="headerlink" title="2.2.1 DefaultUidGenerator"></a>2.2.1 DefaultUidGenerator</h3><ul><li>实现了<em>InitializingBean</em>接口，会在初始化时添加 WorkerNode 至数据库，并返回一个 workerNodeId（可自定义实现：_implements WorkerIdAssigner_）</li><li>nextId 方法主要负责 ID 的生成，这种实现方式很简单，<ul><li>如果毫秒数未发生变化，在序列号加一即可；</li><li>如果毫秒数未发生变化，并且序列号已分配至最大，则等待至下一秒</li><li>毫秒数发生变化，重置 Sequence 为 0;</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">currentSecond</span> <span class="hljs-operator">=</span> getCurrentSecond();<br><br>    <span class="hljs-comment">// Clock moved backwards, refuse to generate uid</span><br>    <span class="hljs-keyword">if</span> (currentSecond &lt; lastSecond) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">refusedSeconds</span> <span class="hljs-operator">=</span> lastSecond - currentSecond;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UidGenerateException</span>(<span class="hljs-string">&quot;Clock moved backwards. Refusing for %d seconds&quot;</span>, refusedSeconds);<br>    &#125;<br><br>    <span class="hljs-comment">// At the same second, increase sequence</span><br>    <span class="hljs-keyword">if</span> (currentSecond == lastSecond) &#123;<br>        sequence = (sequence + <span class="hljs-number">1</span>) &amp; bitsAllocator.getMaxSequence();<br>        <span class="hljs-comment">// Exceed the max sequence, we wait the next second to generate uid</span><br>        <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>            currentSecond = getNextSecond(lastSecond);<br>        &#125;<br><br>        <span class="hljs-comment">// At the different second, sequence restart from zero</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        sequence = <span class="hljs-number">0L</span>;<br>    &#125;<br><br>    lastSecond = currentSecond;<br><br>    <span class="hljs-comment">// Allocate bits for UID</span><br>    <span class="hljs-keyword">return</span> bitsAllocator.allocate(currentSecond - epochSeconds, workerId, sequence);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-CachedUidGenerator"><a href="#2-2-2-CachedUidGenerator" class="headerlink" title="2.2.2 CachedUidGenerator"></a>2.2.2 CachedUidGenerator</h3><ul><li>结构</li></ul><p><img src="https://github.com/baidu/uid-generator/raw/master/doc/ringbuffer.png"></p><ul><li><p>RingBuffer 填充时机</p><ul><li>初始化预填充<br>    RingBuffer 初始化时，预先填充满整个 RingBuffer.</li><li>即时填充<br>    Take 消费时，即时检查剩余可用 slot 量(<code>tail</code> - <code>cursor</code>)，如小于设定阈值，则补全空闲 slots。阈值可通过<code>paddingFactor</code>来进行配置，请参考 Quick Start 中 CachedUidGenerator 配置</li><li>周期填充<br>     通过 Schedule 线程，定时补全空闲 slots。可通过<code>scheduleInterval</code>配置，以应用定时填充功能，并指定 Schedule 时间间隔</li></ul></li><li><p>由于数组元素在内存中是连续分配的，可最大程度利用 CPU cache 以提升性能。但同时会带来「伪共享」FalseSharing 问题，为此在 Tail、Cursor 指针、Flag-RingBuffer 中采用了 CacheLine 补齐方式。</p></li></ul><p><img src="https://github.com/baidu/uid-generator/raw/master/doc/cacheline_padding.png"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APP消息推送</title>
    <link href="/2020/10/22/%E9%A1%B9%E7%9B%AE/APP%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <url>/2020/10/22/%E9%A1%B9%E7%9B%AE/APP%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    
    <content type="html"><![CDATA[<p>真正的 Push 应该是只要一个 Client 设备连接到互联网中，什么也不做等在那里，Server 端随时都可以将数据（消息是数据的一种）发送到这个 Client 上，就好像 Server 等在那里，Client 随时可以访问 Server 一样。</p><pre><code class="hljs">用Server端做个类比，当一个Web Server在互联网上部署好以后，任何一台电脑都可以通过互联网去访问Server：从Server获取数据、向Server提交数据。向Server提交数据实际就是Client Push数据到Server。在这个模式中，Server所做的事情就是等待，等待任意的Client主动来访问它，并且不需要和Client端保持连接。Server是如何做到这点的呢，实际上是通过listen的方式，具体来说是socket的listen，Server端不需要做额外的事情，只要告诉socket，你去listen吧，有Client请求过来就交给对应的程序去完成吧，就这么简单。Client端的Push是否能做到这点呢，我们这里只考虑Client的设备是智能机的情况，主要就是Android、iOS，还有winPhone？大概吧。Android和iOS都是基于linux系统的，有完整的网络协议架构，所以使用socket完全没有问题，winPhone作为一个智能机来说，我想也是没有问题的。所以对于这些智能机来说，让一个socket去listen，等待互联网上的任意一台其他设备来访问是可行的，Server Push数据给Client只需要去连接Client的socket就可以了。事情是这么简单吗？显然不是，不然就不会有各个大小公司跳出来做平台了。ps：首先我们要了解socket是什么，socket是基于tcp/ip协议的一个实现，而tcp/ip是整个互联网的协议基础。关于tcp/ip，socket具体内容不在这里赘述，不了解的可以去查相关资料。Server端和Client端有一个很重要的区别，Server端是有固定的公网ip的，而Client端的ip不是固定的，甚至不一定具有公网ip。Client访问Server时，实际是通过ip找到Server进行访问的（域名？域名最终也是被解析成ip），有固定的公网ip才方便互联网上的其他设备来访问。而反过来Server想找某个Client时，由于Client的ip不固定，Server端是无法找到Client的。所以即使Client这里放了一个socket在listen，Server找不到Client，还是连接不上Client。所以Client是无法使用Server的这种模式去被动接受Push的。是否有办法让Server端知道Client的ip呢，比如每次Client更换ip以后将ip发给Server？这种方法显然是成本高且不可靠的。所以，目前的Push技术实现基本都是Client主动连接Server，钻牛角尖来讲，现在的Push其实都是伪Push。下面简单讲两种方式：</code></pre><p>一、轮询法：</p><pre><code class="hljs">这种方法最简单，Client每过一段时间向Server请求一次数据。优缺点很明显，优点是实现简单；缺点是间隔时间不好控制，并且消耗大（电量、流量）。</code></pre><p>二、长连接法：</p><pre><code class="hljs">还是从socket入手（又是这货？），Client使用socket连接Server，并且保持socket连接，Server随时可以通过这个socket发送数据给Client。优点：最有效，客户端设备消耗比第一种小（设备应该从系统层对socket的长连接做优化，socket链接维护成本从客户端来讲应该是小于频繁的http请求的）；缺点：服务端压力大，每一个设备都需要一个socket连接。还有一些其他协议比如xmpp，其实也逃不过上面两种方式，只是做了一些封装。或者还有一种非互联网方式的做法，比如监听短信法，要push的时候，先发一条手机到目的手机，Client监听到了标的短信，然后向Server请求数据，不过像这类剑走偏锋的方法，限制条件也很多，不是很实用。总结一下，目前各个推送平台的实现都是基于长连接法的，如果App要自己实现推送，也是建议使用这种方式。但是如果每个App都用一个长连接，那么手机也吃不消了，所以又有一些其他技术来实现。</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2020/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/maven/Maven/"/>
    <url>/2020/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/maven/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FnrwUvL28Bbu6LIgTKDj8twmoX68.png"></h1><h1 id="2-maven-访问仓库的顺序"><a href="#2-maven-访问仓库的顺序" class="headerlink" title="2 maven 访问仓库的顺序"></a>2 maven 访问仓库的顺序</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fh3xdml9GgWUhndzBmCKdiLOcsWy.png"></p><h1 id="3-maven-项目目录结构"><a href="#3-maven-项目目录结构" class="headerlink" title="3 maven 项目目录结构"></a>3 maven 项目目录结构</h1><p>约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。<br>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式：</p><ul><li>通过配置的形式明确告诉它</li><li>基于第三方工具或框架的约定</li></ul><p>Maven 对工程目录结构的要求就属于后面的一种。<br>现在 JavaEE 开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而 Maven 正是因为指定了特定文件保存的目录才能够对我们的 Java 工程进行自动化构建。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FnxrUyiJZnLo2sf2by_tAXh8MPxv.jpg"></p><h1 id="4-maven-坐标"><a href="#4-maven-坐标" class="headerlink" title="4 maven 坐标"></a>4 maven 坐标</h1><p>GAV:</p><ul><li>groupid：公司或组织的域名倒序+当前项目名称</li><li>artifactId：当前项目的模块名称</li><li>version：当前模块的版本</li></ul><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>将 gav 三个向量连起来：mysql+mysql-connector-java+5.1.30</li><li>以连起来的字符串作为目录结构到仓库中查找 mysql/mysql-connector-java/5.1.30/mysql-connector-java-5.1.30.jar</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiwXezyn0Dep82UVVFxy_jTX0tEA.png"></p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiwXezyn0Dep82UVVFxy_jTX0tEA.png"></p><h1 id="5-settings-xml-文件详解"><a href="#5-settings-xml-文件详解" class="headerlink" title="5 settings.xml 文件详解"></a>5 settings.xml 文件详解</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 本地仓库的路径。默认值为$&#123;user.home&#125;/.m2/repository。 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>E:/java/apache-maven-3.3.9/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-comment">&lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;interactiveMode&gt;true&lt;/interactiveMode&gt;--&gt;</span><br><br><br> <span class="hljs-comment">&lt;!--表示是否离线，默认是false。这个属性表示在Maven进行项目编译和部署等操作时是否允许Maven进行联网来下载所需要的信息。  --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;offline&gt;false&lt;/offline&gt;</span><br><span class="hljs-comment">  --&gt;</span><br><br><span class="hljs-comment">&lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了org.apache.maven.plugins和org.codehaus.mojo --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- pluginGroup</span><br><span class="hljs-comment">     | Specifies a further group identifier to use for plugin lookup.</span><br><span class="hljs-comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--其下面可以定义一系列的proxy子元素，表示Maven在进行联网时需要使用到的代理。当设置了多个代理的时候第一个标记active为true的代理将会被使用。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">proxies</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--代理元素包含配置代理时需要的信息--&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">proxy</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 代理的唯一定义符，用来区分不同的代理元素。--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>optional<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-comment">&lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">active</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">active</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">protocol</span>&gt;</span>http<span class="hljs-tag">&lt;/<span class="hljs-name">protocol</span>&gt;</span><br><span class="hljs-comment">&lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>proxyuser<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br> <span class="hljs-comment">&lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>proxypass<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。  --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>proxy.host.net<span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。  --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>80<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">nonProxyHosts</span>&gt;</span>local.net|some.host.com<span class="hljs-tag">&lt;/<span class="hljs-name">nonProxyHosts</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">proxy</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">proxies</span>&gt;</span><br><br> <span class="hljs-comment">&lt;!--表示当需要连接到一个私有服务器的时候需要的认证信息 。--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--服务器元素包含配置服务器时需要的信息</span><br><span class="hljs-comment">  发布的服务器,发布的位置在POM中配置，以ID为关联，有很多公用的信息需要配置在POM文件里，最佳实践是定义一个公司级别的root pom -</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frame-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>siteServer<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-comment">&lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是$&#123;user.home&#125;/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">privateKey</span>&gt;</span>/path/to/private/key<span class="hljs-tag">&lt;/<span class="hljs-name">privateKey</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--鉴权时使用的私钥密码。--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">passphrase</span>&gt;</span>optional; leave empty if not used.<span class="hljs-tag">&lt;/<span class="hljs-name">passphrase</span>&gt;</span><br><span class="hljs-comment">&lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filePermissions</span>&gt;</span>664<span class="hljs-tag">&lt;/<span class="hljs-name">filePermissions</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--目录被创建时的权限。 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">directoryPermissions</span>&gt;</span>775<span class="hljs-tag">&lt;/<span class="hljs-name">directoryPermissions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--用于定义一系列的远程仓库的镜像。我们可以在pom中定义一个下载工件的时候所使用的远程仓库。但是有时候这个远程仓库会比较忙，所以这个时候人们就想着给它创建镜像以缓解远程仓库的压力，也就是说会把对远程仓库的请求转换到对其镜像地址的请求。每个远程仓库都会有一个id，这样我们就可以创建自己的mirror来关联到该仓库，那么以后需要从远程仓库下载工件的时候Maven就可以从我们定义好的mirror站点来下载，这可以很好的缓解我们远程仓库的压力。在我们定义的mirror中每个远程仓库都只能有一个mirror与它关联，也就是说你不能同时配置多个mirror的mirrorOf指向同一个repositoryId。--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-comment">&lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>mirrorId<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br> <span class="hljs-comment">&lt;!--　用来表示该mirror是关联的哪一个仓库，其值为其关联仓库的id。当要同时关联多个仓库时，这多个仓库之间可以用逗号隔开；当要关联所有的仓库时，可以使用“*”表示；当要关联除某一个仓库以外的其他所有仓库时，可以表示为“*,!repositoryId”；当要关联不是localhost或用file请求的仓库时，可以表示为“external:*”。--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>repositoryId<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br> <span class="hljs-comment">&lt;!--镜像名称 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用</span><br><span class="hljs-comment">默认的服务器URL。 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://196.160.1.211:8081/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--用于指定一系列的profile。profile元素由activation、repositories、pluginRepositories和properties四个元素组成。当一个profile在settings.xml中是处于活动状态并且在pom.xml中定义了一个相同id的profile时，settings.xml中的profile会覆盖pom.xml中的profile。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--根据环境参数来调整的构件的配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br> <span class="hljs-comment">&lt;!--该配置的唯一标识符。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.4<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-comment">&lt;!--当所有的约束条件都满足的时候就会激活这个profile。--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--当其值为true的时候表示如果没有其他的profile处于激活状态的时候，该profile将自动被激活。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br><span class="hljs-comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。</span><br><span class="hljs-comment"> 这里的版本还可以用一个范围来表示，如</span><br><span class="hljs-comment">&lt;jdk&gt;[1.4,1.7)&lt;/jdk&gt;表示1.4、1.5和1.6满足；</span><br><span class="hljs-comment">&lt;jdk&gt;[1.4,1.7]&lt;/jdk&gt;表示1.4、1.5、1.6和1.7满足；--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br><span class="hljs-comment">&lt;!--表示当操作系统满足条件的时候激活。--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">os</span>&gt;</span><br> <span class="hljs-comment">&lt;!--激活profile的操作系统的名字 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Windows XP<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-comment">&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;)  --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Windows<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br> <span class="hljs-comment">&lt;!--激活profile的操作系统体系结构  --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">arch</span>&gt;</span>x86<span class="hljs-tag">&lt;/<span class="hljs-name">arch</span>&gt;</span><br> <span class="hljs-comment">&lt;!--激活profile的操作系统版本--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.2600<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">os</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--property是键值对的形式，表示当Maven检测到了这样一个键值对的时候就激活该profile。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-comment">&lt;!--这个时候如果要激活该profile的话，可以在调用Maven指令的时候加上参数mavenVersion并指定其值为&gt;2.0.3，如：mvn compile –DmavenVersion=&gt;2.0.3--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mavenVersion<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-comment">&lt;!--激活profile的属性的值 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--表示当文件存在或不存在的时候激活，exists表示存在，missing表示不存在。如下面的例子表示当文件hello/world不存在的时候激活该profile。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span><br> <span class="hljs-comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exists</span>&gt;</span><br> <span class="hljs-comment">&lt;!--如果指定的文件不存在，则激活profile。--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="hljs-tag">&lt;/<span class="hljs-name">missing</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br> <span class="hljs-comment">&lt;!--用于定义远程仓库的，当该profile是激活状态的时候，这里面定义的远程仓库将作为当前pom的远程仓库。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk14<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Repository for JDK 1.4 builds<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.myhost.com/maven/jdk14<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">snapshotPolicy</span>&gt;</span>always<span class="hljs-tag">&lt;/<span class="hljs-name">snapshotPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>env-dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>target-env<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tomcatPath</span>&gt;</span>/path/to/tomcat/instance<span class="hljs-tag">&lt;/<span class="hljs-name">tomcatPath</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexusProfile<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br> <span class="hljs-comment">&lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--远程仓库唯一标识--&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexusProfile<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--远程仓库名称 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--远程仓库URL，按protocol://hostname/path形式</span><br><span class="hljs-comment">  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://196.160.1.211:8081/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--如何处理远程仓库里发布版本的下载--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br><span class="hljs-comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span>always<span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br><br><br>     <span class="hljs-comment">&lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br><br>     <span class="hljs-comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br><br>     <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>centralProfile<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Central Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 虚拟的URL形式,指向镜像的URL,因为所有的镜像都是用的是nexus，这里的central实际上指向的是http://repos.d.xxx.com/nexus/content/groups/public --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br> <span class="hljs-comment">&lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的</span><br><span class="hljs-comment">        profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>nexusProfile<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>centralProfile<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br><br>备注：POM配置<br><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br> <span class="hljs-comment">&lt;!--frame-releases与setting文件的server id 对应 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frame-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>frame-releases<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frame-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>frame Snapshots Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="6-项目打包上传至私服"><a href="#6-项目打包上传至私服" class="headerlink" title="6 项目打包上传至私服"></a>6 项目打包上传至私服</h1><ul><li>pom.xml 文件添加 distributionManagement 节点</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用分发管理将本项目打成jar包，直接上传到指定服务器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--正式版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- nexus服务器中用户名：在settings.xml中&lt;server&gt;的id--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>yang<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这个名称自己定义 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Release repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.1.105:8081/repository/yang/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--快照</span><br><span class="hljs-comment">    &lt;snapshotRepository&gt;</span><br><span class="hljs-comment">        &lt;id&gt;nexus-snapshots&lt;/id&gt;</span><br><span class="hljs-comment">        &lt;name&gt;Snapshots repository&lt;/name&gt;</span><br><span class="hljs-comment">        &lt;url&gt;http://192.168.1.105/repository/yang/&lt;/url&gt;</span><br><span class="hljs-comment">    &lt;/snapshotRepository&gt;--&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>&lt; repository &gt;节点下的&lt; id &gt;对应 setting.xml 文件中的 server 的 id</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--maven连接nexus需要验证用户名和密码--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>yang<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>上传正式版本，pom.xml 文件 version 中不能有 SNAPSHOT，快照版本才有</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.yang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-comment">&lt;!--  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; --&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/2020/09/28/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB/"/>
    <url>/2020/09/28/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本模型"><a href="#1-基本模型" class="headerlink" title="1. 基本模型"></a>1. 基本模型</h1><h2 id="1-1-结构"><a href="#1-1-结构" class="headerlink" title="1.1 结构"></a>1.1 结构</h2><ul><li>database 数据库，与 SQL 的数据库(database)概念相同，一个数据库包含多个集合(表)</li><li>collection 集合，相当于 SQL 中的表(table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema)是动态的，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何 schema 的校验。</li><li>document 文档，相当于 SQL 中的行(row)，一个文档由多个字段(列)组成，并采用 bson(json)格式表示。</li><li>field 字段，相当于 SQL 中的列(column)，相比普通 column 的差别在于 field 的类型可以更加灵活，比如支持嵌套的文档、数组。<br>此外，MongoDB 中字段的类型是固定的、区分大小写、并且文档中的字段也是有序的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkzlQKEl3O8vxDYrEKuW_4lP5GKC.png"></p><h2 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h2><ul><li>_id 主键，MongoDB 默认使用一个_id 字段来保证文档的唯一性。</li><li>reference 引用，勉强可以对应于 外键(foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver)自动进行关联查询、转换的一个特殊类型。</li><li>view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表/集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的(物化视图)。</li><li>index 索引，与 SQL 的索引相同。</li><li>$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能</li><li>transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持</li><li>aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fh6J3UUwu--Q77i5rmpPn1ylMnN8.png"></p><h2 id="1-3-格式"><a href="#1-3-格式" class="headerlink" title="1.3 格式"></a>1.3 格式</h2><ul><li><strong>BSON</strong></li></ul><p>MongoDB 文档可以使用 Javascript 对象表示，从格式上讲，是基于 JSON 的。<br>但是 JSON 也有自己的短板，比如无法支持像日期这样的特定数据类型，因此 MongoDB 实际上使用的是一种扩展式的 JSON，叫 <strong>BSON</strong>(Binary JSON)。<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fm6osILrxRGBL0gEyMW3SIUO28jT.jpeg"></p><h2 id="1-4-分布式-ID"><a href="#1-4-分布式-ID" class="headerlink" title="1.4 分布式 ID"></a>1.4 分布式 ID</h2><p>在单机时代，大多数应用可以使用数据库自增式 ID 来作为主键。 传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment 来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。<br>MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。<br>_id 的生成规则如下：</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fs0cHKKVu8jKEankU1QZlLFrpmjG.png"></p><ul><li>4-byte Unix 时间戳</li><li>3-byte 机器 ID</li><li>2-byte 进程 ID</li><li>3-byte 计数器(初始化随机)</li></ul><p>_id 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。服务端也会检测写入的文档是否包含_id 字段，如果没有就生成一个。</p><hr><h1 id="2-操作语法"><a href="#2-操作语法" class="headerlink" title="2 操作语法"></a>2 操作语法</h1><hr><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3 索引"></a>3 索引</h1><hr><h1 id="4-集群"><a href="#4-集群" class="headerlink" title="4 集群"></a>4 集群</h1><h2 id="4-1-组件"><a href="#4-1-组件" class="headerlink" title="4.1 组件"></a>4.1 组件</h2><p>由于单机垂直扩展能力的局限，水平扩展的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。为了保证数据的高可用，MongoDB 采用副本集的方式来实现数据复制。<br>MongoDB 分片集群(Shard Cluster)：</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fts2ENIKC2nmwt5n92EAmTn_EFHQ.jpeg"></p><ul><li><strong>shard</strong>：分片</li><li><strong>mongos</strong>：查询路由器</li><li><strong>config servers</strong>：配置服务器</li></ul><h3 id="4-1-1-shard"><a href="#4-1-1-shard" class="headerlink" title="4.1.1 shard"></a>4.1.1 shard</h3><ul><li>分片，是 MongoDB 用来将<strong>大型集合分割到不同服务器</strong>（或者说一个集群）上所采用的方法。</li><li>和 MySQL 分区方案相比，MongoDB 的最大区别在于它几乎能<strong>自动完成所有事情</strong>，只要告诉 MongoDB 要分配数据，它就能自动维护数据在<strong>不同服务器之间的均衡</strong>（<strong>chunk 的分裂与迁移</strong>）。</li><li>用于<strong>存储实际的数据块</strong>，实际生产环境中一个 shard server 角色可由几台机器组个一个 replica set 承担，提供了数据冗余和高等级的可靠性，防止主机单点故障。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fjf344dn5aFEzpw-l085FDYi3PeI.png"></p><h3 id="4-1-2-mongos"><a href="#4-1-2-mongos" class="headerlink" title="4.1.2 mongos"></a>4.1.2 mongos</h3><ul><li>查询路由器，提供客户端应用程序和分片集群之间的接口，让整个集群看上去像单一数据库，前端应用可以透明使用。可以部署多个 mongos 路由器。</li><li>mongos 本身没有任何数据，他也不知道该怎么处理这数据，去找 config server</li></ul><h3 id="4-1-3-config-servers"><a href="#4-1-3-config-servers" class="headerlink" title="4.1.3 config servers"></a>4.1.3 config servers</h3><ul><li>配置服务器，<strong>存储集群的元数据和配置设置</strong>。从 MongoDB 3.4 开始，必须将配置服务器部署为 3 成员副本集</li><li>存储所有存、取数据的方式，所有 shard 节点的信息，分片功能的一些配置信息。可以理解为真实数据的元数据。</li></ul><hr><h2 id="4-2-分片策略"><a href="#4-2-分片策略" class="headerlink" title="4.2 分片策略"></a>4.2 分片策略</h2><h3 id="4-2-1-散列分片"><a href="#4-2-1-散列分片" class="headerlink" title="4.2.1 散列分片"></a>4.2.1 散列分片</h3><ul><li>使用散列索引在共享群集中分区数据。散列索引计算<strong>单个字段的哈希值</strong>作为索引值; 此值用作分片键。</li><li>使用散列索引解析查询时，MongoDB 会自动计算哈希值。应用程序也不会需要计算哈希值。</li><li>基于散列值的数据分布有助于更均匀的数据分布，尤其是在分片键单调变化的数据集中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtvRfH_1Rag5S1F_76PLc0vPDiGv.png"></p><h3 id="4-2-2-范围分片"><a href="#4-2-2-范围分片" class="headerlink" title="4.2.2 范围分片"></a>4.2.2 范围分片</h3><ul><li>基于<strong>分片键值</strong>将数据分成范围。然后根据分片键值为每个块分配一个范围。</li><li>mongos 可以将操作仅路由到包含所需数据的分片。</li><li>分片键的规划很重要，可能导致数据不能均匀分布。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FuvfzQSuKpqwSkTvqsGnFf24gCtP.png"></p><hr><h2 id="4-3-复制集选举策略"><a href="#4-3-复制集选举策略" class="headerlink" title="4.3 复制集选举策略"></a>4.3 复制集选举策略</h2><p>复制集通过 replSetInitiate 命令（或 mongo shell 的 rs.initiate()）进行初始化，初始化后各个成员间开始发送心跳消息，并发起 Priamry 选举操作，获得『大多数』成员投票支持的节点，会成为 Primary，其余节点成为 Secondary。<br>『大多数』：假设复制集内投票成员（后续介绍）数量为 N，则大多数为 <strong>N/2 + 1</strong>，当复制集内存活成员数量不足大多数时，整个复制集将无法选举出 Primary，复制集将无法提供写服务，处于只读状态。<br>所以当复制集成员为偶数时，最好加入一个 Arbiter 节点，以提升复制集可用性。</p><hr><h2 id="4-4-shard-chunk"><a href="#4-4-shard-chunk" class="headerlink" title="4.4 shard-chunk"></a>4.4 shard-chunk</h2><h3 id="4-4-1-Chunk-是什么"><a href="#4-4-1-Chunk-是什么" class="headerlink" title="4.4.1 Chunk 是什么"></a>4.4.1 Chunk 是什么</h3><p>在一个 shard server 内部，MongoDB 还是会把数据分为 chunks，每个 chunk 代表这个 shard server 内部一部分数据。</p><ul><li>chunk 有以下两个用途：<ul><li><strong>Splitting</strong>：当一个 chunk 的大小超过配置中的 chunk size 时，MongoDB 的后台进程会把这个 chunk 切分成更小的 chunk，从而避免 chunk 过大的情况</li><li><strong>Balancing</strong>：在 MongoDB 中，balancer 是一个后台进程，负责 chunk 的迁移，从而均衡各个 shard server 的负载，系统初始 1 个 chunk，chunk size 默认值 64M,生产库上选择适合业务的 chunk size 是最好的。mongoDB 会<strong>自动拆分和迁移 chunks</strong>。</li></ul></li></ul><h3 id="4-4-2-Chunksize-的选择"><a href="#4-4-2-Chunksize-的选择" class="headerlink" title="4.4.2 Chunksize 的选择"></a>4.4.2 Chunksize 的选择</h3><ul><li>小的 chunksize：数据均衡是迁移速度快，数据<strong>分布更均匀</strong>。数据分裂<strong>频繁</strong>，路由节点消耗更多资源。</li><li>大的 chunksize：数据分裂少。数据块移动<strong>集中消耗 IO 资源</strong>。通常 100-200M</li></ul><h3 id="4-4-3-Chunk-分裂迁移"><a href="#4-4-3-Chunk-分裂迁移" class="headerlink" title="4.4.3 Chunk 分裂迁移"></a>4.4.3 Chunk 分裂迁移</h3><ul><li>chunk 的分裂和迁移非常消耗 IO 资源；</li><li>只在插入和更新时 chunk 才可能分裂迁移。</li><li>chunk 只会分裂，不会合并，所以即使将 chunkSize 改大，现有的 chunk 数量不会减少，但 chunk 大小会随着写入不断增长，直到达到目标大小。</li><li>过程：<ul><li>chunk 的数据大小超过 chunk size：</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FoCfygewaTMalugBcqqAuX-Vf0nq.png"></p><ul><li>此时各 shard 上的 chunk 数量不平衡，balancer 组件把 chunk 从 chunk 数量最多的 shard 节点挪动到数量最少的节点。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgWM8FdQIRJEQRr9Y9tPPmasBN1E.png"></p><hr><h2 id="4-5-replica-set-复制集"><a href="#4-5-replica-set-复制集" class="headerlink" title="4.5 replica set 复制集"></a>4.5 replica set 复制集</h2><h3 id="4-5-1-简介"><a href="#4-5-1-简介" class="headerlink" title="4.5.1 简介"></a>4.5.1 简介</h3><p>一组复制集就是一组 mongod 实例掌管同一个数据集，实例可以在不同的机器上面。</p><ul><li>实例中包含一个<strong>主导</strong>，接受客户端所有的写入操作，包含了所有的改变操作（写）的日志</li><li>其他都是<strong>副本实例</strong>，从主服务器上获得数据并保持同步。包含有所有的主服务器数据，因此当主服务器挂掉了，就会在副本服务器上重新选取一个成为主服务器。</li><li>每个复制集还有一个<strong>仲裁者</strong>，仲裁者不存储数据，在选取中不能成为主库，只是负责通过心跳包来确认集群中集合的数量，并在主服务器选举的时候作为仲裁决定结果。</li></ul><h3 id="4-5-2-复制集成员说明"><a href="#4-5-2-复制集成员说明" class="headerlink" title="4.5.2 复制集成员说明"></a>4.5.2 复制集成员说明</h3><ul><li>**Secondary **<ul><li>正常情况下，复制集的 Seconary 会参与 Primary 选举（自身也可能会被选为 Primary），并<strong>从 Primary 同步最新写入的数据</strong>，以保证与 Primary 存储相同的数据。</li><li>Secondary<strong>可以提供读服务</strong>，增加 Secondary 节点可以提供复制集的读服务能力，同时提升复制集的可用性。另外，Mongodb 支持对复制集的 Secondary 节点进行灵活的配置，以适应多种场景的需求。</li></ul></li><li><strong>Arbiter</strong><ul><li>Arbiter 节点只参与投票，不能被选为 Primary，并且不从 Primary 同步数据。</li><li>比如你部署了一个 2 个节点的复制集，1 个 Primary，1 个 Secondary，任意节点宕机，复制集将不能提供服务了（无法选出 Primary），这时可以给复制集添加一个 Arbiter 节点，即使有节点宕机，仍能选出 Primary。</li><li>Arbiter 本身不存储数据，是非常轻量级的服务，当复制集成员为偶数时，最好加入一个 Arbiter 节点，以提升复制集可用性。</li></ul></li><li>**Priority0 **<ul><li>Priority0 节点的选举优先级为 0，不会被选举为 Primary</li><li>比如你跨机房 A、B 部署了一个复制集，并且想指定 Primary 必须在 A 机房，这时可以将 B 机房的复制集成员 Priority 设置为 0，这样 Primary 就一定会是 A 机房的成员。（注意：如果这样部署，最好将『大多数』节点部署在 A 机房，否则网络分区时可能无法选出 Primary）</li></ul></li><li><strong>Vote0</strong><ul><li>Mongodb 3.0 里，复制集成员最多 50 个，参与 Primary 选举投票的成员最多 7 个，其他成员（Vote0）的 vote 属性必须设置为 0，即不参与投票。</li></ul></li><li><strong>Hidden</strong><ul><li>Hidden 节点不能被选为主（Priority 为 0），并且对 Driver 不可见。因 Hidden 节点不会接受 Driver 的请求，可使用 Hidden 节点做一些数据备份、离线计算的任务，不会影响复制集的服务。</li></ul></li><li><strong>Delayed</strong><ul><li>Delayed 节点必须是 Hidden 节点，并且其数据落后于 Primary 一段时间（可配置，比如 1 个小时）。</li><li>因 Delayed 节点的数据比 Primary 落后一段时间，当错误或者无效的数据写入 Primary 时，可通过 Delayed 节点的数据来恢复到之前的时间点。</li></ul></li></ul><h3 id="4-5-3-基本架构"><a href="#4-5-3-基本架构" class="headerlink" title="4.5.3 基本架构"></a>4.5.3 基本架构</h3><ul><li><strong>一主两从（三成员都有数据）</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FurMGQqoZissD9BwdGF5vdiyiwtj.png"><br>当主库宕机后,两个从库都会进行竞选，其中一个变为主库，当原主库恢复后，作为从库加入当前的复制集群即可。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqGHV79G1QpWzgbd3KB0GpCREff6.png"></p><ul><li><strong>一主一从一仲裁者（两个有数据）</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgRBvjWXRqyctHG2PICjOoB180Z_.png"><br>当主库宕机时，将会选择从库成为主，主库修复后，将其加入到现有的复制集群中即可。</p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqUSlHSm68iGmtjayaNXFfLahaD9.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL</title>
    <link href="/2020/09/28/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/NoSQL/"/>
    <url>/2020/09/28/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/NoSQL/</url>
    
    <content type="html"><![CDATA[<p>Not Only SQL，非关系型数据库：<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhUiybrMR8r55N0vkDGatqUR1pTQ.jpeg"></p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FnKx1d7xb1mieDPirCjoXFvTRJ_P.png"></h1><h1 id="1-文档数据库"><a href="#1-文档数据库" class="headerlink" title="1 文档数据库"></a>1 文档数据库</h1><p>这些数据库通常将每个键与称为文档的复杂数据结构配对。文档可以包含键数组对、键值对甚至嵌套文档</p><hr><h1 id="2-键值存储"><a href="#2-键值存储" class="headerlink" title="2 键值存储"></a>2 键值存储</h1><p>每个单独的项都存储为键值对。键值存储是所有 NoSQL 数据库中最简单的数据库</p><hr><h1 id="3-列式存储"><a href="#3-列式存储" class="headerlink" title="3 列式存储"></a>3 列式存储</h1><p>这些类型的数据库针对大型数据集上的查询进行了优化，它们将数据列存储在一起，而不是行。</p><hr><h1 id="4-图形存储"><a href="#4-图形存储" class="headerlink" title="4 图形存储"></a>4 图形存储</h1><p>这些存储关于图形、网络的信息，例如社会关系、路线图、交通链接</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security</title>
    <link href="/2020/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Security/"/>
    <url>/2020/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Security/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。SpringSecurity 对 Web 资源的保护是靠<strong>Filter</strong>实现的</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fk0ba_23P7QKgGgG25lO06ikD3tF.png"></h1><ul><li>SecurityContextPersistenceFilter：这个 Filter 是整个拦截过程的入口和出口（也就是第一个和最后一个拦截<br>器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给 SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好<br>的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext；</li><li>UsernamePasswordAuthenticationFilter：用于处理来自表单提交的认证。该表单必须提供对应的用户名密码，内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；</li><li>FilterSecurityInterceptor 是用于保护 web 资源的，使用 AccessDecisionManager 对当前用户进行授权访问，前<br>面已经详细介绍过了；</li><li>ExceptionTranslationFilter 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。</li></ul><h1 id="2-认证"><a href="#2-认证" class="headerlink" title="2 认证"></a>2 认证</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fsjaz6wXG5w6nAGXePMY827AdR2V.png"></p><h2 id="2-1-密码模式"><a href="#2-1-密码模式" class="headerlink" title="2.1 密码模式"></a>2.1 密码模式</h2><h3 id="2-1-1-UsernamePasswordAuthenticationFilter-源码："><a href="#2-1-1-UsernamePasswordAuthenticationFilter-源码：" class="headerlink" title="2.1.1 UsernamePasswordAuthenticationFilter 源码："></a>2.1.1 UsernamePasswordAuthenticationFilter 源码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.web.authentication;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> org.springframework.lang.Nullable;<br><span class="hljs-keyword">import</span> org.springframework.security.authentication.AuthenticationServiceException;<br><span class="hljs-keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;<br><span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<br><span class="hljs-keyword">import</span> org.springframework.security.core.AuthenticationException;<br><span class="hljs-keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;<br><span class="hljs-keyword">import</span> org.springframework.util.Assert;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsernamePasswordAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAuthenticationProcessingFilter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SPRING_SECURITY_FORM_USERNAME_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SPRING_SECURITY_FORM_PASSWORD_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;password&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">usernameParameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">passwordParameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;password&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">postOnly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UsernamePasswordAuthenticationFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Authentication <span class="hljs-title function_">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException &#123;<br>        <span class="hljs-comment">//判断是否是 POST 请求</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthenticationServiceException</span>(<span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 获取请求中的用户，密码。</span><br>        <span class="hljs-comment">// 就是最简单的：request.getParameter(xxx)</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.obtainUsername(request);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.obtainPassword(request);<br>            <span class="hljs-keyword">if</span> (username == <span class="hljs-literal">null</span>) &#123;<br>                username = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (password == <span class="hljs-literal">null</span>) &#123;<br>                password = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br><br>            username = username.trim();<br>            <span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">authRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(username, password);<br>            <span class="hljs-built_in">this</span>.setDetails(request, authRequest);<br>            <span class="hljs-comment">// 将authRequest 塞进 AuthenticationManager并返回</span><br>            <span class="hljs-comment">// 此时的authRequest的权限是没有任何值的。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAuthenticationManager().authenticate(authRequest);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-keyword">return</span> request.getParameter(<span class="hljs-built_in">this</span>.passwordParameter);<br>    &#125;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-keyword">return</span> request.getParameter(<span class="hljs-built_in">this</span>.usernameParameter);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDetails</span><span class="hljs-params">(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest)</span> &#123;<br>        authRequest.setDetails(<span class="hljs-built_in">this</span>.authenticationDetailsSource.buildDetails(request));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsernameParameter</span><span class="hljs-params">(String usernameParameter)</span> &#123;<br>        Assert.hasText(usernameParameter, <span class="hljs-string">&quot;Username parameter must not be empty or null&quot;</span>);<br>        <span class="hljs-built_in">this</span>.usernameParameter = usernameParameter;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPasswordParameter</span><span class="hljs-params">(String passwordParameter)</span> &#123;<br>        Assert.hasText(passwordParameter, <span class="hljs-string">&quot;Password parameter must not be empty or null&quot;</span>);<br>        <span class="hljs-built_in">this</span>.passwordParameter = passwordParameter;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPostOnly</span><span class="hljs-params">(<span class="hljs-type">boolean</span> postOnly)</span> &#123;<br>        <span class="hljs-built_in">this</span>.postOnly = postOnly;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getUsernameParameter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.usernameParameter;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getPasswordParameter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.passwordParameter;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-1-2-UsernamePasswordAuthenticationToken"><a href="#2-1-2-UsernamePasswordAuthenticationToken" class="headerlink" title="2.1.2 UsernamePasswordAuthenticationToken"></a>2.1.2 UsernamePasswordAuthenticationToken</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkQKLbOt6yIhq8Fyk3ZOvRMyog8G.png"></h3><p>Authentication 中包含了用户信息、请求信息等参数。</p><h3 id="2-1-3-AuthenticationManager"><a href="#2-1-3-AuthenticationManager" class="headerlink" title="2.1.3 AuthenticationManager"></a>2.1.3 AuthenticationManager</h3><p>ProviderManager 为 AuthenticationManager 的一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AuthenticationManager</span>, MessageSourceAware, InitializingBean &#123;<br>   ...<br>    <span class="hljs-keyword">public</span> Authentication <span class="hljs-title function_">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException &#123;<br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Authentication</span>&gt; toTest = authentication.getClass();<br>        <span class="hljs-type">AuthenticationException</span> <span class="hljs-variable">lastException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">AuthenticationException</span> <span class="hljs-variable">parentException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Authentication</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Authentication</span> <span class="hljs-variable">parentResult</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">debug</span> <span class="hljs-operator">=</span> logger.isDebugEnabled();<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var8</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getProviders().iterator();<br><br>       <span class="hljs-type">Iterator</span> <span class="hljs-variable">var8</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getProviders().iterator();<br>        <span class="hljs-keyword">while</span>(var8.hasNext()) &#123;<br>            <span class="hljs-type">AuthenticationProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> (AuthenticationProvider)var8.next();<br>            <span class="hljs-comment">// 1.判断是否有provider支持该Authentication</span><br>            <span class="hljs-keyword">if</span> (provider.supports(toTest)) &#123;<br>                <span class="hljs-keyword">if</span> (debug) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Authentication attempt using &quot;</span> + provider.getClass().getName());<br>                &#125;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 2. 真正的逻辑判断</span><br>                    result = provider.authenticate(authentication);<br>                    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-built_in">this</span>.copyDetails(authentication, result);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException | AccountStatusException var13) &#123;<br>                    <span class="hljs-built_in">this</span>.prepareException(var13, authentication);<br>                    <span class="hljs-keyword">throw</span> var13;<br>                &#125; <span class="hljs-keyword">catch</span> (AuthenticationException var14) &#123;<br>                    lastException = var14;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先通过 provider 判断是否支持当前传入进来的<code>Authentication</code>，目前我们使用的是<code>UsernamePasswordAuthenticationToken</code>，因为除了帐号密码登录的方式，还会有其他的方式，比如<code>JwtAuthenticationToken</code>。</p><hr><h1 id="3-授权"><a href="#3-授权" class="headerlink" title="3 授权"></a>3 授权</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><em><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FlnEfUduY6ODer2h80zf5aGWxvPi.png"></em></h1><h1 id="-3"><a href="#-3" class="headerlink" title="_"></a>_</h1><h1 id="-4"><a href="#-4" class="headerlink" title="_"></a>_</h1><h1 id="-5"><a href="#-5" class="headerlink" title="_"></a>_</h1><h1 id="-6"><a href="#-6" class="headerlink" title="_"></a>_</h1><h1 id="-7"><a href="#-7" class="headerlink" title="_"></a>_</h1><h1 id="-8"><a href="#-8" class="headerlink" title="_"></a>_</h1><h1 id="-9"><a href="#-9" class="headerlink" title="_"></a>_</h1><h1 id="-10"><a href="#-10" class="headerlink" title="_"></a>_</h1><h1 id="1-UserDetailsService"><a href="#1-UserDetailsService" class="headerlink" title="_1. UserDetailsService _"></a>_1. UserDetailsService _</h1><p><em>定义用户信息服务（获取所有用户信息）</em></p><hr><h1 id="2-PasswordEncoder"><a href="#2-PasswordEncoder" class="headerlink" title="2. _PasswordEncoder _"></a>2. _PasswordEncoder _</h1><p>_密码编码器 _</p><h2 id="2-1-BCryptPasswordEncoder"><a href="#2-1-BCryptPasswordEncoder" class="headerlink" title="2.1 BCryptPasswordEncoder"></a>2.1 BCryptPasswordEncoder</h2><p>使用 BCrypt 方式加密，这块代码的格式拼接可以查看 gensalt()方法源码<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgvwRNAIOD4MByrasbbzyPJh55si.png"></p><ul><li>$是分割符，无意义；</li><li>2a 是 bcrypt 加密版本号；</li><li>10 是 cost 的值；</li><li>而后的前 22 位是 salt 值；</li><li>再然后的字符串就是密码的密文。</li></ul><h2 id="2-2-NoOpPasswordEncoder"><a href="#2-2-NoOpPasswordEncoder" class="headerlink" title="2.2 NoOpPasswordEncoder"></a>2.2 NoOpPasswordEncoder</h2><hr><h1 id="3-configure"><a href="#3-configure" class="headerlink" title="3. configure"></a><em>3. configure</em></h1><p><em>(WebSecurity web)/configure(HttpSecurity http) 安全拦截机制</em><br>_<br>FilterChainProxy：<br>真正处理认证和授权的：<br>Filter 1        —&gt;AuthenticationManger 认证管理器<br>…<br>Filter n        —&gt;AccessDecisionManager 决策管理器</p>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/09/21/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/git/Git/"/>
    <url>/2020/09/21/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/git/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="1-指令"><a href="#1-指令" class="headerlink" title="1 指令"></a>1 指令</h1><p>–创建分支<br>git branch <name><br>–将 master 分支强制指向 HEAD 的第 3 级父提交。<br>git branch -f master HEAD<del>3<br>–切换到新的分支上<br>git checkout &lt;name/hash 值&gt;;<br>–在<name>分支上提交修改<br>git checkout <name>; –切换到 name 分支上<br>git commit;<br>–合并 name 分支至当前分支<br>git merge <name>;<br>–把当前分支 rebase 至 name 分支<br>git rebase <name>  <br>HEAD-指向你正在其基础上进行工作的提交记录<br>–查看提交记录的哈希值（基于 SHA-1）。<br>git log<br>–相对引用<br>使用 ^ 向上移动 1 个提交记录<br>使用 ~<num> 向上移动多个提交记录，如 ~3<br>ps: git checkout HEAD^^ == git checkout HEAD</del>4<br>–撤销变更<br>git reset C1 –撤回至 C1，在 reset 后， C2 所做的变更还在，但是处于未加入暂存区状态<br>git revert HEAD –提交新的记录，与 HEAD 的前一次记录相同</p><h1 id="2-版本管理实践"><a href="#2-版本管理实践" class="headerlink" title="2 版本管理实践"></a>2 版本管理实践</h1><ul><li><strong>FeatureXXX：</strong><ul><li>具体功能开发分支，从 develop 分支拉，功能开发自测完后合并到 develop 分支。来不及上线的 feature 分支不要合并到 develop。</li></ul></li><li><strong>develop 开发分支：</strong><ul><li>上面代码都是已经开发完的代码（包括已上线和正在测试的）。</li></ul></li><li><strong>Release 分支：</strong><ul><li>测试分支，从 develop 上 fork 进行测试，测试发现问题就在 release 分支上修改，测试通过 release 代码合并到 master 分支发布和 develop 分支（如果有修改）。</li></ul></li><li><strong>master 分支：</strong><ul><li>发布分支，任何时候 master 上代码都是能上线的，可以打 tag。</li></ul></li><li><strong>fix 分支：</strong><ul><li>当上线后发现 bug，在 master 上开一个 fix 分支进行修正，修正完后合并到 master 进行发布，同时 fix 也要合并到 develop，（看情况决定是否合并到当前正在测试的 release 分支）。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JWT</title>
    <link href="/2020/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/JWT/"/>
    <url>/2020/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/JWT/</url>
    
    <content type="html"><![CDATA[<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案</p><ul><li>认证：用户认证就是判断一个用户的身份是否合法的过程</li><li>授权：控制用户访问资源</li></ul><h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h1><ul><li>Base64UrlEncode[<strong>header</strong>]**.<strong>Base64UrlEncode[<strong>payload</strong>]</strong>.**Base64UrlEncode[<strong>signature</strong>]</li><li>decode 后结构：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fud2pnBR6oIos9Mr54YHZgk_Zgg-.png"></p><h2 id="1-1-头部（header"><a href="#1-1-头部（header" class="headerlink" title="1.1 头部（header)"></a>1.1 头部（header)</h2><p>是一个 JSON 对象</p><ul><li>声明类型，这里是 jwt</li><li>声明加密的算法：<ul><li>RS256。非对称算法，易于使用方获取和使用公钥</li><li>HS256。对称算法，必须注意确保密钥不被泄密</li></ul></li></ul><hr><h2 id="1-2-载荷（payload"><a href="#1-2-载荷（payload" class="headerlink" title="1.2 载荷（payload)"></a>1.2 载荷（payload)</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据</p><ul><li>JWT 规定了 7 个官方字段，供选用。<ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></li><li>自定义信息<ul><li>通过 TokenEnhance 实现</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先实现TokenEnhancer接口<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IatTokenEnhancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TokenEnhancer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title function_">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> &#123;<br>        addClaims((DefaultOAuth2AccessToken) accessToken);<br>        <span class="hljs-keyword">return</span> accessToken;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addClaims</span><span class="hljs-params">(DefaultOAuth2AccessToken accessToken)</span> &#123;<br>        <span class="hljs-type">DefaultOAuth2AccessToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> accessToken;<br>        Map&lt;String, Object&gt; additionalInformation = token.getAdditionalInformation();<br>        <span class="hljs-keyword">if</span> (additionalInformation.isEmpty()) &#123;<br>            additionalInformation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, Object&gt;();<br>        &#125;<br>        <span class="hljs-comment">//添加自定义信息-------------------------</span><br>        additionalInformation.put(<span class="hljs-string">&quot;iat&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>((<span class="hljs-type">int</span>)(System.currentTimeMillis()/<span class="hljs-number">1000L</span>)));<br>        additionalInformation.put(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;myTest&quot;</span>);<br>        token.setAdditionalInformation(additionalInformation);<br>    &#125;<br>&#125;<br><br><span class="hljs-number">2.</span>配置Enhancer至令牌增强器<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//pick up all  TokenEnhancers incl. those defined in the application</span><br>        <span class="hljs-comment">//this avoids changes to this class if an application wants to add its own to the chain</span><br>        Collection&lt;TokenEnhancer&gt; tokenEnhancers =<br>            applicationContext.getBeansOfType(TokenEnhancer.class).values();<br>        <span class="hljs-type">TokenEnhancerChain</span> <span class="hljs-variable">tokenEnhancerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenEnhancerChain</span>();<br>        tokenEnhancerChain.setTokenEnhancers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tokenEnhancers));<br>        endpoints<br>            .authenticationManager(authenticationManager)<br>            .tokenStore(tokenStore())<br>            .tokenEnhancer(tokenEnhancerChain)<br>            .reuseRefreshTokens(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><h2 id="1-3-签名（signature"><a href="#1-3-签名（signature" class="headerlink" title="1.3 签名（signature)"></a>1.3 签名（signature)</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。<br>使用 secret，对编码后的 header 和 payload 通过 header 中指定签名算法做数字签名，公式如下：<br><code>header中指定签名算法( ``**base64UrlEncode(header)+&quot;.&quot;+base64UrlEncode(payload)**</code> <code>,``**secret**``)</code></p><ul><li>算法<ul><li>HS256<ul><li>先做摘要 再用 MAC 对称加密算法加密</li></ul></li><li>RS256<ul><li>先做摘要 再用 RSA 非对称加密算法加密</li></ul></li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2020/09/18/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/kafka/Kafka/"/>
    <url>/2020/09/18/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/kafka/Kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="1-构成"><a href="#1-构成" class="headerlink" title="1 构成"></a>1 构成</h1><ul><li>Broker：一台 Kafka 服务器</li><li>topic：即队列</li><li>Partition：topic 的分区，一个 topic 会分为多个 Partition，每个 Partition 负责存储这个 Topic 一部分的数据。<ul><li>主分区：若某个 Broker 挂了，会选举出其他 Broker 的备份分区做主分区。实现<strong>高可用</strong></li><li>备份分区：只做备份，不做读写。</li></ul></li><li>集群的 metadata（kafka 集群的每一台 broker 都缓存了整个集群的 metadata, 当 broker 或某一个 topic 的 metadata 信息发生变化时, 集群的<a href="https://www.jianshu.com/p/a9f559ee6035">Controller</a>                              都会感知到作相应的状态转换, 同时把发生变化的新的 metadata 信息广播到所有的 broker;）<ul><li>所有 broker 信息（包括 ip，port）</li><li>所有 topic 的信息: topic name, partition 数量, 每个 partition 的 leader, isr, replica 集合等</li></ul></li></ul><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Foc4FYlkhlLJH6kqQDn8lQj0inP0.png"></h1><hr><ul><li>offset<ul><li>0.9 版本之前保存在 zookeeper<ul><li>消费者需频繁从 zookeeper 拉取 offset</li></ul></li><li>0.9 版本之后保存在 kafka 本地的某一个 topic</li></ul></li></ul><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2 特点"></a>2 特点</h1><h2 id="2-1-At-least-once"><a href="#2-1-At-least-once" class="headerlink" title="2.1 At least once"></a>2.1 At least once</h2><p>Kafka 采用的是至少一次（At least once）</p><ul><li><strong>消息不会丢</strong></li><li><strong>但是可能会重复消费</strong><ul><li>生产者角度：<ul><li>消息发到 broker，broker 写入消息，broker 返回响应。若返回的响应（可能因为网络原因）生产者没有收到，然后生产者又重发了一次</li></ul></li><li>消费者角度：<ul><li>消费者拿到消息消费完成，更新 consumer offset。若更新 offset 前消费者额挂了，其他消费者又消费了这条消息</li></ul></li></ul></li><li>幂等处理重复消费</li></ul><h2 id="2-2-acks-机制：确保消息写入成功"><a href="#2-2-acks-机制：确保消息写入成功" class="headerlink" title="2.2 acks 机制：确保消息写入成功"></a>2.2 acks 机制：确保消息写入成功</h2><p>生产者中设置：</p><ul><li>**acks=0   **<ul><li>消息发出后就不管了</li></ul></li><li>**acks=1（默认） **<ul><li>只要 Partition Leader 接收到消息而且写入本地磁盘了，就认为成功了</li></ul></li><li>**acks=all  **<ul><li>Partition Leader 接收到消息之后，还必须要求 ISR 列表里跟 Leader 保持同步的那些 Follower 都要把消息同步过去，才能认为这条消息是写入成功了</li><li>当 partition 中只有一个 leader 时，acks=all 也会丢失消息</li></ul></li></ul><h2 id="2-3-多副本冗余的机制"><a href="#2-3-多副本冗余的机制" class="headerlink" title="2.3 多副本冗余的机制"></a>2.3 多副本冗余的机制</h2><pre><code class="hljs">我们数据存在不同的partition上，那kafka就把这些partition做备份。比如，现在我们有三个partition，分别存在三台broker上。每个partition都会备份，这些备份散落在不同的broker上。</code></pre><h2 id="2-4-多副本数据同步"><a href="#2-4-多副本数据同步" class="headerlink" title="2.4 多副本数据同步"></a>2.4 多副本数据同步</h2><p>只有 Partition Leader 是对外提供读写服务的,也就是说，如果有一个客户端往一个 Partition 写入数据，此时一般就是写入这个 Partition 的 Leader 副本。<br>然后 Leader 副本接收到数据之后，Follower 副本会不停的给他发送请求尝试去拉取最新的数据，拉取到自己本地后，写入磁盘中。</p><h2 id="2-5-快"><a href="#2-5-快" class="headerlink" title="2.5 快"></a>2.5 快</h2><ul><li><strong>顺序读写：</strong>Kafka 采取顺序写入磁盘的方式，避免了随机磁盘寻址的浪费</li><li><strong>零拷贝：</strong>减少内核之间的切换<ul><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqVtxs0MQ6Ax9ChbsghT3fsto2te.png"></li></ul></li><li><strong>消息压缩</strong></li><li><strong>分批发送：</strong>Kafka 可以将数据记录分批发送，从生产者到文件系统（Kafka 主题日志）到消费者，可以端到端的查看这些批次的数据。</li></ul><h2 id="2-6-持久化"><a href="#2-6-持久化" class="headerlink" title="2.6 持久化"></a>2.6 持久化</h2><ul><li>Kafka 是将 partition 的数据写在<strong>磁盘的消息日志</strong>，不是 partition 一有数据就立马将数据写到磁盘上，它会先缓存一部分，等到足够多数据量或等待一定的时间再批量写入(<strong>flush</strong>)</li><li>Kafka 只允许<strong>追加写入</strong>(顺序访问)，避免缓慢的随机 I/O 操作。</li></ul><h2 id="2-7-全局有序（特定条件）-分区有序"><a href="#2-7-全局有序（特定条件）-分区有序" class="headerlink" title="2.7 全局有序（特定条件）/分区有序"></a>2.7 全局有序（特定条件）/分区有序</h2><ul><li>全局有序(需特定条件)<ul><li>特定条件：topic 中只有一个 partition（队列）</li></ul></li><li>分区有序<ul><li>在 topic 中有多个 partition 的时候，只能保证 partition 有序</li></ul></li></ul><hr><h1 id="3-消息堆积问题"><a href="#3-消息堆积问题" class="headerlink" title="3 消息堆积问题"></a>3 消息堆积问题</h1><ul><li>原因<ul><li><strong>生产者的生产速度与消费者的消费速度不匹配</strong></li></ul></li><li>解决方案<ul><li>优化代码逻辑<ul><li>一条一条消费改为批量消费（如：数据库插入操作）</li></ul></li><li>水平扩容<ul><li>同时增加 Topic 的 partitions 和 consumer</li></ul></li></ul></li></ul><hr><h1 id="4-场景"><a href="#4-场景" class="headerlink" title="4 场景"></a>4 场景</h1><ul><li>追求<strong>高吞吐量</strong></li><li>对消息的重复没有严格要求</li><li>适合产生<strong>大量数据</strong>的互联网服务的数据收集业务（如日志采集）</li></ul><hr><h1 id="5-配置"><a href="#5-配置" class="headerlink" title="5 配置"></a>5 配置</h1><h2 id="5-1-kafka-服务端配置"><a href="#5-1-kafka-服务端配置" class="headerlink" title="5.1 kafka 服务端配置"></a>5.1 kafka 服务端配置</h2><ul><li>server.properties：</li></ul><p>#The id of the broker. This must be set to a unique integer for each broker.</p><ul><li>broker.id=0</li></ul><h1 id="A-comma-separated-list-of-directories-under-which-to-store-log-files（运行数据-日志存放路径）"><a href="#A-comma-separated-list-of-directories-under-which-to-store-log-files（运行数据-日志存放路径）" class="headerlink" title="A comma separated list of directories under which to store log files（运行数据/日志存放路径）"></a>A comma separated list of directories under which to store log files（运行数据/日志存放路径）</h1><ul><li>log.dirs=/usr/local/var/lib/kafka-logs</li></ul><h1 id="The-minimum-age-of-a-log-file-to-be-eligible-for-deletion-due-to-age"><a href="#The-minimum-age-of-a-log-file-to-be-eligible-for-deletion-due-to-age" class="headerlink" title="The minimum age of a log file to be eligible for deletion due to age"></a>The minimum age of a log file to be eligible for deletion due to age</h1><ul><li>log.retention.hours=168</li></ul><h2 id="5-2-kafka-客户端配置"><a href="#5-2-kafka-客户端配置" class="headerlink" title="5.2 kafka 客户端配置"></a>5.2 kafka 客户端配置</h2><ul><li>拉取时设置的 timeout<ul><li><strong>_@param _</strong><em>timeout The maximum time to block</em></li><li><em>拉取消息时等待的最长时间，若到最长时间还没有消息，就直接返回 空</em></li><li>public ConsumerRecords&lt;K, V&gt; poll(final Duration timeout)</li></ul></li><li>max.poll.interval.ms: 600000<ul><li>最大拉取间隔时间，若超过，则客户端会主动离开 group</li><li>避免“活锁”的情况：客户端持续的发送心跳，但是没有拉取消息处理。为了预防消费者在这种情况下一直持有分 区，我们使用 max.poll.interval.ms 活跃检测机制。</li></ul></li><li>heartbeat.interval.ms<ul><li>间隔多久发送一次心跳</li><li>默认 3s</li></ul></li><li>session.timeout.ms<ul><li>group coordinator 多久没收到心跳 就 rebalance</li><li>默认 10s</li></ul></li></ul><p></p><hr><h1 id="6-Java-API"><a href="#6-Java-API" class="headerlink" title="6 Java API"></a>6 Java API</h1><h2 id="6-1-Producer-端消息发送的基本流程"><a href="#6-1-Producer-端消息发送的基本流程" class="headerlink" title="6.1 Producer 端消息发送的基本流程"></a>6.1 Producer 端消息发送的基本流程</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fjfc3k3xel-XF-jcQ0yChvS2n9mg.png"></p><h3 id="6-1-1-序列化器"><a href="#6-1-1-序列化器" class="headerlink" title="6.1.1 序列化器"></a>6.1.1 序列化器</h3><h3 id="6-1-2-分区器"><a href="#6-1-2-分区器" class="headerlink" title="6.1.2 分区器"></a>6.1.2 分区器</h3><hr><h2 id="6-2-kafkaConsumer–assign-与-subscribe"><a href="#6-2-kafkaConsumer–assign-与-subscribe" class="headerlink" title="6.2 kafkaConsumer–assign 与 subscribe"></a>6.2 kafkaConsumer–assign 与 subscribe</h2><blockquote><p>一般场景建议使用 subscribe（） 函数来实现 partition 的分配。</p></blockquote><ul><li>assign(Collection partitions)<ul><li>为 consumer 手动、显示的指定需要消费的 topic-partitions，不受 group.id 限制，相当与指定的 group 无效（this method does not use the consumer’s group management）</li></ul></li><li>subscribe(Collection<String> topics)<ul><li>为 consumer 自动分配 partition，有内部算法保证 topic-partition 以最优的方式均匀分配给同 group 下的不同 consumer。</li></ul></li></ul><hr><h2 id="6-3-Kafka-Producer-send-阻塞"><a href="#6-3-Kafka-Producer-send-阻塞" class="headerlink" title="6.3 Kafka Producer send 阻塞"></a>6.3 Kafka Producer send 阻塞</h2><p>参考：<a href="https://www.cnblogs.com/objcoding/articles/13662337.html">https://www.cnblogs.com/objcoding/articles/13662337.html</a></p><h3 id="6-3-1-场景-1–Producer-获取不到-metadata-信息："><a href="#6-3-1-场景-1–Producer-获取不到-metadata-信息：" class="headerlink" title="6.3.1 场景 1–Producer 获取不到 metadata 信息："></a>6.3.1 场景 1–Producer 获取不到 metadata 信息：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">2021-06-15 00:00:01,141 WARN  [kafka-producer-network-thread | producer-1] NetworkClient: [Producer <span class="hljs-attribute">clientId</span>=producer-1] <span class="hljs-built_in">Error</span> <span class="hljs-keyword">while</span> fetching metadata with correlation id 48587 : &#123;<span class="hljs-attribute">mainfab_offline_indicator_config_topic</span>=UNKNOWN_TOPIC_OR_PARTITION&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Flt0YB2XiXWqud9exw0mxrljs3Tj.png"></p><h3 id="6-3-2-场景-2–缓冲池内存用完"><a href="#6-3-2-场景-2–缓冲池内存用完" class="headerlink" title="6.3.2 场景 2–缓冲池内存用完"></a>6.3.2 场景 2–缓冲池内存用完</h3><blockquote><p>RecordAccumulator（Kafka Producer 缓冲池核心类）中注释：<br>The accumulator uses a bounded amount of memory and append calls will block when that memory is exhausted, unless this behavior is explicitly disabled.<br>当缓冲池的内存块用完后，消息追加调用将会被阻塞，直到有空闲的内存块。</p></blockquote><ul><li>在新版的 Kafka Producer 中，设计了一个消息缓冲池，客户端发送的消息都会被存储到缓冲池中，同时 Producer 启动后还会开启一个 Sender 线程，不断地从缓冲池获取消息并将其发送到 Broker</li><li>缓冲池大小设置：buffer.memory</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiKrXCEUWgm1s5ZNS8W_PtFVqgKj.png"></p>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JPA</title>
    <link href="/2020/09/16/java%E5%9F%BA%E7%A1%80/JPA/"/>
    <url>/2020/09/16/java%E5%9F%BA%E7%A1%80/JPA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><h2 id="1-1-Hibernate，JPA，Spring-Data-JPA-关系"><a href="#1-1-Hibernate，JPA，Spring-Data-JPA-关系" class="headerlink" title="1.1 Hibernate，JPA，Spring Data JPA 关系"></a>1.1 <strong>Hibernate，JPA，Spring Data JPA 关系</strong></h2><ul><li>JPA 是一套<strong>规范</strong>，内部是由接口和抽象类组成的。</li><li>hibernate 是一套 ORM 框架，而且 Hibernate<strong>实现了 JPA 规范</strong>，所以也可以称 hibernate 为 JPA 的一种实现方式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fsb2t9Ku5ZqMhqWkD7prfpvWcXUW.png"></p><ul><li>Spring Data JPA 是 Spring 提供的一套对 JPA 操作更加高级的封装（编写规范）。Spring Data JPA 和 JPA 一样，虽然定义了持久层的编写规范，但是持久层的具体操作需要由第三方框架来做，它自己并不能做相应的 CRUD 操作。</li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h1><h2 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.hibernate.version</span>&gt;</span>5.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">project.hibernate.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- junit --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- hibernate对jpa的支持包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-entitymanager<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.hibernate.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- c3p0数据库连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.hibernate.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- log日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Mysql and MariaDB --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><hr><h1 id="3-JPA-实现-Hibenate"><a href="#3-JPA-实现-Hibenate" class="headerlink" title="3 JPA 实现-Hibenate"></a>3 JPA 实现-Hibenate</h1><h2 id="3-1-Hibernate-缓存机制"><a href="#3-1-Hibernate-缓存机制" class="headerlink" title="3.1 Hibernate 缓存机制"></a>3.1 Hibernate 缓存机制</h2><h3 id="3-1-1-一级缓存"><a href="#3-1-1-一级缓存" class="headerlink" title="3.1.1 一级缓存"></a>3.1.1 一级缓存</h3><h3 id="3-1-2-二级缓存"><a href="#3-1-2-二级缓存" class="headerlink" title="3.1.2 二级缓存"></a>3.1.2 二级缓存</h3><hr><h1 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Id</span><br><span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="hljs-keyword">private</span> Long id;<br></code></pre></td></tr></table></figure><ul><li><strong>strategy</strong><ul><li>**IDENTITY: **主键由数据库自动生成（主要是自动增长型）（Mysql 支持）</li><li><strong>SEQUENCE：</strong>根据底层数据库的序列来生成主键，条件是数据库支持序列。（oracle 支持）</li><li>AUTO<strong>：</strong>主键由程序控制</li><li>TABLE<strong>：</strong>使用一个特定的数据库表格来保存主键</li></ul></li></ul><hr><h1 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h1>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2020/09/16/java%E5%9F%BA%E7%A1%80/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2020/09/16/java%E5%9F%BA%E7%A1%80/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-接口的默认方法"><a href="#1-接口的默认方法" class="headerlink" title="1 接口的默认方法"></a>1 接口的默认方法</h1><h1 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2 Lambda 表达式"></a>2 Lambda 表达式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匿名内部类方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List list)</span>&#123;<br>    Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">//lambda表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaSort00</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>    Collections.sort(list, (String x,String y) -&gt; &#123;<br>        <span class="hljs-keyword">return</span> x.compareTo(y);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">//函数体只有一行代码时，你可以去掉大括号以及return关键字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaSort01</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>    Collections.sort(list, (String x,String y) -&gt; x.compareTo(y));<br>&#125;<br><br><span class="hljs-comment">//编译器可以自动推导出参数类型，所以你可以不用再写一次类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaSort02</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>    Collections.sort(list, (x,y) -&gt; x.compareTo(y));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3 函数式接口"></a>3 函数式接口</h1><ul><li>函数式接口(Functional Interface)就是一个<strong>有且仅有一个抽象方法</strong>，但是可以有多个非抽象方法的接口。</li><li>可以使用 Lambda 表达式来表示<strong>该接口的一个实现。</strong></li><li>接口添加** @FunctionalInterface** 注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候会报错</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsZ8jRvZ0p7yR76lIdc89H0owgBf.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JAVA 8 之前一般是用匿名类实现的</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//可以使用Lambda表达式来表示该接口的一个实现</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4 方法引用"></a>4 方法引用</h1><ul><li>根据<strong>已有的</strong>方法实现来创建 Lambda 表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Lambda表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaSort02</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>    Collections.sort(list, (x,y)-&gt;x.compareTo(y));<br>&#125;<br><br><span class="hljs-comment">//引用 类静态方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaSort03</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>    Collections.sort(list, MyCompareTest::myStaticCompare);<br>&#125;<br><br><span class="hljs-comment">//引用 实例方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaSort04</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>    Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCompareTest</span>()::myCompare);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: wqc</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-09-16 15:38</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompareTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myCompare</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.compareTo(s2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myStaticCompare</span> <span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.compareTo(s2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Stream"><a href="#5-Stream" class="headerlink" title="5 Stream"></a>5 Stream</h1><ul><li>Java 8 新增的 Stream 是为了方便操作集合（<strong>Collection</strong>）。</li><li>每次操作流都会返回一个新的流对象，方便进行链式操作，但<strong>原有的流对象会保持不变</strong>。</li></ul><h2 id="5-1-创建流"><a href="#5-1-创建流" class="headerlink" title="5.1 创建流"></a>5.1 创建流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组创建流（方式一）</span><br>String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>&#125;;<br>Stream&lt;String&gt; stream = Arrays.stream(arr);<br><span class="hljs-comment">//数组创建流（方式二）</span><br>stream = Stream.of(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);<br><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);<br><span class="hljs-comment">//集合创建流</span><br>stream = list.stream();<br><span class="hljs-comment">//集合创建并发流</span><br>stream = list.parallelStream();<br></code></pre></td></tr></table></figure><h2 id="5-2-操作流"><a href="#5-2-操作流" class="headerlink" title="5.2 操作流"></a>5.2 操作流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;DD&quot;</span>);<br>Stream&lt;String&gt; stream = list.stream();<br><span class="hljs-comment">//过滤 输出：AAA</span><br>list.stream().filter(elem -&gt; elem.contains(<span class="hljs-string">&quot;A&quot;</span>)).forEach(System.out::println);<br><br><span class="hljs-comment">//映射 输出：3 3 3 2</span><br>list.stream().map(<span class="hljs-keyword">for</span>).forEach(System.out::println);<br><br><span class="hljs-comment">//匹配</span><br>list.stream().anyMatch(element -&gt; element.contains(<span class="hljs-string">&quot;A&quot;</span>));<br>list.stream().allMatch(element -&gt; element.length() &gt; <span class="hljs-number">1</span>);<br>list.stream().noneMatch(element -&gt; element.endsWith(<span class="hljs-string">&quot;X&quot;</span>));<br><br><span class="hljs-comment">//组合</span><br>Optional&lt;String&gt; optional = list.stream().reduce((a, b) -&gt; a + b);<br>System.out.println(optional.orElse(<span class="hljs-string">&quot;null&quot;</span>));<br><span class="hljs-comment">//&quot;test&quot;为起始值</span><br>System.out.println(list.stream().reduce(<span class="hljs-string">&quot;test&quot;</span>, (a, b) -&gt; a + b));<br><br><span class="hljs-comment">//去重</span><br>list.stream().distinct().forEach(System.out::println);<br><br><span class="hljs-comment">//删除 输出：DD</span><br>list.stream().skip(<span class="hljs-number">3</span>).forEach(System.out::println);<br><br><span class="hljs-comment">//求最小值 输出：Optional[AAA]</span><br>list.stream().min(String::compareTo);<br></code></pre></td></tr></table></figure><h3 id="5-2-1-中间操作之-map-与-flatMap"><a href="#5-2-1-中间操作之-map-与-flatMap" class="headerlink" title="5.2.1 中间操作之 map 与 flatMap"></a>5.2.1 中间操作之 map 与 flatMap</h3><ul><li>map</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;World&quot;</span>&#125;;<br>List&lt;String[]&gt; a = Arrays.stream(words)<br>    .map(word -&gt; word.split(<span class="hljs-string">&quot;&quot;</span>))<br>    .distinct()<br>    .collect(toList());<br>a.forEach(System.out::print);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fo6U7gmF-YArcyUvG8UbySUGq4S0.png"></p><ul><li>flatMap(对流扁平化处理)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;World&quot;</span>&#125;;<br>List&lt;String&gt; a = Arrays.stream(words)<br>    .map(word -&gt; word.split(<span class="hljs-string">&quot;&quot;</span>))<br>    .flatMap(Arrays::stream)<br>    .distinct()<br>    .collect(toList());<br>a.forEach(System.out::print);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fo1t0Yi-LEUwu3A3Xmh8JL8tj9g4.png"></p><h2 id="5-3-terminal-operation"><a href="#5-3-terminal-operation" class="headerlink" title="5.3 terminal operation"></a>5.3 terminal operation</h2><p>Collectors 就是一个 collector 工厂，原理如下图：<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FpXafat2yx1Ch5zSgj12bBQNFbe0.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//流转化为List</span><br>list.stream().collect(Collectors.toList());<br>list.stream().collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword">new</span>));<br><br><span class="hljs-comment">// 流转化为Map</span><br>list.stream().collect(Collectors.toMap(DTO::getId,<br>                                       Function.identity(),<br>                                       (newData, oldData) -&gt; newData));<br><br><span class="hljs-comment">// 去重1</span><br>list.stream()<br>    .collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(dto::getName))), ArrayList::<span class="hljs-keyword">new</span>));<br><span class="hljs-comment">// 去重2</span><br>list.stream()<br>    .collect(Collectors.groupingBy(dto::getName));<br></code></pre></td></tr></table></figure><h1 id="6-新增的接口-类"><a href="#6-新增的接口-类" class="headerlink" title="6 新增的接口/类"></a>6 新增的接口/类</h1><h2 id="6-1-函数式接口"><a href="#6-1-函数式接口" class="headerlink" title="6.1 函数式接口"></a>6.1 <strong>函数式接口</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// x -&gt; y</span><br>Function&lt;Integer, Integer&gt; function = x -&gt; x + <span class="hljs-number">5</span>;<br>System.out.println(function.apply(<span class="hljs-number">3</span>));<br><br><span class="hljs-comment">// () -&gt; y</span><br>Supplier&lt;Integer&gt; supplier = () -&gt; <span class="hljs-number">5</span>;<br>System.out.println(supplier.get());<br><br><span class="hljs-comment">// x -&gt; ()</span><br>Consumer&lt;Integer&gt; consumer = System.out::println;<br>consumer.accept(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// (x, y) -&gt; ()</span><br>BiConsumer&lt;Integer, Integer&gt; biConsumer = (x, y) -&gt; System.out.println(x + y);<br>biConsumer.accept(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// x -&gt; Boolean</span><br>Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; <span class="hljs-number">5</span>;<br>System.out.println(predicate.test(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><h2 id="6-2-Optional-类"><a href="#6-2-Optional-类" class="headerlink" title="6.2 Optional 类"></a>6.2 <strong>Optional 类</strong></h2><ul><li>防止 NullPointerException</li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JHipster</title>
    <link href="/2020/09/15/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/JHipster/"/>
    <url>/2020/09/15/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/JHipster/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><ul><li>JHipster 或者称 Java Hipster，是一个应用代码产生器，能够创建 SpringBoot + AngularJS/React 的单体或分布式应用。</li><li>架构图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FlPmOwGeNa_PdwivWrk11D4hPGkN.png"></p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h1><h2 id="2-1-安装-JDK"><a href="#2-1-安装-JDK" class="headerlink" title="2.1 安装 JDK"></a>2.1 安装 JDK</h2><p>官网推荐 jdk11，jdk1.8 也可</p><h2 id="2-2-安装-node-js（请使用-LTS-64-位版本-非-LTS-版本不再支持）"><a href="#2-2-安装-node-js（请使用-LTS-64-位版本-非-LTS-版本不再支持）" class="headerlink" title="2.2 安装 node.js（请使用 LTS 64 位版本, 非 LTS 版本不再支持）**"></a>2.2 安装 node.js（<strong>请使用 LTS 64 位版本, 非 LTS 版本不再支持</strong>）**</h2><p><strong>node：</strong>就是一个<strong>javascript 的运行环境（平台）</strong>，他不是一门语言，也不是 javascript 的框架。可以用来开发服务端应用程序，web 系统。其特点是体积小，快速，高性能。</p><ul><li>查看 node 版本：<ul><li><code>node -v</code></li></ul></li></ul><p><strong>npm：</strong>JavaScript 的包管理工具。类似 Java 中的 maven，gradle</p><ul><li>设置淘宝镜像<ul><li><code>npm config set registry </code><a href="https://registry.npm.taobao.org/"><code>https://registry.npm.taobao.org</code></a></li></ul></li><li>查看 npm 的配置信息<ul><li><code>npm config list</code></li></ul></li></ul><h2 id="2-3-安装-JHipster"><a href="#2-3-安装-JHipster" class="headerlink" title="2.3 安装 JHipster"></a>2.3 安装 JHipster</h2><ul><li><code>npm install -g generator-jhipster</code></li></ul><h1 id="3-创建应用程序"><a href="#3-创建应用程序" class="headerlink" title="3 创建应用程序"></a>3 创建应用程序</h1><ul><li>创建一个生产应用程序的空目录<ul><li><code>mkdir jhipstertest</code></li></ul></li><li>进入目录，生成应用程序<ul><li><code>cd C:\Will\Study\workspace\jhipstertest</code></li><li><code>jhipster</code></li></ul></li><li>启动<ul><li><code>./mvnw</code></li></ul></li></ul><h1 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3 项目结构"></a>3 项目结构</h1>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>脚手架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2020/09/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/"/>
    <url>/2020/09/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="1-指令"><a href="#1-指令" class="headerlink" title="1. 指令"></a>1. 指令</h1><h2 id="1-1-docker"><a href="#1-1-docker" class="headerlink" title="1.1 docker"></a>1.1 docker</h2><p>systemctl stop docker.service<br>systemctl start docker.service<br>systemctl restart docker.service<br>systemctl status docker.service</p><p>–拉取镜像<br>docker pull how2j/tmall</p><p>–运行镜像<br>docker run -dit –privileged -p21:21 -p80:80 -p8080:8080 -p30000-30010:30000-30010 –name how2jtmall how2j/tmall:latest /usr/sbin/init</p><p>–检查端口<br>netstat -anp|grep 8080</p><p>–访问<br><a href="http://192.168.0.128:8080/tmall/">http://192.168.0.128:8080/tmall/</a></p><p>–进入容器<br>docker exec -it how2jtmall /bin/bash</p><p>–退出容器<br>exit</p><hr><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">set-default</span> <span class="hljs-string">graphical</span>.<span class="hljs-string">target</span>  <span class="hljs-comment"># 将默认模式修改为图形界面模式</span><br><span class="hljs-string">systemctl</span> <span class="hljs-built_in">set-default</span> <span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span> <span class="hljs-comment"># 将默认模式修改为命令行模式</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MapStruct</title>
    <link href="/2020/09/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/MapStruct/MapStruct/"/>
    <url>/2020/09/08/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/MapStruct/MapStruct/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><ul><li><strong>官网</strong>：<a href="https://mapstruct.org/">https://mapstruct.org/</a></li><li>MapStruct 是一个<strong>属性映射工具</strong>，只需要定义一个 Mapper 接口，MapStruct 就会自动实现这个映射接口，避免了复杂繁琐的映射实现</li><li>**@Mapper **注解的 **componentModel **属性用于指定自动生成的接口实现类的组件类型，支持四个值：<ul><li>**default: **默认的情况，mapstruct 不使用任何组件类型, 可以通过 Mappers.getMapper(Class)方式获取自动生成的实例对象。</li><li>**cdi: **the generated mapper is an application-scoped CDI bean and can be retrieved via @Inject</li><li><strong>spring:</strong> 生成的实现类上会自动添加@Component，可以通过 Spring 的@Autowired 方式注入</li><li>**jsr330: **生成的实现类上会添加@javax.inject.Named 和@Singleton 注解，可以通过 @Inject 注解获取</li></ul></li></ul><h1 id="2-应用"><a href="#2-应用" class="headerlink" title="2 应用"></a>2 应用</h1><h2 id="2-1-引入依赖："><a href="#2-1-引入依赖：" class="headerlink" title="2.1 引入依赖："></a>2.1 引入依赖：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapstruct.version</span>&gt;</span>1.2.0.Final<span class="hljs-tag">&lt;/<span class="hljs-name">mapstruct.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 包含了一些必要的注解，例如@Mapping。若我们使用的JDK版本高于1.8，当我们在pom里面导入依赖时候，</span><br><span class="hljs-comment">建议使用坐标是：org.mapstruct:mapstruct-jdk8，这可以帮助我们利用一些Java8的新特性。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 注解处理器，根据注解自动生成mapper的实现。--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-定义接口"><a href="#2-2-定义接口" class="headerlink" title="2.2 定义接口"></a>2.2 定义接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.mapstruct.Mapper;<br><br><span class="hljs-meta">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AgrSceneGroupTempRelMapper</span> &#123;<br><br>   <span class="hljs-comment">//定义DTO与entity之间字段关系</span><br><span class="hljs-meta">@Mappings(&#123;</span><br><span class="hljs-meta">    @Mapping(source = &quot;townName&quot;, target = &quot;regionName&quot;),</span><br><span class="hljs-meta">        @Mapping(source = &quot;bName&quot;, target = &quot;bbbName&quot;)</span><br><span class="hljs-meta">    &#125;)</span><br>    AgrSceneGroupTempRel <span class="hljs-title function_">toEntity</span><span class="hljs-params">(AgrSceneGroupTempRelDTO trainingDto)</span>;<br><br>    AgrSceneGroupTempRelDTO <span class="hljs-title function_">toDto</span><span class="hljs-params">(AgrSceneGroupTempRel training)</span>;<br><br>    List&lt;AgrSceneGroupTempRelDTO&gt; <span class="hljs-title function_">listEntityToDto</span><span class="hljs-params">(List&lt;AgrSceneGroupTempRel&gt; training)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-clean，然后-compile"><a href="#2-3-clean，然后-compile" class="headerlink" title="2.3 clean，然后 compile"></a>2.3 clean，然后 compile</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fi_gn6GCYIva3UgPePQ1FS4byndW.png"></p><ul><li>实现类已生成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsiIe-PvihcBiwb6tqn-5XBBEEY9.png"></p><h1 id="3-注解"><a href="#3-注解" class="headerlink" title="3 注解"></a>3 注解</h1><ul><li>@Mapper<ul><li>componentModel<ul><li>default：默认，可以通过 Mappers.getMapper(Class) 方式获取实例对象</li><li>spring：在接口的实现类上自动添加注解 @Component，可通过 @Autowired 方式注入</li></ul></li></ul></li><li>@Mapping 属性映射，若源对象属性与目标对象名字一致，会自动映射对应属性<ul><li>source：源属性</li><li>target：目标属性</li><li>dateFormat：String 到 Date 日期之间相互转换</li><li>ignore: 转换时忽略这个字段</li></ul></li><li>@Mappings：配置多个@Mapping</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>MapStruct</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Log</title>
    <link href="/2020/09/03/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/log/Log/"/>
    <url>/2020/09/03/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/log/Log/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fj5tagGSzGFScHm7h8xRYQ582ixJ.jpeg"></p><h1 id="1-日志门面"><a href="#1-日志门面" class="headerlink" title="1 日志门面"></a>1 日志门面</h1><h2 id="1-1-Commons-Logging"><a href="#1-1-Commons-Logging" class="headerlink" title="1.1 Commons Logging"></a>1.1 Commons Logging</h2><p>Commons Logging 是通过动态查找机制，在程序运行时，使用自己的 ClassLoader 寻找和载入本地具体的实现。详细策略可以查看 commons-logging-*.jar 包中的 org.apache.commons.logging.impl.LogFactoryImpl.java 文件。由于 Osgi 不同的插件使用独立的 ClassLoader，Osgi 的这种机制保证了插件互相独立, 其机制限制了 Commons Logging 在 Osgi 中的正常使用。</p><h2 id="1-2-Slf4j"><a href="#1-2-Slf4j" class="headerlink" title="1.2 Slf4j"></a>1.2 Slf4j</h2><p>Slf4j 在编译期间，静态绑定本地的 Log 库，因此可以在 Osgi 中正常使用。它是通过查找类路径下 org.slf4j.impl.StaticLoggerBinder，然后在 StaticLoggerBinder 中进行绑定。</p><hr><h1 id="2-日志实现"><a href="#2-日志实现" class="headerlink" title="2 日志实现"></a>2 日志实现</h1><h2 id="2-1-Logback"><a href="#2-1-Logback" class="headerlink" title="2.1 Logback"></a>2.1 Logback</h2><h2 id="2-2-Log4j"><a href="#2-2-Log4j" class="headerlink" title="2.2 Log4j"></a>2.2 Log4j</h2>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>log</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/HTTP/"/>
    <url>/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><strong>以下部分内容摘自《图解 HTTP》</strong></p><ul><li><p><strong>无状态协议</strong></p><blockquote><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说 HTTP 这个级别，协议对于发送过的请求和响应都不做持久化的处理。</p></blockquote><ul><li>设计简单，为了更快的处理大量的事务，确保协议的可伸缩性</li><li>HTTP + Cookie 就可以管理状态了</li></ul></li></ul><hr><ul><li><p><strong>持久连接</strong></p><blockquote><p>持久连接也被称为 HTTP keep alive 或者 HTTP connection reuse。它的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p></blockquote><ul><li><p>好处</p><ul><li>减少了 TCP 连接重复建立和断开的时间开销</li><li>减轻了服务端的负载</li></ul></li><li><p><strong>HTTP 初始版本：</strong></p></li></ul></li></ul><p>**<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgNGqwwDzAa16gEWUFAsnZDeivZY.webp"></p><ul><li><strong>HTTP1.1 后默认持久连接：</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhmMpE_lm644NSa5wMuRrWuY2zzE.webp"></p><hr><ul><li>管线化<blockquote><p>同时<strong>并行</strong>发送多个请求。之前需要发送请求之后必须等待并且接收到回应之后，才能发送下一个请求。管线化技术出现之后，就不用等待就可以发送下一个请求了。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhB7Z09Xacz__aoppbDsugTqkkUL.webp"></p><h1 id="2-HTTP-请求方法"><a href="#2-HTTP-请求方法" class="headerlink" title="2 HTTP 请求方法"></a>2 HTTP 请求方法</h1><h2 id="2-1-GET"><a href="#2-1-GET" class="headerlink" title="2.1 GET"></a>2.1 GET</h2><ul><li>一般用来获取数据</li><li>HTTP 协议规范没有对 URL 长度进行限制，但是特定的<strong>浏览器</strong>及<strong>服务器</strong>会对长度进行限制，如果是服务端调用服务端接口，则长度只受服务器影响<ul><li>IE    2083 个字符</li><li>Firefox    65,536 个字符</li><li>Safari    80,000 个字符</li><li>Opera    190,000 个字符</li><li>Google chrome    8182 个字符</li><li>Apache Server    8,192 个字符</li><li>IIS 微软 web server    16,384 个字符</li></ul></li></ul><h2 id="2-2-POST"><a href="#2-2-POST" class="headerlink" title="2.2 POST"></a>2.2 POST</h2><p>一般用来新增数据</p><h2 id="2-3-PUT"><a href="#2-3-PUT" class="headerlink" title="2.3 PUT"></a>2.3 PUT</h2><p>一般用来修改数据</p><h2 id="2-4-Delete"><a href="#2-4-Delete" class="headerlink" title="2.4 Delete"></a>2.4 Delete</h2><p>一般用来删除数据</p><h2 id="2-5-TRACE"><a href="#2-5-TRACE" class="headerlink" title="2.5 TRACE"></a>2.5 TRACE</h2><p>回显服务器收到的请求，主要用于测试或诊断</p><h2 id="2-6-OPTIONS"><a href="#2-6-OPTIONS" class="headerlink" title="2.6 OPTIONS"></a>2.6 OPTIONS</h2><p>获取服务器支持的 HTTP 请求方法<br>用来检查服务器的性能</p><h2 id="2-7-HEAD"><a href="#2-7-HEAD" class="headerlink" title="2.7 HEAD"></a>2.7 HEAD</h2><p>请求获取由 Request-URI 所标识的资源的响应消息报头</p><h2 id="2-8-CONNECT"><a href="#2-8-CONNECT" class="headerlink" title="2.8 CONNECT"></a>2.8 CONNECT</h2><p>This specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel</p><hr><h1 id="3-HTTP-状态码"><a href="#3-HTTP-状态码" class="headerlink" title="3 HTTP 状态码"></a>3 HTTP 状态码</h1><ul><li><strong>200</strong> OK<ul><li>当您的操作将在响应正文中返回数据时，出现此结果。</li></ul></li><li><strong>204</strong> No Content<ul><li>当您的操作成功，但不在响应正文中返回数据时，出现此结果。</li></ul></li><li><strong>304</strong> Not Modified（重定向）<ul><li>当测试实体自上次检索以来是否被修改时，出现此结果。</li></ul></li><li><strong>403</strong> Forbidden</li><li><strong>401</strong> Unauthorized<ul><li>客户端试图未经授权访问受保护的资源</li></ul></li><li><strong>413</strong> Payload Too Large<ul><li>当请求长度过长时，出现此结果。</li></ul></li><li><strong>400</strong> BadRequest<ul><li>当参数无效时，出现此结果。</li></ul></li><li><strong>404</strong> Not Found<ul><li>无法找到指定位置的资源</li></ul></li><li><strong>405</strong> Method Not Allowed<ul><li>请求方法（GET、POST、HEAD、Delete、PUT、TRACE 等）对指定的资源不适用。</li></ul></li><li><strong>406</strong> Not Acceptable<ul><li>指定的资源已经找到，但它的 MIME 类型和客户在 Accpet 头中所指定的不兼容</li></ul></li><li><strong>412</strong> Precondition Failed</li><li><strong>500</strong> Internal Server Error<ul><li>服务器内部错误</li></ul></li><li><strong>501</strong> Not Implemented<ul><li>当未实施某个请求的操作时，出现此结果。</li></ul></li><li><strong>502</strong> Bad Gateway</li><li><strong>503</strong> Service Unavailable<ul><li>当 Web API 服务不可用时，出现此结果。</li></ul></li><li><strong>504</strong> Gateway Timeout<ul><li>由代理或网关服务使用，表示不能及时地从远程服务器获得应答</li></ul></li></ul><h1 id="4-HTTP-head-中常用字段"><a href="#4-HTTP-head-中常用字段" class="headerlink" title="4 HTTP head 中常用字段"></a>4 HTTP head 中常用字段</h1><h2 id="4-1-request"><a href="#4-1-request" class="headerlink" title="4.1 request"></a>4.1 request</h2><ul><li>Accept：用于高速服务器，客户机支持的数据类型</li><li>Accept-Charset：用于告诉服务器，客户机采用的编码格式</li><li>Accept-Encoding：用于告诉服务器，客户机支持的数据压缩格式</li><li>Accept-Language：客户机的语言环境</li><li>Host：客户机通过这个头高速服务器，想访问的主机名</li><li>If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间</li><li>Referer：客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的（防盗链）</li><li><strong>Content-Type</strong>：指定 body 中的数据类型</li><li>Content-Length：指定发送数据的长度</li><li>User-Agent：客户机通过这个头告诉服务器，客户机的软件环境</li><li>Cookie：客户机通过这个头可以向服务器带数据</li><li>Connection：处理完这次请求后是否断开连接还是继续保持连接</li><li>Date：当前时间值</li></ul><h2 id="4-2-response"><a href="#4-2-response" class="headerlink" title="4.2 response"></a>4.2 response</h2><ul><li>Location：这个头配合 302 状态码使用，用于告诉客户找谁。</li><li>Server：服务器通过这个头告诉浏览器服务器的类型。</li><li>Content-Encoding：服务器通过这个头告诉浏览器数据的压缩格式。</li><li>Content-Length：服务器通过这个头告诉浏览器回送数据的长度</li><li><strong>Content-Type</strong>：服务器通过这个头告诉浏览器回送数据的类型</li><li>Last-Modified：告诉浏览器当前资源的最后缓存时间</li><li>Refresh：告诉浏览器隔多久刷新一次</li><li>Content-Disposition：告诉浏览器以下载方式打开数据</li><li>Transfer-Encoding：告诉浏览器数据的传送格式</li><li>ETag：缓存相关的头</li><li>Expires：告诉浏览器把回送的资源缓存多长时间 -1 或 0 则是不缓存</li><li>Cache-Control：no-cache ，控制浏览器不要缓存数据</li><li>Pragma：no-cache， 控制浏览器不要缓存数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络与安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GraphQL</title>
    <link href="/2020/09/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/GraphQL/GraphQL/"/>
    <url>/2020/09/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/GraphQL/GraphQL/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>与 RESTful 不同，每一个的 GraphQL 服务其实对外只提供了一个用于调用内部接口的端点，所有的请求都访问这个暴露出来的唯一端点。<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsGCbdjuHnVSaW7XdtRGhCwm1zfK.png"></p><h2 id="1-1-标量"><a href="#1-1-标量" class="headerlink" title="1.1 标量"></a>1.1 标量</h2><p>标量(ScalarTypeDefinition)是 GraphQL 中不可分割的原子数据类型，在服务中充当叶子节点。对于客户端而言，合法的查询集(Select Set)必须到达叶子节点，也就是到达标量类型节点。</p><ul><li><strong>GraphQL 规范提供了五种标量：</strong></li></ul><ol><li>Int: 32 位有符号整型，超出精度范围后，引擎会抛出异常</li><li>Float: 有符号双精度浮点数，超出精度范围后，引擎会抛出异常</li><li>String: 字符串，用于表示 UTF-8 字符序列</li><li>Boolean: bool 值</li><li>ID: 资源唯一标志符</li></ol><ul><li><strong>自定义标量：</strong></li></ul><ol><li>在.graphql 文件中定义标量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">scalar Datetime<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>定义序列化、反序列化函数</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateTimeScalarType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GraphQLScalarType</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DATE_FORMAT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DateTimeScalarType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;DateTime&quot;</span>, <span class="hljs-string">&quot;A valid date time value.&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Coercing</span>&lt;Date, String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object o)</span> &#123;<br>                <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> (Date) o;<br>                <span class="hljs-keyword">return</span> sdf.format(date);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">parseValue</span><span class="hljs-params">(Object o)</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> String.valueOf(o);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;null&quot;</span>.equalsIgnoreCase(value) || <span class="hljs-string">&quot;&quot;</span>.equalsIgnoreCase(value)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">return</span> DateUtils.parseDate(value, DATE_FORMAT);<br>                &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">parseLiteral</span><span class="hljs-params">(Object o)</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> String.valueOf(o);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;null&quot;</span>.equalsIgnoreCase(value) || <span class="hljs-string">&quot;&quot;</span>.equalsIgnoreCase(value)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">return</span> DateUtils.parseDate(value, DATE_FORMAT);<br>                &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="2-应用"><a href="#2-应用" class="headerlink" title="2 应用"></a>2 应用</h1><h2 id="2-1-依赖"><a href="#2-1-依赖" class="headerlink" title="2.1 依赖"></a>2.1 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.graphql-java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>graphql-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.graphql-java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>graphql-java-tools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.graphql-java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>graphiql-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h2><ul><li>定义 root.graphqls（应与 resolver 类中方法同名）：</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta">#查询入口</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Query</span> &#123;</span><br><span class="hljs-class">    <span class="hljs-title">selectById</span>(<span class="hljs-title">id</span>:<span class="hljs-type">ID</span>!): <span class="hljs-type">City</span></span><br><span class="hljs-class">    <span class="hljs-title">selectAgrTemplateStyleById</span>(<span class="hljs-title">id</span>:<span class="hljs-type">ID</span>!): <span class="hljs-type">AgrTemplateStyle</span></span><br><span class="hljs-class">    <span class="hljs-title">queryq</span>: <span class="hljs-type">AgrScene</span></span><br><span class="hljs-class">&#125;</span><br><br><span class="hljs-meta">#修改入口</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Mutation</span> &#123;</span><br><span class="hljs-class">    <span class="hljs-title">updateCityById</span>(<span class="hljs-title">input</span>: <span class="hljs-type">CityInput</span>!): <span class="hljs-type">Int</span></span><br><span class="hljs-class">    <span class="hljs-title">releaseTemplate</span>(<span class="hljs-title">agrSceneGroupTempRel</span>:<span class="hljs-type">AgrSceneGroupTempRel</span>!): <span class="hljs-type">Int</span></span><br><span class="hljs-class">    <span class="hljs-title">offlineTemplate</span>(<span class="hljs-title">id</span>:<span class="hljs-type">ID</span>!): <span class="hljs-type">Int</span></span><br><span class="hljs-class">&#125;</span><br><br>//定义输入类型<br><span class="hljs-title">input</span> <span class="hljs-type">AgrSceneGroupTempRel</span> &#123;<br>    id:<span class="hljs-type">Int</span><br>    templateId: <span class="hljs-type">Int</span><br>    parentTemplateId: <span class="hljs-type">Int</span><br>    groupId: <span class="hljs-type">Int</span><br>    tenantId: <span class="hljs-type">Int</span><br>    isDelete: <span class="hljs-type">Int</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateMutation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GraphQLMutationResolver</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ITemplateService iTemplateService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">releaseTemplate</span><span class="hljs-params">(AgrSceneGroupTempRelDTO dto)</span> &#123;<br>        <span class="hljs-keyword">return</span> iTemplateService.releaseTemplate(dto);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="http://localhost:8089/graphiql">http://localhost:8089/graphiql</a>，前端参数：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">--参数为AgrSceneGroupTempRel<br>mutation&#123;<br>  releaseTemplate(<br>    agrSceneGroupTempRel:&#123;templateId:<span class="hljs-number">1</span>&#125;<br>  )<br>&#125;<br><br>--参数为List&lt;AgrSceneGroupTempRel&gt;<br>mutation&#123;<br>  releaseTemplate(<br>    agrSceneGroupTempRel:<br>    [&#123;templateId:<span class="hljs-number">1</span>&#125;,&#123;templateId:<span class="hljs-number">2</span>&#125;]<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>GraphQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-查询性能优化</title>
    <link href="/2020/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><strong>衡量查询开销的三个指标</strong></p><ul><li>响应时间（= 服务时间 + 排队时间）<ul><li>服务时间：数据库处理查询真正花费的时间</li><li>排队时间：服务器因为等待某些资源而没有真正执行查询的时间</li></ul></li><li>扫描的行数</li><li>返回的行数</li></ul><hr><h1 id="0-优化顺序"><a href="#0-优化顺序" class="headerlink" title="0 优化顺序"></a>0 优化顺序</h1><blockquote><p>以下成本由低到高</p></blockquote><h2 id="0-1-优化-sql-和-index"><a href="#0-1-优化-sql-和-index" class="headerlink" title="0.1 优化 sql 和 index"></a>0.1 优化 sql 和 index</h2><h2 id="0-2-加缓存（redis-等）"><a href="#0-2-加缓存（redis-等）" class="headerlink" title="0.2 加缓存（redis 等）"></a>0.2 加缓存（redis 等）</h2><h2 id="0-3-分区"><a href="#0-3-分区" class="headerlink" title="0.3 分区"></a>0.3 分区</h2><h2 id="0-4-分表"><a href="#0-4-分表" class="headerlink" title="0.4 分表"></a>0.4 分表</h2><h3 id="0-4-1-垂直切分"><a href="#0-4-1-垂直切分" class="headerlink" title="0.4.1 垂直切分"></a>0.4.1 垂直切分</h3><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmwCa_HhBBXSX_jf_UX9NaxUQHvR.png"></p><h3 id="0-4-2-水平切分"><a href="#0-4-2-水平切分" class="headerlink" title="0.4.2 水平切分"></a>0.4.2 水平切分</h3><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhAd3jNgZCpZSqc_Sa-6CEFjIaoD.png"></p><h2 id="0-5-分库"><a href="#0-5-分库" class="headerlink" title="0.5 分库"></a>0.5 分库</h2><p>主从复制，读写分离<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FlRQkiEU_uHr5nv85_2qxYRR9Go1.png"></p><hr><h1 id="1-优化数据访问"><a href="#1-优化数据访问" class="headerlink" title="1.优化数据访问"></a>1.优化数据访问</h1><h2 id="1-1-是否向服务器请求了不需要的数据"><a href="#1-1-是否向服务器请求了不需要的数据" class="headerlink" title="1.1 是否向服务器请求了不需要的数据"></a>1.1 是否向服务器请求了不需要的数据</h2><ul><li>查询不需要的记录</li><li>总是去查询全部列</li><li>重复查询相同数据（相同数据可缓存起来）</li></ul><h2 id="1-2MySQL-是否扫描了额外记录"><a href="#1-2MySQL-是否扫描了额外记录" class="headerlink" title="1.2MySQL 是否扫描了额外记录"></a>1.2MySQL 是否扫描了额外记录</h2><p>通过执行计划，若发现了查询需要扫描大量的数据，但值返回少数的行，通常可以尝试以下方式优化：</p><ul><li><strong>覆盖索引。</strong>把所有需要用到的列都放到索引中，这样存储引擎无需回表。</li><li><strong>改变库表结</strong>构。（例如使用单独的汇总表）</li><li><strong>重写查询。</strong>让 MySQL 优化器能够以更优化的方式执行这个查询。<ul><li><strong>切分查询</strong></li></ul></li></ul><p>有时候可以对一个大查询“分而治之”(若一个查询可以胜任，还切分为多个独立查询是不明智的)，将大查询切分为小查询，每个查询功能完全一样，只完成一小部分。<br>例如删除旧数据，清理大量数据时，如果一次完成，则可能需要一次锁住很多数据，耗尽系统资源，阻塞很多小而重要的查询。在每次删除部分数据后，可以暂停一会儿再做下一次删除操作，可以将压力分散到一个很长的时间段，降低对服务器的影响。</p><ul><li><strong>分解关联查询</strong></li></ul><p>很多高性能的应用都会对关联查询进行分解。对每一个表进行一次单表查询，然后在应用中对结果进行关联</p><pre><code class="hljs">  - 缓存效率更高  - 应用层做关联，可以更容易对数据库进行拆分。</code></pre><hr>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-存储引擎</title>
    <link href="/2020/08/28/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2020/08/28/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FhzzJGcZ1bYvjnXYV3C0Aud7QlGz.jpeg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plsql">--查看mysql现在已提供什么存储引擎<br>show engines;<br>--查看table使用的是什么引擎<br>show table status like &#x27;table_name&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FoksqPjIY3skJ3Uz-9GO6KBTrtab.png"></p><hr><ul><li>除非需要用到某些 InnoDB 不具备的特性，并且没有其他方法可以替代，否则应优先选择 InnoDB。</li><li>除非万不得已，否则建议不要混合使用多种存储引擎。</li></ul><h1 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h1>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-索引</title>
    <link href="/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FisYeEfWKeHAVtpasfiBRu2sekhi.jpeg">- 由存储引擎负责实现索引，不同存储引擎的索引工作方式并不一样。</p><h1 id="1-操作"><a href="#1-操作" class="headerlink" title="1.操作"></a>1.操作</h1><h2 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1 创建"></a>1.1 创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plsql">--index_name可选<br>ALTER TABLE table_name ADD INDEX index_name (column_names);<br>ALTER TABLE table_name ADD UNIQUE (column_names);<br>ALTER TABLE table_name ADD PRIMARY KEY (column_names);<br><br>--不能用CREATE INDEX语句创建PRIMARY KEY索引<br>CREATE INDEX index_name ON table_name (column_list);<br>CREATE UNIQUE INDEX index_name ON table_name (column_list);<br></code></pre></td></tr></table></figure><h2 id="1-2-删除"><a href="#1-2-删除" class="headerlink" title="1.2 删除"></a>1.2 删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plsql">ALTER TABLE table_name DROP INDEX index_name;<br>ALTER TABLE table_name DROP PRIMARY KEY;<br><br>--只在删除PRIMARY KEY索引时使用<br>DROP INDEX index_name ON talbe_name;<br></code></pre></td></tr></table></figure><p>如果没有创建 PRIMARY KEY 索引，但表具有一个或多个 UNIQUE 索引，则 MySQL 将删除第一个 UNIQUE 索引。<br>对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p><h2 id="1-3-查看"><a href="#1-3-查看" class="headerlink" title="1.3 查看"></a>1.3 查看</h2><h3 id="1-3-1-查看索引"><a href="#1-3-1-查看索引" class="headerlink" title="1.3.1 查看索引"></a>1.3.1 查看索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plsql">SHOW INDEX FROM table_name;<br>SHOW KEYS FROM table_name;<br></code></pre></td></tr></table></figure><ul><li>Table                  表的名称</li><li>Non_unique      如果索引不能包括重复词，则为 0。如果可以，则为 1。</li><li>Key_name         索引的名称。</li><li>Seq_in_index     索引中的列序列号，从 1 开始。</li><li>Column_name    列名称。</li><li>Collation             列以什么方式存储在索引中。在 MySQL 中，有值‘A’（升序）或 NULL（无分类）。</li><li>Cardinality         索引中唯一值的数目的估计值。通过运行 ANALYZE TABLE 或 myisamchk -a 可以更新。基数根                              据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数                              越大，当进行联合时，MySQL 使用该索引的机会就越大。</li><li>Sub_part 　　      如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为                             NULL。</li><li>Packed                 指示关键字如何被压缩。如果没有被压缩，则为 NULL。</li><li>Null     　　          如果列含有 NULL，则含有 YES。如果没有，则该列含有 NO。</li><li>Index_type     　用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。</li></ul><h3 id="1-3-2-查看执行计划"><a href="#1-3-2-查看执行计划" class="headerlink" title="1.3.2 查看执行计划"></a>1.3.2 查看执行计划</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plsql">explain select column_names from table_name;<br><br>explain select * from book where author_name_id = (select id from author where author_name = &#x27;District panel&#x27;);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkB1WS-bxkgpnhG9KggQVrCwthUU.png"></p><ul><li><p><strong>id</strong></p><blockquote><p>表示查询中执行 SELECT 子句或操作表的顺序,SQL 按 id 从大到小执行。</p></blockquote></li><li><p><strong>select_type</strong></p><blockquote><p>表示 select 查询的类型</p></blockquote><ul><li><strong>SIMPLLE</strong>：简单查询，该查询不包含 UNION 或子查询</li><li><strong>PRIMARY</strong>：如果查询包含 UNION 或子查询，则最外层的查询被标识为 PRIMARY</li><li>UNION：表示此查询是 UNION 中的第二个或者随后的查询</li><li>DEPENDENT：UNION 满足 UNION 中的第二个或者随后的查询，其次取决于外面的查询</li><li>UNION RESULT：UNION 的结果 SUBQUERY：子查询中的第一个 select 语句(该子查询不在 from 子句中)</li><li><strong>SUBQUERY</strong>：子查询中的第一个 select 语句(该子查询不在 from 子句中)</li><li>DEPENDENT SUBQUERY：子查询中的 第一个 select，同时取决于外面的查询</li><li><strong>DERIVED</strong>：包含在 from 子句中子查询(也称为派生表)</li><li>UNCACHEABLE SUBQUERY：满足是子查询中的第一个 select 语句，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li><li>UNCACHEABLE UNION：满足此查询是 UNION 中的第二个或者随后的查询，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li></ul></li><li><p><strong>table</strong></p><blockquote><p>该列显示了对应行正在访问哪个表(有别名就显示别名)。当 from 子句中有子查询时，table 列是 <derivenN>格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询）</p></blockquote></li><li><p><strong>partitions</strong></p></li><li><p>**type</p><blockquote><p>称为<strong>关联类型</strong>或者<strong>访问类型</strong>，它指明了 MySQL 决定如何查找表中符合条件的行，同时<strong>是我们判断查询是否高效的重要依据</strong>。</p></blockquote><ul><li>ALL：全表扫描</li><li>index：全索引扫描。index 与 ALL 区别为 index 类型只遍历索引树</li><li>range：范围扫描</li><li>ref：一种索引访问，也称索引查找，它返回所有匹配某个单个值的行。针对于非唯一或非主键索引</li><li>eq_ref：唯一性索引或主键查找时会出现该值，非常高效。</li><li>const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用于在和 primary key 或 unique 索引中有固定值比较的情形。</li><li>NULL：在执行阶段不需要访问表。</li></ul></li></ul><p><em>从上至下，性能越来越好。</em></p><ul><li><p><strong>possible_keys</strong><br>这一列显示查询可能使用哪些索引来查找</p></li><li><p><strong>key</strong></p><blockquote><p>显示 MySQL 在查询中实际使用的索引，若没有使用索引，显示为 NULL</p></blockquote></li><li><p><strong>key_len</strong></p></li><li><p><strong>ref</strong></p></li><li><p><strong>rows</strong></p><blockquote><p>这一列显示了<strong>估计</strong>要找到所需的行而要读取的行数，这个值是个估计值，原则上值越小越好。</p></blockquote></li><li><p><strong>filtered</strong></p><blockquote><p>表示返回结果的行数占需要读取行数的百分比，值越大越好，filtered 列的值依赖统计信息，并不十分准确</p></blockquote></li><li><p><strong>Extra</strong></p><blockquote><p>包含不适合在其他列中显示但十分重要的额外信息</p></blockquote><ul><li>Using index：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。</li><li>Using Where：在存储引擎检索行后再进行过滤，使用了 where 从句来限制哪些行将与下一张表匹配或者是返回给用户。</li><li>Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。</li><li>Using filesort：对结果使用一个外部索引排序，而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大。</li></ul></li></ul><hr><h1 id="2-索引数据结构"><a href="#2-索引数据结构" class="headerlink" title="2.索引数据结构"></a>2.索引数据结构</h1><h2 id="2-1B-Tree"><a href="#2-1B-Tree" class="headerlink" title="2.1B+ Tree"></a>2.1B+ Tree</h2><h2 id="2-2Hash"><a href="#2-2Hash" class="headerlink" title="2.2Hash"></a>2.2Hash</h2><ul><li>优势<ul><li>hash 索引只包含<strong>hash 值</strong>和<strong>行指针</strong>，使索引结构紧凑，查询快。</li></ul></li><li>劣势<ul><li>hash 索引数据未按索引值顺序存储，无法用于排序</li><li>不支持部分索引列匹配查找，{A,B}上建索引，查询 A 时无法使用该索引</li><li>只支持等值查找，不支持范围查找</li><li>hash 冲突导致查询慢，维护代价高</li></ul></li></ul><hr><h1 id="3-索引的存储方式"><a href="#3-索引的存储方式" class="headerlink" title="3.索引的存储方式"></a>3.索引的存储方式</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fo0kfhSBLR45fVcXdA9xU_CDAIvD.png"></p><ul><li>InnoDB<ul><li>二级索引<ul><li>非叶子节点<ul><li>保存<strong>索引</strong>信息</li></ul></li><li>叶子节点<ul><li>保存数据的<strong>主键值</strong>（若非聚集索引，需要回表查询）</li></ul></li></ul></li><li>聚集索引（实际数据存储在此）<ul><li>非叶子节点<ul><li>保存<strong>索引</strong>信息</li></ul></li><li>叶子节点<ul><li>保存<strong>实际数据</strong></li></ul></li></ul></li></ul></li><li>MyISAM<ul><li>二级索引<ul><li>非叶子节点<ul><li>保存<strong>索引</strong>信息</li></ul></li><li>叶子节点<ul><li>保存数据的<strong>物理地址</strong></li></ul></li></ul></li><li>实际数据按插入顺序存储在磁盘上（非树形结构）</li></ul></li></ul><h2 id="3-1-聚簇索引"><a href="#3-1-聚簇索引" class="headerlink" title="3.1 聚簇索引"></a>3.1 聚簇索引</h2><blockquote><p>索引的叶子节点就是对应的数据节点（MySQL 的 MyISAM 除外）</p></blockquote><p>InnoDB 将通过<strong>主键</strong>聚集数据，若未定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替，若无唯一的非空索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。</p><ul><li>优势<ul><li>可以把相关数据保存在一起，只需要从磁盘读取少量的数据页就能获取全部信息，减少磁盘 I/O。</li><li>数据访问更快。聚簇索引把索引和数据保存在同一个树中，因此从聚簇索引中获取数据通常比非聚簇索引要快</li></ul></li><li>劣势<ul><li>更新索引代价高。<ul><li>InnoDB 会将每个被更新的行移动到新的位置</li><li>页分裂。当行的主键值要求必须将这一行数据插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li></ul></li></ul></li></ul><h2 id="3-2-二级索引（非聚集索引）"><a href="#3-2-二级索引（非聚集索引）" class="headerlink" title="3.2 二级索引（非聚集索引）"></a>3.2 二级索引（非聚集索引）</h2><blockquote><p>InnoDB 中二级索引的叶子节点包含了引用行的主键值（不是行指针，没有指向行的物理地址）。<br>若保存的是行指针，那么更新聚集索引后，会更新数据到新的位置，那么也要维护二级索引的叶子节点。若保存的是主键，则可以减少对二级索引的影响</p></blockquote><ul><li>优势<ul><li>当聚簇索引中出现行移动或页分列时，减少二级索引的维护工作</li></ul></li><li>劣势<ul><li>二级索引（非聚集索引）可能比想象的要大，因为在叶子节点包含了引用行的主键值。</li><li>若非覆盖索引，需进行回表查询。</li></ul></li></ul><h2 id="3-3-覆盖索引"><a href="#3-3-覆盖索引" class="headerlink" title="3.3 覆盖索引"></a>3.3 覆盖索引</h2><blockquote><p>一个索引覆盖所有需要查询的字段值,我们称之为“覆盖索引”。</p></blockquote><p>可以直接使用索引来获取列数据，而无需回表查询。</p><p>当发起一个索引覆盖查询时，在 Extra 列可以看到“Using index”。<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvzncHHxHD3gxljXyR26CXpXx25P.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-基本架构</title>
    <link href="/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>MySQL 基本架构：<br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkyNUFlO8-sTmdMHSTKgFCaVEPqt.webp"><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmhURtJZd4vP8NqsP7uPi5bVfc28.png"></p><h1 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h1><p>负责跟客户端<strong>建立链接</strong>、<strong>获取权限</strong>、<strong>维持和管理连接</strong>。<br>链接的时候会经过 TCP 握手，然后身份验证，然后我们输入用户名密码就好了。验证 ok 后，我们就连上了这个 MySQL 服务了，但是这个时候我们处于空闲状态。<br>我们数据库的客户端太久没响应，连接器就会自动断开了，这个时间参数是 wait_timeout 控制住的，默认时长为 8 小时。</p><hr><h1 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a><del>2.查询缓存</del></h1><p>查询的时候会拿着语句先去缓存中查询（通过一个对大小写敏感的<strong>hash 查找</strong>实现），如果能够命中就返回缓存的 value，如果不命中就执行后面的阶段。同一条语句在 MySQL 执行两次，第一次和后面的时间是不一样的，后者明显快一些，这就是因为缓存的存在。<br>跟 Redis 一样，只要是之前执行过的语句，都会在内存里面用 key-value 形式存储。</p><p><strong>缓存弊大于利：</strong><br>缓存的失效很容易，只要对表有任何的更新，这个表的所有查询缓存就会全部被清空，导致查询的命中率很低。<br>只有那种只查询不更新的表适用缓存，但是这样的表往往很少存在，一般都是什么配置表之类的。</p><p><strong>缓存在 MySQL8.0 之后就取消了。</strong></p><hr><h1 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3.分析器"></a>3.分析器</h1><ul><li><strong>词法分析</strong></li></ul><p>识别每个字符串所代表的是什么，是关键字，表名，还是列名等等。</p><ul><li><strong>语法分析</strong></li></ul><p>根据词法分析的结果，语法分析会判断 sql 的对错，错了会提醒你，并且会提示哪里错了。</p><hr><h1 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4.优化器"></a>4.优化器</h1><p>优化器在评估成本的时候并不考虑任何层面的缓存。</p><h2 id="4-1-如何优化"><a href="#4-1-如何优化" class="headerlink" title="4.1 如何优化"></a>4.1 如何优化</h2><ul><li><strong>确认使用哪个索引：</strong></li></ul><p>因为我们建立表可能会建立很多索引，优化有一步就是要确认使用哪个索引，比如使用你的主键索引，联合索引还是什么索引更好。<br><strong>优化过程</strong>大致如下：<br>1、根据搜索条件，找出所有可能使用的索引<br>2、计算全表扫描的代价<br>3、计算使用不同索引执行查询的代价<br>4、对比各种执行方案的代价，找出成本最低的那一个</p><ul><li><strong>对执行顺序进行优化</strong></li></ul><p>条件那么多，先查哪个表，还是先关联，会出现很多方案，最后由优化器决定选用哪种方案。</p><h2 id="4-2-优化器错误选择执行计划原因"><a href="#4-2-优化器错误选择执行计划原因" class="headerlink" title="4.2 优化器错误选择执行计划原因"></a>4.2 优化器错误选择执行计划原因</h2><ul><li>统计信息不准确。MySQL 依赖存储引擎提供的统计信息来评估成本，有的存储引擎提供的信息可能偏差较大。比如 InnoDB 因为 MVCC 不能维护一个数据表行数的精确统计信息。</li><li>优化器在评估成本的时候并不考虑任何层面的缓存。</li><li>MySQL 不考虑并发执行的查询</li><li>优化器有时无法估算所有可能的执行计划。</li></ul><hr><h1 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5.执行器"></a>5.执行器</h1><p>MySQL 根据执行计划给出的指令逐步执行。<br><strong>explain</strong>可以看到执行计划</p><hr><h1 id="6-存储引擎"><a href="#6-存储引擎" class="headerlink" title="6.存储引擎"></a>6.存储引擎</h1><p>存储引擎负责 MySQL 中数据的存储和提取</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>String</title>
    <link href="/2020/08/27/java%E5%9F%BA%E7%A1%80/String/"/>
    <url>/2020/08/27/java%E5%9F%BA%E7%A1%80/String/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jb51.net/article/49092.htm">https://www.jb51.net/article/49092.htm</a></p><h1 id="String-为什么不可变"><a href="#String-为什么不可变" class="headerlink" title="String 为什么不可变"></a>String 为什么不可变</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Ft6EAAx1UMoRlif4R1g0e8l6R9W7.png"></p><hr><h1 id="为什么-String-要设计成不可变"><a href="#为什么-String-要设计成不可变" class="headerlink" title="为什么 String 要设计成不可变"></a>为什么 String 要设计成不可变</h1><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li>若 String 对象允许改变,那么将会导致各种逻辑错误（s1 的修改会影响 s2）<ul><li>尤其是 String 对象会被当作各种参数使用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FtzzJw-sKSddZHpBl3-SKQFSy19f.png"></p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><ul><li>缓存 hash（修改时去修改缓存 hash 不可以吗？）</li><li>适合作为 map 中的 key</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FjX62XA8N9InZbxN2NzVm8D2J6-F.png"></p><h3 id="使用简单"><a href="#使用简单" class="headerlink" title="使用简单"></a>使用简单</h3><ul><li>因为不可变，所以就不用考虑多线程的情况</li></ul><hr><h1 id="循环中的-String"><a href="#循环中的-String" class="headerlink" title="循环中的 String"></a>循环中的 String</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// String</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        str += i;<br>    &#125;<br>    System.out.println(str);<br>&#125;<br><br><span class="hljs-comment">// StringBuilder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStringBuilder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        builder.append(i);<br>    &#125;<br>    System.out.println(builder.toString());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>String：每一次循环都创建一个 StringBuilder 对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqsO-FJgwXgvJOF65Ak-VBI2rYND.png"></p><ul><li>StringBuilder：只在循环外创建一个 StringBuilder 对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqsO-FJgwXgvJOF65Ak-VBI2rYND.png"><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqY3_A-96W9mpysUgFt5IWCkV5vX.png"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JMM</title>
    <link href="/2020/08/27/java%E5%9F%BA%E7%A1%80/JVM/JMM/"/>
    <url>/2020/08/27/java%E5%9F%BA%E7%A1%80/JVM/JMM/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiNxftbcfKLpuQ4VyOEomYZS80lj.jpeg">&gt; JMM 定义了 Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。（对特定的内存或高速缓存进行读写访问的过程抽象）</p><blockquote><p>从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fi0B1UrEQjpzwS2UUQG-DJC3ZJDr.png"></p><h1 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1 原子性"></a>1 原子性</h1><hr><h1 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2 可见性"></a>2 可见性</h1><h2 id="2-1-volatile"><a href="#2-1-volatile" class="headerlink" title="2.1 volatile"></a>2.1 volatile</h2><p>volatile 域规则：对一个 volatile 域的写操作，<strong>happens-before</strong>于任意线程后续对这个 volatile 域的读。</p><ul><li><p><strong>MESI:</strong></p><p>当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p></li><li><p><strong>怎么发现数据是否失效呢?</strong></p><p>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p></li><li><p><strong>缺点：</strong></p><p>总线风暴。由于 Volatile 的 MESI 缓存一致性协议，需要不断的从主内存嗅探和 cas 不断循环，无效交互会导致总线带宽达到峰值。所以不要大量使用 volatile。</p></li></ul><h2 id="2-2-synchronized"><a href="#2-2-synchronized" class="headerlink" title="2.2 synchronized"></a>2.2 synchronized</h2><p>因为某一个线程进入 synchronized 代码块前后，线程会获得锁，<strong>清空工作内存</strong>，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。<br>而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。</p><h2 id="2-3-final"><a href="#2-3-final" class="headerlink" title="2.3 final"></a>2.3 final</h2><hr><h1 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3 有序性"></a>3 有序性</h1>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类加载</title>
    <link href="/2020/08/27/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/08/27/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgnUA0yWY5iFMPbBDyUeYjpvUWVk.jpeg"></h2><h1 id="1-加载"><a href="#1-加载" class="headerlink" title="1 加载"></a>1 加载</h1><ol><li>通过一个类的全限定名<strong>获取定义此类的二进制字节流</strong><ol><li>可以不从 class 文件中获取</li></ol></li><li>将二进制字节流代表的<strong>静态存储结构</strong>转化为<strong>方法区</strong>的<strong>运行时数据结构</strong></li><li>在<strong>堆</strong>中生成一个代表这个类的 java.lang.<strong>Class 对象</strong>，作为程序访问方法区这个类型数据的外部接口</li></ol><h2 id="1-1-类加载器"><a href="#1-1-类加载器" class="headerlink" title="1.1 类加载器"></a>1.1 类加载器</h2><h3 id="1-1-1-类与类加载器"><a href="#1-1-1-类与类加载器" class="headerlink" title="1.1.1 类与类加载器"></a>1.1.1 类与类加载器</h3><h3 id="1-1-2-双亲委派模型"><a href="#1-1-2-双亲委派模型" class="headerlink" title="1.1.2 双亲委派模型"></a>1.1.2 双亲委派模型</h3><hr><h1 id="2-连接"><a href="#2-连接" class="headerlink" title="2 连接"></a>2 连接</h1><ul><li>加载阶段与连接阶段的部分动作是<strong>交叉进行</strong>的，但<strong>开始时间有固定的先后顺序</strong></li></ul><h2 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h2><ul><li>为确保 Class 文件的字节流所包含信息符合 JVM 规范的全部约束要求，保证这些信息被当做代码运行后不会危害 JVM 自身的安全。</li></ul><h2 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h2><ul><li>为类变量（类中的静态变量）分配内存</li><li>为类变量设置初始值<ul><li>不为 final 类型的置为 0</li><li>final 类型直接赋值</li></ul></li></ul><h2 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h2><ul><li>解析阶段是 JVM 将常量池（在方法区中）内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程<ul><li>符号引用：以一组<strong>符号描述</strong>所引用的目标（引用的目标未必已经在 JVM 内存中）</li><li>直接引用：是可以<strong>直接指向目标的指针</strong>，<strong>相对偏移量</strong>，一个能<strong>间接定位到目标的句柄</strong>（引用的目标必定已经在 JVM 内存中）</li></ul></li></ul><h3 id="2-3-1-类-结构的解析"><a href="#2-3-1-类-结构的解析" class="headerlink" title="2.3.1 类/结构的解析"></a>2.3.1 类/结构的解析</h3><h3 id="2-3-2-字段的解析"><a href="#2-3-2-字段的解析" class="headerlink" title="2.3.2 字段的解析"></a>2.3.2 字段的解析</h3><h3 id="2-3-3-方法解析"><a href="#2-3-3-方法解析" class="headerlink" title="2.3.3 方法解析"></a>2.3.3 方法解析</h3><hr><h1 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3 初始化"></a>3 初始化</h1><ul><li><p>初始化阶段就是执行类构造器**<clinit>()方法**的过程</p><ul><li><clinit>()方法并非程序员在代码中编写的，而是<strong>javac 编译器</strong>自动收集<strong>类中所有类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并产生</li></ul></li><li><p>当初始化一个类的时候，若发现其父类还未初始化，则需要先初始化父类</p></li><li><p>JVM 会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</p><ul><li>若多个线程同时初始化一个类，只有一个线程会执行<clinit>()方法，其余线<strong>程阻塞等待</strong>。（P279）</li></ul></li><li><p><clinit>()方法<strong>不是必须的</strong></p><ul><li>若一个类中没有静态代码块和类变量的赋值动作，则 javac 编译器可以不为这个类生成<clinit>()方法</li></ul></li><li><p><strong>主导：</strong></p><ul><li>前面的步骤除自定义类加载器方式（获取二进制字节流）局部参与外，其余完全由<strong>JVM 主导控制</strong></li><li>直到初始化阶段，JVM 才真正开始执行类中编写的 java 代码，由<strong>应用程序主导控制</strong></li></ul></li></ul><hr><h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h1><h1 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5 卸载"></a>5 卸载</h1>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GC</title>
    <link href="/2020/08/27/java%E5%9F%BA%E7%A1%80/JVM/GC/"/>
    <url>/2020/08/27/java%E5%9F%BA%E7%A1%80/JVM/GC/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fv2VEpieE289bFYEbNSj-GGFWeFu.jpeg"></p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><ul><li>初步判断是否频繁 gc，以及 gc 效果：<ul><li>jstat -gc 进程 id 刷新间隔时间 ms</li><li>jstat -gc 7904 5000<ul><li>S0C：第一个幸存区的大小</li><li>S1C：第二个幸存区的大小</li><li>S0U：第一个幸存区的使用大小</li><li>S1U：第二个幸存区的使用大小</li><li>EC：伊甸园区的大小</li><li>EU：伊甸园区的使用大小</li><li>OC：老年代大小</li><li>OU：老年代使用大小</li><li>MC：方法区大小</li><li>MU：方法区使用大小</li><li>CCSC:压缩类空间大小</li><li>CCSU:压缩类空间使用大小</li><li>YGC：年轻代垃圾回收次数</li><li>YGCT：年轻代垃圾回收消耗时间</li><li>FGC：老年代垃圾回收次数</li><li>FGCT：老年代垃圾回收消耗时间</li><li>GCT：垃圾回收消耗总时间</li></ul></li></ul></li><li>打印 gc 日志<ul><li>-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/Users/will/ideaProjects/hjzn/main_fab_core/gclogs</li></ul></li><li>初步分析 jvm 内存：<ul><li>jmap -histo:live 7904 | head -17</li><li>jmap -histo:live 进程 id | head -17</li></ul></li><li>分析 dump 文件<ul><li>生成 dump 文件：<ul><li>jmap -dump:format=b,file=heap.log 38510</li></ul></li><li>分析 dump 文件：<ul><li>jhat -port 9998 /tmp/dump.dat</li><li></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud</title>
    <link href="/2020/08/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Cloud/"/>
    <url>/2020/08/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Cloud/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FqQYn20mWNJl66-qEf1EmkHdQ6Ru.jpeg"></p><h1 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1 Eureka"></a>1 Eureka</h1><h2 id="1-0-Eureka-与-Zookeeper-对比"><a href="#1-0-Eureka-与-Zookeeper-对比" class="headerlink" title="1.0 Eureka 与 Zookeeper 对比"></a>1.0 Eureka 与 Zookeeper 对比</h2><ul><li>Eureka： <strong>符合 AP 原则</strong> 为了保证了可用性，Eureka 不会等待集群所有节点都已同步信息完成，它会无时无刻提供服务。<ul><li>注：2018 年已官宣停止维护</li></ul></li><li>Zookeeper： <strong>符合 CP 原则</strong> 为了保证一致性，在所有节点同步完成之前是阻塞状态的。</li><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FghKc7yychyX0uiccQDuHg9JFAAe.png"></li><li><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FkpWfwdQO6tlALG4GgkHggnlU6Jd.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvCry-jadnLgyDS_2NucFa1x3xJe.webp"></p><ul><li>蓝色的  Eureka Server  是  Eureka  服务器。<ul><li>这三个代表的是集群，而且他们是<strong>去中心化</strong>的。</li></ul></li><li>绿色的  Application Client  是  Eureka  客户端。<ul><li>其中可以是消费者和提供者，最左边的就是典型的提供者，它需要向  Eureka  服务器注册自己和发送心跳包进行续约，而其他消费者则通过  Eureka  服务器来获取提供者的信息以调用他们</li></ul></li></ul><h2 id="1-1-服务提供者"><a href="#1-1-服务提供者" class="headerlink" title="1.1 服务提供者"></a>1.1 服务提供者</h2><ul><li><strong>服务注册：</strong></li></ul><p>启动的时候会通过发送 REST 请求的方式将自己注册到 Eureka Server 上，同时带上了自身服务的一些元数据。</p><ul><li><strong>服务续约：</strong></li></ul><p>xx 在注册完服务之后，服务提供者会维护一个心跳（默认每隔 30s 发送一次）用来持续告诉 Eureka Server: “我还活着 ” 、</p><ul><li><strong>服务下线：</strong></li></ul><p>当服务实例进行正常的关闭操作时，它会触发一个服务下线的 REST 请求给 Eureka Server, 告诉服务注册中心：“我要下线了 ”。</p><h2 id="1-2-服务消费者"><a href="#1-2-服务消费者" class="headerlink" title="1.2 服务消费者"></a>1.2 服务消费者</h2><ul><li><strong>获取服务：</strong></li></ul><p>当我们启动服务消费者的时候，它会发送一个 REST 请求给服务注册中心，来获取上面注册的服务列表信息（该注册列表信息定期 30s 更新一次）</p><ul><li><strong>服务调用：</strong></li></ul><p>服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，优先访问同处一个 Zone 中的服务提供方。</p><h2 id="1-3-Eureka-Server-服务注册中心"><a href="#1-3-Eureka-Server-服务注册中心" class="headerlink" title="1.3 Eureka Server(服务注册中心)"></a>1.3 Eureka Server(服务注册中心)</h2><ul><li><strong>失效剔除：</strong></li></ul><p>默认每隔一段时间（默认为 60 秒） 将当前清单中超时（默认为 90 秒，3 个续约周期）没有续约的服务从注册表中删除。</p><ul><li><strong>自我保护：</strong></li></ul><p>EurekaServer 在运行期间，会统计心跳失败的比例在 15 分钟之内是否低于 85%(通常由于网络不稳定导致)。 Eureka Server 会将当前的实例注册信息保护起来， 让这些实例不会过期，尽可能保护这些注册信息。</p><hr><h1 id="2-Ribbon"><a href="#2-Ribbon" class="headerlink" title="2 Ribbon"></a>2 Ribbon</h1><ul><li>让服务<strong>调用端</strong>具备<strong>负载均衡</strong>能力，不用在服务集群内再架设负载均衡服务，很大程度简化了服务集群内的架构。<ul><li>RestTemplate 内部调用负载均衡拦截器，拦截器内最终是调用了负载均衡器来选择服务实例。</li></ul></li></ul><h2 id="2-1-Nginx-和-Ribbon-的对比"><a href="#2-1-Nginx-和-Ribbon-的对比" class="headerlink" title="2.1 Nginx 和 Ribbon 的对比"></a>2.1 Nginx 和 Ribbon 的对比</h2><ul><li>Nginx<ul><li><strong>集中式</strong>的负载均衡器，接收了所有的请求后进行负载均衡</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgKizsKTdZ4362lf35lTMUVoJoun.webp"></p><ul><li>Ribbon<ul><li>先在客户端进行负载均衡才进行请求的</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FrlmTV4jNB1jtLFsJ9od3113WK4L.webp"></p><h2 id="2-2-Ribbon-中的负载均衡算法"><a href="#2-2-Ribbon-中的负载均衡算法" class="headerlink" title="2.2 Ribbon 中的负载均衡算法"></a>2.2 Ribbon 中的负载均衡算法</h2><ul><li><strong>RoundRobinRule</strong>：轮询策略（Ribbon 默认采用的策略）。若经过一轮轮询没有找到可用的<code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 null。</li><li><strong>RandomRule</strong>: 随机策略，从所有可用的 provider 中随机选择一个。</li><li><strong>RetryRule</strong>: 重试策略。先按照 RoundRobinRule 策略获取 provider，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li><li>等等。。。</li><li><strong>自定义负载均衡算法。</strong><ul><li>只需要实现<code>com.netflix.loadbalancer.IRule</code>接口，然后修改配置文件或者自定义<code>Java Config</code>类。</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#更换负载均衡算法</span><br><span class="hljs-attr">providerName:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span><br></code></pre></td></tr></table></figure><hr><h1 id="3-Hystrix"><a href="#3-Hystrix" class="headerlink" title="3 Hystrix"></a>3 Hystrix</h1><h2 id="3-1-Fallback-失败快速返回-："><a href="#3-1-Fallback-失败快速返回-：" class="headerlink" title="3.1 Fallback(失败快速返回)："></a>3.1 Fallback(失败快速返回)：</h2><pre><code class="hljs">当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方返回一个错误响应， 而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</code></pre><h2 id="3-2-资源-依赖隔离-线程池隔离-："><a href="#3-2-资源-依赖隔离-线程池隔离-：" class="headerlink" title="3.2 资源/依赖隔离(线程池隔离)："></a>3.2 资源/依赖隔离(线程池隔离)：</h2><pre><code class="hljs">它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响， 而不会拖慢其他的依赖服务。</code></pre><ul><li>参数：<ul><li>滑动窗口大小（20）、</li><li>熔断器开关间隔（重新检测该触发条件，判断是否把熔断器关闭，或者继续打开的时间间隔）</li><li>错误率（超过错误率时，会打开熔断器，此时再调用此服务，将会直接返回失败，不再调远程服务）</li></ul></li></ul><h2 id="3-3-Hystrix-仪表盘："><a href="#3-3-Hystrix-仪表盘：" class="headerlink" title="3.3 Hystrix 仪表盘："></a>3.3 Hystrix 仪表盘：</h2><pre><code class="hljs">它主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。</code></pre><hr><h1 id="4-Feign-与-OpenFeign"><a href="#4-Feign-与-OpenFeign" class="headerlink" title="4 Feign 与 OpenFeign"></a>4 Feign 与 OpenFeign</h1><ul><li>OpenFeign 在 Feign 的基础上支持了 Spring MVC 的注解</li><li>Ribbon 和 Hystrix 这两个框架的使用几乎是同时出现的–&gt;Feign 整合了 Spring Cloud Ribbon 与 Spring Cloud Hystrix,还提供了声明式的服务调用(不再通过 RestTemplate)</li></ul><h2 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgmfJFw7JJDlFtwRUrlvv0LF44Qm.png"></p><ol><li>通过 Spring IOC 容器实例，<strong>装配代理实例</strong>，然后进行远程调用。</li><li>执行 **InvokeHandler **调用处理器的 invoke(…)方法<ol><li>调用到默认的 FeignInvocationHandler 调用处理器实例的 invoke(…)方法</li><li>默认的调用处理器 FeignInvocationHandle，内部保持了一个远程调用方法实例和方法处理器的一个 Key-Value 键值对 Map 映射。FeignInvocationHandle 在其 invoke(…)方法中，会根据 Java 反射的方法实例，在 dispatch 映射对象中，找到对应的 MethodHandler 方法处理器，然后由后者完成实际的 HTTP 请求和结果的处理。</li></ol></li><li>执行 **MethodHandler **方法处理器的 invoke(…)方法<ol><li>feign 默认的方法处理器为 SynchronousMethodHandler，其 invoke(…)方法主要是通过内部成员 feign 客户端成员 client，完成远程 URL 请求执行和获取远程结果。</li></ol></li><li>通过** feign.Client** 客户端成员，完成远程 URL 请求执行和获取远程结果</li></ol><hr><h1 id="5-SpringCloud-gateway"><a href="#5-SpringCloud-gateway" class="headerlink" title="5 SpringCloud gateway"></a>5 SpringCloud gateway</h1><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h2><ul><li><p>外层调用都必须通过 API 网关，使得将维护服务实例的工作交给了服务治理框架自动完成。</p><table><thead><tr><th></th><th>zuul</th><th>zuul2</th><th>Gateway</th></tr></thead><tbody><tr><td>所属公司</td><td>Netflix</td><td>Netflix</td><td>springcloud</td></tr><tr><td>springboot 版本</td><td>springcloud 1.x</td><td>Springcloud 2.x</td><td>Springcloud 2.x</td></tr><tr><td>架构</td><td>基于 Servlet 2.5,使用阻塞架构，不支持任何长连接</td><td>基于 Netty 非阻塞</td><td>基于 webFlux 非阻塞</td></tr><tr><td>长连接</td><td>不支持任何长连接</td><td>支持</td><td>支持</td></tr><tr><td>性能</td><td>已过时</td><td>较好</td><td>较好</td></tr></tbody></table></li><li><p>工作原理</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fh7k7es_KunqJjc3EDcS3N3vBVPH.webp"></p><h2 id="5-2-配置"><a href="#5-2-配置" class="headerlink" title="5.2 配置"></a>5.2 配置</h2><hr><h1 id="6-Spring-Cloud-Config"><a href="#6-Spring-Cloud-Config" class="headerlink" title="6 Spring Cloud Config"></a>6 Spring Cloud Config</h1><ul><li>Spring Cloud Config 项目是一个解决分布式系统的<strong>配置管理</strong>方案。</li><li>它包含了 Client 和 Server 两个部分<ul><li>server 提供配置文件的存储、以接口的形式将配置文件的内容提供出去</li><li>client 通过接口获取数据、并依据此数据初始化自己的应用。</li></ul></li></ul><p>简单来说，使用 Spring Cloud Config 就是将配置文件放到统一的位置管理(比如 GitHub)，客户端通过接口去获取这些配置文件。在 GitHub 上修改了某个配置文件，应用加载的就是修改后的配置文件。</p><hr><h1 id="7-UAA"><a href="#7-UAA" class="headerlink" title="7 UAA"></a>7 UAA</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FjlBcKTpPPPyZ_9sVvgmfCrukYVn.png"><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FvZKVa8yiBxYkFNM8A3XhXcOvF5h.png"></p>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot</title>
    <link href="/2020/08/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Boot/"/>
    <url>/2020/08/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Boot/</url>
    
    <content type="html"><![CDATA[<p>–启动：</p><ul><li>new SpringApplication()：创建 SpringApplication 实例，负责加载配置一些基本的环境变量、资源、构造器、监听器</li><li>run()：负责 springboot 整个启动过程，包括加载创建环境、打印 banner、配置文件、配置应用上下文，加载 bean 等等 sb 整个生命周期几乎都在 run 方法中；</li></ul><p>–配置<br>Spring Cloud 构建于 Spring Boot 之上，在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。<br>bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何 Spring 应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。</p><ul><li><p>bootstrap</p><ul><li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li><li>一些固定的<strong>不能被覆盖</strong>的属性</li><li>一些加密/解密的场景</li></ul></li><li><p>application</p><ul><li>applcation.properties 文件中指定当前的环境 spring.profiles.active=test，这时候读取的就是 application-test.yml 文件。</li></ul><p>Spring Boot 项目的自动化配置。</p></li><li><p>YAML 语法：</p><ul><li>以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。</li><li>注意不能用 tab 代替空格</li><li>且大小写敏感</li><li>字面值：字符串，布尔类型，数值，日期。字符串默认不加引号，单引号或者不加引号会转义特殊字符，双引号直接输出。日期格式支持 yyyy/MM/dd HH:mm:ss</li><li>对象：由键值对组成，形如 key:(空格)value 的数据组成。冒号后面的空格是必须要有的，每组键值对占用一行，且缩进的程度要一致，也可以使用行内写法：{k1: v1, ….kn: vn}</li><li>数组：由形如 -(空格)value 的数据组成。短横线后面的空格是必须要有的，每组数据占用一行，且缩进的程度要一致，也可以使用行内写法： [1,2,…n]</li><li>复合结构：上面三种数据结构任意组合</li></ul></li></ul><p>–注解：<br>@ConfigurationProperties(prefix = “library”)   读取配置信息并与 bean 绑定。<br>@EnableConfigurationProperties       注解的作用是：使使用 @ConfigurationProperties 注解的类生效。<br>eg：@EnableConfigurationProperties(RedisProperties.class)<br>@SpringBootApplication<br>@Configuration         允许在 Spring 上下文中注册额外的 bean 或导入其他配置类  <br>@ComponentScan         注解默认会扫描该类所在的包下所有的类。<br>@EnableAutoConfiguration       启用 SpringBoot 的自动配置机制<br> @Import(AutoConfigurationImportSelector.class)   借助 AutoConfigurationImportSelector，@EnableAutoConfiguration 可以帮助 SpringBoot 应用将所有符合条件的@Configuration 配置都加载到当前 SpringBoot 创建并使用的 IoC 容器。</p>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Framework</title>
    <link href="/2020/08/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Framework/"/>
    <url>/2020/08/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%A1%86%E6%9E%B6/spring/Spring%20Framework/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Spring-MVC"><a href="#1-Spring-MVC" class="headerlink" title="1 Spring MVC"></a>1 Spring MVC</h1><ul><li>Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC 框架（一些用 Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot</li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FpjVVCaSqSJZBUQuesaQUfb1IyPG.png"><br><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FsiTzpJlXxan02k5JoIBDR7A-UIw.jpeg?x-oss-process=image/auto-orient,1"></p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fij1jsx_uA-2AlAT2O7DbpWE6sir.png"></p><h1 id="2-bean-生命周期"><a href="#2-bean-生命周期" class="headerlink" title="2 bean 生命周期"></a>2 bean 生命周期</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FmKLo8YIeqm_-EflprdvHYSgBwps.png"></p>]]></content>
    
    
    <categories>
      
      <category>中间件与框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2020/08/27/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/08/27/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-锁"><a href="#1-锁" class="headerlink" title="1 锁"></a>1 锁</h1><h2 id="1-1-synchronized"><a href="#1-1-synchronized" class="headerlink" title="1.1 synchronized"></a>1.1 synchronized</h2><h3 id="1-1-1-锁升级"><a href="#1-1-1-锁升级" class="headerlink" title="1.1.1 锁升级"></a>1.1.1 锁升级</h3><p><strong>Hotspot 实现：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fnfai6GntcGYzKTH0Q3Wnhf6AMuP.jpeg"></p><hr><h3 id="1-1-2-锁消除"><a href="#1-1-2-锁消除" class="headerlink" title="1.1.2 锁消除"></a>1.1.2 锁消除</h3><h3 id="1-1-3-锁粗化"><a href="#1-1-3-锁粗化" class="headerlink" title="1.1.3 锁粗化"></a>1.1.3 锁粗化</h3><hr><h2 id="1-2-Lock"><a href="#1-2-Lock" class="headerlink" title="1.2 Lock"></a>1.2 Lock</h2><hr><h2 id="1-3-volatile"><a href="#1-3-volatile" class="headerlink" title="1.3 volatile"></a>1.3 volatile</h2><hr><h1 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2 ThreadLocal"></a>2 ThreadLocal</h1><ul><li><strong>应用：</strong><ul><li>Spring 中的@Transaction 中有应用</li><li>SpringSecurity 中有应用</li><li>myBatis 的 PageHelper 分页插件</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FiGSQzI-UOT3iHxetWDde-oaq3Ms.jpeg"></p><ul><li><strong>Thread,ThreadLocal,ThreadLocalMap 三者关系：</strong><ul><li>线程类 Thread 内部持有 ThreadLocalMap 的成员变量</li><li>ThreadLocalMap 是 ThreadLocal 的内部类</li><li>ThreadLocal 操作了 thread 内部持有的 ThreadLocalMap 对象内部的数据，对外暴露的都是 ThreadLocal 的方法 API，隐藏了 ThreadLocalMap 的具体实现</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fr4K7ZOfI3zlL2PSRzFx3nrBNS8q.jpeg"></p><ul><li><strong>ThreadLocalMap 理解：</strong><ul><li>创建的 table 可以看成一个哈希表，默认大小是 16，即有 16 个槽(slot)。创建 table 完毕，根据 firstKey 算出本次插入的槽位，然后用内部类 Entry 将两个值包装成键值对(entry)，放入槽中：table[i] = new Entry(firstKey, firstValue);</li></ul></li><li><strong>内存泄漏分析</strong><ul><li><strong>防止无法回收 threadLocal</strong><ul><li><strong>threadLocalMap 中 entry 的 key 为弱引用</strong></li><li><strong>当线程一直存在时，即使 threadLocal 不再使用，若不是弱引用，就无法回收 threadLocal</strong></li></ul></li><li><strong>防止 entry 与 value 无法回收</strong><ul><li>**用完后需要手动 remove() 即：置 value 与 entry 为 null; **</li><li><strong>当线程一直存在时，若不 remove，就可能会内存泄漏；但是当线程销毁时，即使不 remove，也不会泄漏</strong></li></ul></li></ul></li></ul><hr><h1 id="3-创建线程"><a href="#3-创建线程" class="headerlink" title="3 创建线程"></a>3 创建线程</h1><hr><h1 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4 线程池"></a>4 线程池</h1><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fg7UlO56cgzZ7elQA-mscsOTzgln.png"></p><h2 id="4-1-阻塞队列"><a href="#4-1-阻塞队列" class="headerlink" title="4.1 阻塞队列"></a>4.1 阻塞队列</h2><p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/Fthds15rrsnV2SdIn3ge_SJWqCXp.png"></p><hr><h2 id="4-2-七大参数"><a href="#4-2-七大参数" class="headerlink" title="4.2 七大参数"></a>4.2 七大参数</h2><ul><li><strong>corePoolSize：</strong> 线程池核心线程数最大值</li><li><strong>maximumPoolSize：</strong> 线程池最大线程数大小</li><li><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</li><li><strong>unit：</strong> 线程空闲存活时间单位</li><li><strong>workQueue：</strong> 存放任务的阻塞队列</li><li><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li><strong>handler：</strong> 线城池的饱和策略事件，主要有四种类型。</li></ul><hr><h2 id="4-3-拒绝策略"><a href="#4-3-拒绝策略" class="headerlink" title="4.3 拒绝策略"></a>4.3 拒绝策略</h2><ul><li>AbortPolicy(抛出一个异常，默认的)</li><li>DiscardPolicy(直接丢弃任务)</li><li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li><li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li></ul><hr><h2 id="4-4-JDK1-5-后-Executors"><a href="#4-4-JDK1-5-后-Executors" class="headerlink" title="4.4 JDK1.5 后 Executors"></a>4.4 JDK1.5 后 Executors</h2><hr><h1 id="5-Fork-Join"><a href="#5-Fork-Join" class="headerlink" title="5 Fork/Join"></a>5 Fork/Join</h1><p><a href="https://zhuanlan.zhihu.com/p/366781946">https://zhuanlan.zhihu.com/p/366781946</a></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2020/08/27/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    <url>/2020/08/27/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/heheii/blog-imag/blog-images/FgNNG85_rtKsyWW37yV2uHusOtzp.jpeg"></p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>结构：<ul><li>Entry[] 哈希桶数组（默认大小为 16）</li><li>链表</li><li>红黑树</li></ul></li><li>Entry 节点：</li></ul><p>hash、key、value、next</p><ul><li><p>插入方式：</p><p>1.8 前为头插法（并发时可能导致死循环）<br>因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。<br>1.8 及以后为尾插法（并发不会死循环）</p></li><li><p>线程不安全</p><ul><li>1.8 前 头插法，并发时可能造成死循环</li><li>1.8 后 尾插法，没有死循环。并发时插入数据可能被覆盖</li></ul></li></ul><hr><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
